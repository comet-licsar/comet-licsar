<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>licsar_proc.python.LiCSAR_lib.lics_unwrap &mdash; COMET LiCSAR  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> COMET LiCSAR
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../wiki.html">LiCSAR Wiki (from gitlab)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Main LiCSAR Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../licsar_db/index.html">LiCSInfo db</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../licsar_proc/index.html">LiCSAR proc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../licsar_framebatch/index.html">LiCSAR Framebatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../daz/index.html">daz</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../licsar_proc/apidoc.html">LiCSAR proc</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Further information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ciw.html">COMET InSAR Workshop Materials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer comments and advices</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation.html">Notes about documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation.html#admin-or-dev-comments">Admin or dev comments</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">COMET LiCSAR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">licsar_proc.python.LiCSAR_lib.lics_unwrap</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for licsar_proc.python.LiCSAR_lib.lics_unwrap</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="c1">################################################################################</span>
<span class="c1"># LiCSAR Unwrapper</span>
<span class="c1"># by Milan Lazecky, 2021-2022, University of Leeds</span>
<span class="c1">#</span>
<span class="c1"># version: 1.0.0 (2022-06-03)</span>
<span class="c1">#</span>
<span class="c1"># A tool to unwrap LiCSAR (or any other) interferogram, starting from geotiffs</span>
<span class="c1"># Mandatory inputs: geotiffs of phase, coherence</span>
<span class="c1"># Optional inputs: geotiffs with GACOS corrections, DEM, landmask (automatically found for LiCSAR)</span>
<span class="c1">#</span>
<span class="c1"># Pre-requisities: snaphu</span>
<span class="c1"># Optional requisites: GMT, cpxfiddle (doris), ImageMagick</span>
<span class="c1">#</span>
<span class="c1">################################################################################</span>
<span class="c1">#Imports</span>
<span class="c1">################################################################################</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">subprocess</span>

<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="n">xr</span><span class="o">.</span><span class="n">set_options</span><span class="p">(</span><span class="n">keep_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">rioxarray</span>
<span class="kn">from</span> <span class="nn">osgeo</span> <span class="kn">import</span> <span class="n">gdal</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">generic_filter</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sps</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">spl</span>
<span class="kn">from</span> <span class="nn">astropy.convolution</span> <span class="kn">import</span> <span class="n">Gaussian2DKernel</span><span class="p">,</span> <span class="n">interpolate_replace_nans</span><span class="p">,</span> <span class="n">convolve_fft</span><span class="p">,</span> <span class="n">convolve</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">HuberRegressor</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">glob</span>

<span class="c1"># avoid cv2 in ipynb</span>
<span class="k">def</span> <span class="nf">in_ipynb</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cfg</span> <span class="o">=</span> <span class="n">get_ipython</span><span class="p">()</span><span class="o">.</span><span class="n">config</span> 
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">if not in_ipynb():</span>
<span class="sd">    # some extra imports, used by additional functions</span>
<span class="sd">    try:</span>
<span class="sd">        import cv2</span>
<span class="sd">    except:</span>
<span class="sd">        print(&#39;cv2 not loaded - cascade will not work&#39;)</span>
<span class="sd">else:</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="k">if</span> <span class="n">in_ipynb</span><span class="p">():</span>
    <span class="c1">#print(&#39;at JASMIN notebook service, cv2 does not load - cascade will not work&#39;)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;setting pyproj data directory&#39;</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">pyproj</span>
    <span class="n">pyproj</span><span class="o">.</span><span class="n">datadir</span><span class="o">.</span><span class="n">set_data_dir</span><span class="p">(</span><span class="s1">&#39;/gws/smf/j04/nceo_geohazards/software/mambalics/share/proj&#39;</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;dask not loaded - hgt correlation will not work&#39;</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">LiCSAR_lib.LiCSAR_misc</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;licsar misc not loaded&#39;</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">LiCSBAS_io_lib</span> <span class="k">as</span> <span class="nn">io</span>
    <span class="kn">from</span> <span class="nn">LiCSBAS_tools_lib</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;licsbas not loaded - the amplitude/coherence average/stability will fail&#39;</span><span class="p">)</span>


<span class="c1">################################################################################</span>
<span class="c1"># Main functions to perform the unwrapping</span>
<span class="c1">################################################################################</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">class UnwOptions(object):</span>
<span class="sd">    def __init__(self):</span>
<span class="sd">        self.frame = None</span>
<span class="sd">        self.pair = None</span>
<span class="sd">        self.procdir = os.getcwd()</span>
<span class="sd">        </span>
<span class="sd">        # standard ifg processing parameters</span>
<span class="sd">        self.ml = 10</span>
<span class="sd">        self.fillby = &#39;nearest&#39;</span>
<span class="sd">        self.thres = 0.3</span>
<span class="sd">        self.smooth = False</span>
<span class="sd">        self.lowpass = True</span>
<span class="sd">        self.goldstein = True</span>
<span class="sd">        self.specmag = False</span>
<span class="sd">        self.defomax = 0.6</span>
<span class="sd">        self.hgtcorr = False</span>
<span class="sd">        self.gacoscorr = True</span>
<span class="sd">        self.pre_detrend = True</span>
<span class="sd">        self.cliparea_geo = None</span>
<span class="sd">        self.outtif = None</span>
<span class="sd">        self.prevest = None</span>
<span class="sd">        self.prev_ramp = None</span>
<span class="sd">        self.coh2var = False</span>
<span class="sd">        self.add_resid = True</span>
<span class="sd">        self.rampit=False</span>
<span class="sd">        self.subtract_gacos = False</span>
<span class="sd">        self.dolocal = False,</span>
<span class="sd">        self.cohratio = None</span>
<span class="sd">        self.keep_coh_debug = True</span>
<span class="sd">        </span>
<span class="sd">        # parameters for cascade processing</span>
<span class="sd">        self.downtoml = 1</span>
<span class="sd">        self.only10 = True</span>
<span class="sd">        #</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    def show_params(self):</span>
<span class="sd">        for x in self.__dict__.items():</span>
<span class="sd">            print(x[0]+&#39;: &#39;+str(x[1]))</span>
<span class="sd">&#39;&#39;&#39;</span>
<div class="viewcode-block" id="cascade_unwrap"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.cascade_unwrap">[docs]</a><span class="k">def</span> <span class="nf">cascade_unwrap</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">downtoml</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span>
                   <span class="n">only10</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">thres</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
                   <span class="n">outtif</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dolocal</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main function to unwrap a geocoded LiCSAR interferogram using a cascade approach.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        frame (string): LiCSAR frame ID</span>
<span class="sd">        pair (string): identifier of interferometric pair, e.g. &#39;20200120_20200201&#39;</span>
<span class="sd">        downtoml (int): target multilook factor (default: 1, no extra multilooking)</span>
<span class="sd">        procdir (string): path to processing directory</span>
<span class="sd">        only10 (boolean): switch to use only 1 previous ramp, scaled 10x to the downtoml, instead of few cascades</span>
<span class="sd">        smooth (boolean): switch to use extra Gaussian filtering for 2-pass unwrapping</span>
<span class="sd">        thres (float): threshold between 0-1 for gaussian-based coherence-like measure (spatial phase consistence?); higher number - more is masked prior to unwrapping</span>
<span class="sd">        </span>
<span class="sd">        hgtcorr (boolean): switch to perform correction for height-phase correlation.</span>
<span class="sd">        outtif (string or None): path to geotiff file to export result to.</span>
<span class="sd">        cliparea_geo (string or None): use GMT/LiCSBAS string to identify area to clip, in geo-coordinates, as ``&#39;lon1/lon2/lat1/lat2&#39;``</span>
<span class="sd">        subtract_gacos (boolean): switch whether to return the interferograms with GACOS being subtracted (by default, GACOS is used only to support unwrapping and would be added back)</span>
<span class="sd">        dolocal (boolean): switch to use local directory to find interferograms, rather than search for LiCSAR_public directory in JASMIN</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: unwrapped multilooked interferogram with additional layers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;performing cascade unwrapping&#39;</span><span class="p">)</span>
    <span class="n">starttime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">only10</span><span class="p">:</span>
        <span class="c1"># 01/2022: updating parameters:</span>
        <span class="n">ifg_ml10</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">downtoml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">rampit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">downtoml</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># avoiding gauss proc, as seems heavy for memory</span>
            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">downtoml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">ifg_ml10</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">],</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">outtif</span><span class="o">=</span><span class="n">outtif</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">downtoml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">ifg_ml10</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">],</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">outtif</span><span class="o">=</span><span class="n">outtif</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ifg_mlc</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">rampit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">downtoml</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">ifg_mla</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">],</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">rampit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
                <span class="n">ifg_mlc</span> <span class="o">=</span> <span class="n">ifg_mla</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">downtoml</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># avoiding gauss proc, as seems heavy for memory</span>
            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">downtoml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">],</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">outtif</span><span class="o">=</span><span class="n">outtif</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">downtoml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">],</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">outtif</span><span class="o">=</span><span class="n">outtif</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
    <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">starttime</span>
    <span class="n">hour</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elapsed_time</span><span class="o">/</span><span class="mi">3600</span><span class="p">)</span>
    <span class="n">minite</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">((</span><span class="n">elapsed_time</span><span class="o">/</span><span class="mi">60</span><span class="p">),</span><span class="mi">60</span><span class="p">))</span>
    <span class="n">sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span><span class="mi">60</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Total elapsed time: </span><span class="si">{0:02}</span><span class="s2">h </span><span class="si">{1:02}</span><span class="s2">m </span><span class="si">{2:02}</span><span class="s2">s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hour</span><span class="p">,</span><span class="n">minite</span><span class="p">,</span><span class="n">sec</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ifg_ml</span></div>


<span class="k">def</span> <span class="nf">get_cliparea_xr</span><span class="p">(</span><span class="n">xrd</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">xrd</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">min</span><span class="p">()))</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">xrd</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">xrd</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">min</span><span class="p">()))</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">xrd</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">max</span><span class="p">()))</span>


<div class="viewcode-block" id="process_ifg"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.process_ifg">[docs]</a><span class="k">def</span> <span class="nf">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> 
        <span class="n">ml</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">lowpass</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">goldstein</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">specmag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prevest</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coh2var</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>  <span class="n">rampit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dolocal</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cohratio</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main function to unwrap a geocoded LiCSAR interferogram. Works on JASMIN (but can be easily adapted for local use)</span>
<span class="sd">    Args:</span>
<span class="sd">        frame (string): LiCSAR frame ID</span>
<span class="sd">        pair (string): identifier of interferometric pair, e.g. ``&#39;20200120_20200201&#39;``</span>
<span class="sd">        procdir (string): path to processing directory</span>
<span class="sd">        ml (int): multilooking factor used to reduce the interferogram in lon/lat</span>
<span class="sd">        fillby (string): algorithm to fill gaps. use one of values: ``&#39;gauss&#39;``, ``&#39;nearest&#39;``, ``&#39;none&#39;`` (where ``&#39;none&#39;`` would only fill NaNs by zeroes)</span>
<span class="sd">        thres (float): threshold between 0-1 for gaussian-based coherence-like measure (spatial phase consistence?); higher number - more is masked prior to unwrapping</span>
<span class="sd">        smooth (boolean): switch to use extra Gaussian filtering for 2-pass unwrapping (not recommended anymore)</span>
<span class="sd">        lowpass (boolean): additional large-window Gaussian low-pass filtering (recommended to use)</span>
<span class="sd">        goldstein (boolean): use Goldstein filter (recommended to use, but might slow down the procedure)</span>
<span class="sd">        specmag (boolean): use spectral magnitude of the Goldstein filter (if it is on) as an experimental measure of coherence</span>
<span class="sd">        defomax (float): parameter to snaphu for maximum deformation in rad per 2pi cycle (DEFOMAX_CYCLE)</span>
<span class="sd">        </span>
<span class="sd">        hgtcorr (boolean): switch to perform correction for height-phase correlation</span>
<span class="sd">        gacoscorr (boolean): switch to apply GACOS corrections (if detected)</span>
<span class="sd">        pre_detrend (boolean): switch to apply detrending on wrapped phase to support unwrapping</span>
<span class="sd">        </span>
<span class="sd">        cliparea_geo (string or None): use GMT/LiCSBAS string to identify area to clip, in geo-coordinates, as ``&#39;lon1/lon2/lat1/lat2&#39;``</span>
<span class="sd">        outtif (string or None): path to geotiff file to export result to.</span>
<span class="sd">        prevest (xarray.DataArray or None): a previous rough estimate to be used by snaphu as the ESTFILE</span>
<span class="sd">        prev_ramp (xarray.DataArray or None): a previous estimate or a ramp that will be removed prior to unwrapping (and added back)</span>
<span class="sd">        </span>
<span class="sd">        coh2var (boolean): convert coherence to variance for weighting. now used wrongly, for experimentation - please avoid</span>
<span class="sd">        add_resid (boolean): switch to add back residuals from spatially filtered unwrapping (makes sense if smooth is ON)</span>
<span class="sd">        rampit (boolean): perform an extra strong gaussian filter to get a very rough unwrapping result. basically a longwave signal ramp. used by cascade approach</span>
<span class="sd">        subtract_gacos (boolean): switch whether to return the interferograms with GACOS being subtracted (by default, GACOS is used only to support unwrapping and would be added back)</span>
<span class="sd">        dolocal (boolean): switch to use local directory to find interferograms, rather than search for LiCSAR_public directory in JASMIN</span>
<span class="sd">        </span>
<span class="sd">        cohratio (xr.DataArray): coherence ratio (or another array) to be used for weighting the phase instead of the original coherence</span>
<span class="sd">        keep_coh_debug (boolean): only in combination with use_coh_stab - whether or not to keep original (downsampled) ifg coherence after using the coh_stab to weight the phase during multilooking</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: unwrapped multilooked interferogram with additional layers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ifg</span> <span class="o">=</span> <span class="n">load_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">unw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dolocal</span><span class="o">=</span><span class="n">dolocal</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error in loading data&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="c1"># prepare tmp dir structure</span>
    <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span><span class="s1">&#39;temp_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ml</span><span class="p">))</span>
    <span class="n">tmpgendir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span><span class="s1">&#39;temp_gen&#39;</span><span class="p">)</span>
    <span class="c1">#tmpunwdir = os.path.join(procdir,pair,&#39;temp_unw&#39;)</span>
    <span class="k">for</span> <span class="n">dodir</span> <span class="ow">in</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span><span class="n">pair</span><span class="p">),</span> <span class="n">tmpdir</span><span class="p">,</span> <span class="n">tmpgendir</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dodir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dodir</span><span class="p">)</span>
    
    <span class="c1"># do gacos if exists</span>
    <span class="k">if</span> <span class="n">gacoscorr</span><span class="p">:</span>
        <span class="n">gacoscorrfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpgendir</span><span class="p">,</span><span class="s1">&#39;gacos.tif&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">gacoscorrfile</span> <span class="o">=</span> <span class="n">make_gacos_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">gacoscorrfile</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error processing gacos data for pair &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
            <span class="n">gacoscorrfile</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gacoscorrfile</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="k">if</span> <span class="n">gacoscorrfile</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;GACOS data found, using to improve unwrapping&#39;</span><span class="p">)</span>
        <span class="c1">#ingacos = xr.open_dataset(gacoscorrfile)</span>
        <span class="n">ingacos</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">gacoscorrfile</span><span class="p">)</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">pha</span>
        <span class="k">if</span> <span class="n">dolocal</span><span class="p">:</span>
            <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ingacos</span><span class="o">.</span><span class="n">interp_like</span><span class="p">(</span><span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span> <span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">ingacos</span><span class="o">.</span><span class="n">values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gacoscorr</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg_core</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> 
        <span class="n">ml</span> <span class="o">=</span> <span class="n">ml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="n">fillby</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">lowpass</span> <span class="o">=</span> <span class="n">lowpass</span><span class="p">,</span> <span class="n">goldstein</span> <span class="o">=</span> <span class="n">goldstein</span><span class="p">,</span> <span class="n">specmag</span> <span class="o">=</span> <span class="n">specmag</span><span class="p">,</span>
        <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="n">gacoscorr</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="n">pre_detrend</span><span class="p">,</span>
        <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">prevest</span> <span class="o">=</span> <span class="n">prevest</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">prev_ramp</span><span class="p">,</span>
        <span class="n">coh2var</span> <span class="o">=</span> <span class="n">coh2var</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="n">add_resid</span><span class="p">,</span>  <span class="n">rampit</span><span class="o">=</span><span class="n">rampit</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span>
        <span class="n">cohratio</span> <span class="o">=</span> <span class="n">cohratio</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="n">keep_coh_debug</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ifg_ml</span></div>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">import glob</span>
<span class="sd">pairs=glob.glob(&#39;2*&#39;)</span>
<span class="sd">for p in pairs:</span>
<span class="sd">    print(p)</span>
<span class="sd">    phatif=os.path.join(p,p+&#39;.geo.diff_pha.tif&#39;)</span>
<span class="sd">    cohtif=os.path.join(p,p+&#39;.geo.cc.tif&#39;)</span>
<span class="sd">    outtif=os.path.join(p,p+&#39;.geo.unw.tif&#39;)</span>
<span class="sd">    b=process_ifg_pair(phatif, cohtif, procdir = os.getcwd(), ml = 1, fillby = &#39;nearest&#39;, </span>
<span class="sd">        thres = 0.3, smooth = False, lowpass = True, goldstein = True, specmag = True, defomax = 0.6, hgtcorr = False, outtif=outtif, gacoscorr = False)</span>

<span class="sd">&#39;&#39;&#39;</span>



<span class="k">def</span> <span class="nf">process_ifg_pair</span><span class="p">(</span><span class="n">phatif</span><span class="p">,</span> <span class="n">cohtif</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> 
        <span class="n">ml</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">lowpass</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">goldstein</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">specmag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prevest</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coh2var</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>  <span class="n">rampit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cohratio</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cascade</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ifg</span> <span class="o">=</span> <span class="n">load_from_tifs</span><span class="p">(</span><span class="n">phatif</span><span class="p">,</span> <span class="n">cohtif</span><span class="p">,</span> <span class="n">landmask_tif</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error in loading data&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># prepare tmp dir structure</span>
    <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span><span class="s1">&#39;tmp_unwrap&#39;</span><span class="p">,</span><span class="s1">&#39;temp_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ml</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span><span class="s1">&#39;tmp_unwrap&#39;</span><span class="p">)):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span><span class="s1">&#39;tmp_unwrap&#39;</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
    <span class="c1"># not ready now for gacos or hgt correlation</span>
    <span class="n">gacoscorr</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cascade</span><span class="p">:</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg_core</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> 
            <span class="n">ml</span> <span class="o">=</span> <span class="n">ml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="n">fillby</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">lowpass</span> <span class="o">=</span> <span class="n">lowpass</span><span class="p">,</span> <span class="n">goldstein</span> <span class="o">=</span> <span class="n">goldstein</span><span class="p">,</span> <span class="n">specmag</span> <span class="o">=</span> <span class="n">specmag</span><span class="p">,</span>
            <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="n">gacoscorr</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="n">pre_detrend</span><span class="p">,</span>
            <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">prevest</span> <span class="o">=</span> <span class="n">prevest</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">prev_ramp</span><span class="p">,</span>
            <span class="n">coh2var</span> <span class="o">=</span> <span class="n">coh2var</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="n">add_resid</span><span class="p">,</span>  <span class="n">rampit</span><span class="o">=</span><span class="n">rampit</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span>
            <span class="n">cohratio</span> <span class="o">=</span> <span class="n">cohratio</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="n">keep_coh_debug</span><span class="p">,</span>
            <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;performing 1 step cascade&#39;</span><span class="p">)</span>
        <span class="n">ml10</span><span class="o">=</span><span class="mi">10</span><span class="o">*</span><span class="n">ml</span>
        <span class="n">ifg_ml10</span> <span class="o">=</span> <span class="n">process_ifg_core</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> 
            <span class="n">ml</span> <span class="o">=</span> <span class="n">ml10</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="n">fillby</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">lowpass</span> <span class="o">=</span> <span class="n">lowpass</span><span class="p">,</span> <span class="n">goldstein</span> <span class="o">=</span> <span class="n">goldstein</span><span class="p">,</span> <span class="n">specmag</span> <span class="o">=</span> <span class="n">specmag</span><span class="p">,</span>
            <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="n">gacoscorr</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="n">pre_detrend</span><span class="p">,</span>
            <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prevest</span> <span class="o">=</span> <span class="n">prevest</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">prev_ramp</span><span class="p">,</span>
            <span class="n">coh2var</span> <span class="o">=</span> <span class="n">coh2var</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>  <span class="n">rampit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span>
            <span class="n">cohratio</span> <span class="o">=</span> <span class="n">cohratio</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="n">keep_coh_debug</span><span class="p">,</span>
            <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">)</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg_core</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> 
            <span class="n">ml</span> <span class="o">=</span> <span class="n">ml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="n">fillby</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">lowpass</span> <span class="o">=</span> <span class="n">lowpass</span><span class="p">,</span> <span class="n">goldstein</span> <span class="o">=</span> <span class="n">goldstein</span><span class="p">,</span> <span class="n">specmag</span> <span class="o">=</span> <span class="n">specmag</span><span class="p">,</span>
            <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="n">gacoscorr</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="n">pre_detrend</span><span class="p">,</span>
            <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">prevest</span> <span class="o">=</span> <span class="n">prevest</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">ifg_ml10</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">],</span>
            <span class="n">coh2var</span> <span class="o">=</span> <span class="n">coh2var</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>  <span class="n">rampit</span><span class="o">=</span><span class="n">rampit</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span>
            <span class="n">cohratio</span> <span class="o">=</span> <span class="n">cohratio</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="n">keep_coh_debug</span><span class="p">,</span>
            <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">)</span>
        <span class="n">ifg_ml10</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">ifg_ml</span>


<span class="k">def</span> <span class="nf">process_ifg_core</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> 
        <span class="n">ml</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">lowpass</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">goldstein</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">specmag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prevest</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coh2var</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>  <span class="n">rampit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cohratio</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">tmpdir</span> <span class="o">=</span> <span class="kc">None</span> <span class="p">):</span>
    <span class="c1"># masking by coherence if we do not use multilooking - here the coherence corresponds to reality</span>
    <span class="n">tmpunwdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;temp_unw&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">dodir</span> <span class="ow">in</span> <span class="p">[</span><span class="n">tmpdir</span><span class="p">,</span> <span class="n">tmpunwdir</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dodir</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dodir</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ml</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">cohthres</span> <span class="o">=</span> <span class="mf">0.15</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cohthres</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hgtcorr</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;hgt&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR in importing heights!&#39;</span><span class="p">)</span>
            <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># now doing multilooking, using coh as mag...</span>
    <span class="c1">#make complex from coh and pha</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">coh2var</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">cohratio</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="c1"># use cohratio for better weights</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="n">cohratio</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span>
        <span class="c1"># if this is better, i will change it and have it fixed</span>
        <span class="n">cohratio</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">coh</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">coh</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">cohratio</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">cohratio</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="c1">#fixing difference in xarray version...</span>
    <span class="k">if</span> <span class="s1">&#39;lat&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;warning - perhaps old xarray version - trying anyway&#39;</span><span class="p">)</span>
        <span class="n">ifg</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">rename_dims</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="s1">&#39;lat&#39;</span><span class="p">})</span>
    <span class="c1"># now crop if needed:</span>
    <span class="k">if</span> <span class="n">cliparea_geo</span><span class="p">:</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipy</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minclipy</span> <span class="o">&gt;</span> <span class="n">maxclipy</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (latitude). fixing&#39;</span><span class="p">)</span>
            <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipy</span>
            <span class="n">minclipy</span><span class="o">=</span><span class="n">maxclipy</span>
            <span class="n">maxclipy</span><span class="o">=</span><span class="n">tmpcl</span>
        <span class="k">if</span> <span class="n">minclipx</span> <span class="o">&gt;</span> <span class="n">maxclipx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (longitude). fixing&#39;</span><span class="p">)</span>
            <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipx</span>
            <span class="n">minclipx</span><span class="o">=</span><span class="n">maxclipx</span>
            <span class="n">maxclipx</span><span class="o">=</span><span class="n">tmpcl</span>
        <span class="c1"># now will clip it - lat is opposite-sorted, so need to slice from max to min in y ... plus 10 pixels on all sides</span>
        <span class="n">resdeg</span> <span class="o">=</span> <span class="n">get_resolution</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">in_m</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ifg</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">minclipx</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">,</span> <span class="n">maxclipx</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">),</span> <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">maxclipy</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">,</span> <span class="n">minclipy</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">))</span>
        <span class="c1"># not the best here, as pixels might get slightly shifted, but perhaps not that big deal (anyway prev_ramp is &#39;blurred&#39;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">prev_ramp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">prev_ramp</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">minclipx</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">,</span> <span class="n">maxclipx</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">),</span> <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">maxclipy</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">,</span> <span class="n">minclipy</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">))</span>
    <span class="c1">#WARNING - ONLY THIS FUNCTION HAS GACOS INCLUDED NOW! (and heights fix!!!)</span>
    <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">multilook_normalised</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">ml</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="n">pre_detrend</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">prev_ramp</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="n">keep_coh_debug</span><span class="p">)</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lowpass</span><span class="p">:</span>
        <span class="c1"># let&#39;s do longwave filtering:</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">lowpass_gauss</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">thres</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span> <span class="n">use_gold</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="c1">#update the origpha to keep state before filtering</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">goldstein</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filtering by goldstein filter&#39;</span><span class="p">)</span>
        <span class="c1"># this line waits for super-truper improvement - as the spectral magnitude could be used as quality measure! i think..</span>
        <span class="c1"># but i have to skip it for now</span>
        <span class="c1">#ifg_ml[&#39;filtpha&#39;], specmag = goldstein_filter_xr(ifg_ml.pha, blocklen=16, alpha=0.8, nproc=1, returncoh=False)</span>
        <span class="c1">#get mask from specmag:</span>
        <span class="c1"># sp=np.log10(specmag.values)</span>
        <span class="c1"># sp[sp&lt;0]=0</span>
        <span class="c1"># sp[sp&gt;1]=1</span>
        <span class="c1"># spmask=sp&gt;thres # try 0.25</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;filtpha&#39;</span><span class="p">],</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">goldstein_filter_xr</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="p">,</span> <span class="n">blocklen</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">returncoh</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">specmag</span><span class="p">))</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gold_coh&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">sp</span>
        <span class="n">sp</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">values</span>
        <span class="n">sp</span><span class="p">[</span><span class="n">sp</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># should not happen, but just in case...</span>
        <span class="n">sp</span><span class="p">[</span><span class="n">sp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gold_coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">sp</span>
        <span class="c1">#sp=sp.fillna(0).values</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if specmag:</span>
<span class="sd">            #sp = np.log10(sp)</span>
<span class="sd">            sp[sp &gt; 1] = 1</span>
<span class="sd">            sp[sp &lt; 0] = 0</span>
<span class="sd">            # now improve the corr weights with using the coh from phasediff</span>
<span class="sd">            phadiff = A.origpha.copy()</span>
<span class="sd">            phadiff.values = wrap2phase(A.origpha - B[0])</span>
<span class="sd">            phadiff.values = coh_from_phadiff(phadiff.values)</span>
<span class="sd">            phadiff = phadiff.fillna(0)</span>
<span class="sd">            phadiff = phadiff * B[1]</span>
<span class="sd">        ifg_ml[&#39;gold_coh&#39;].values=sp</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># this is just to have the masked pixels zeroes...</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gold_coh&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gold_coh&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>
        <span class="n">sp</span><span class="o">=</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gold_coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">spmask</span><span class="o">=</span><span class="n">sp</span><span class="o">&gt;</span><span class="n">thres</span>
        <span class="c1"># and remove islands - let&#39;s keep the 2x2 km islands...</span>
        <span class="n">npa</span><span class="o">=</span><span class="n">spmask</span><span class="o">*</span><span class="mf">1.0</span>
        <span class="n">npa</span><span class="p">[</span><span class="n">npa</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">lenthres</span> <span class="o">=</span> <span class="mi">2000</span>  <span class="c1"># m</span>
        <span class="n">mlres</span> <span class="o">=</span> <span class="n">get_resolution</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">in_m</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># ok, but we can trust clusters of maxpx pixels (2 km might be overshoot)</span>
        <span class="n">maxpx</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">16</span>
        <span class="n">pixels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">lenthres</span> <span class="o">/</span> <span class="n">mlres</span><span class="p">))</span>
        <span class="n">pixelsno</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pixels</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">maxpx</span><span class="p">)</span>
        <span class="n">spmask</span><span class="o">=</span><span class="n">remove_islands</span><span class="p">(</span><span class="n">npa</span><span class="p">,</span> <span class="n">pixelsno</span><span class="p">)</span>
        <span class="c1">#delta = np.angle(np.exp(1j*(ifg_ml[&#39;filtpha&#39;] - ifg_ml[&#39;pha&#39;])))</span>
        <span class="c1">#mask = np.abs(delta&lt;1)*1</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_filt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_extent&#39;</span><span class="p">]</span>
        <span class="c1">#ifg_ml[&#39;mask_filt&#39;].values=mask</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_filt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">=</span><span class="n">spmask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_filt&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_extent&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>
        <span class="c1"># need to properly assess variance (or coherence-like measure) - but cannot use gaussian!</span>
        <span class="c1">#tofillpha = ifg_ml.filtpha.where(ifg_ml.mask_filt.where(ifg_ml.mask_extent == 1).fillna(1) == 1)</span>
        <span class="c1">#ifg_ml[&#39;pha&#39;].values = interpolate_nans(tofillpha.values, method=&#39;nearest&#39;)</span>
        <span class="c1"># no gapfilling here! but then it gets wrong... so.. gapfilling:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gapfilling&#39;</span><span class="p">)</span>
        <span class="n">tofillpha</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">filtpha</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_extent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pha2unw</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">tofillpha</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="n">cpx</span> <span class="o">=</span> <span class="n">pha2cpx</span><span class="p">(</span><span class="n">pha2unw</span><span class="p">)</span>
        <span class="c1">#coh = sp  # actually ,let&#39;s use the phasediff if we use specmag...</span>
        <span class="k">if</span> <span class="n">specmag</span><span class="p">:</span>
            <span class="n">phadiff</span><span class="o">=</span><span class="n">wrap2phase</span><span class="p">((</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;filtpha&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="n">coh_from_phadiff</span><span class="p">(</span><span class="n">phadiff</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">coh</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coh</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="n">sp</span>
        <span class="n">mask</span><span class="o">=</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;unwrapping filtered phase&#39;</span><span class="p">)</span>
        <span class="n">unw</span><span class="p">,</span><span class="n">conncomp</span> <span class="o">=</span><span class="n">unwrap_np</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span><span class="n">coh</span><span class="p">,</span><span class="n">defomax</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span><span class="n">tmpdir</span><span class="o">=</span><span class="n">tmpunwdir</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span><span class="n">conncomp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">deltemp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;conncomp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;conncomp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">conncomp</span>
        <span class="n">ifg_ml</span><span class="o">.</span><span class="n">unw</span><span class="o">.</span><span class="n">values</span><span class="o">=</span><span class="n">unw</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;filtpha&#39;</span><span class="p">]</span>
        <span class="c1"># add residuals, using orig coh</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;unwrapping residuals&#39;</span><span class="p">)</span>
        <span class="n">cpx</span><span class="o">=</span><span class="n">pha2cpx</span><span class="p">(</span><span class="n">wrap2phase</span><span class="p">((</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;filtpha&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">))</span> <span class="c1"># fillna probably not needed</span>
        <span class="n">coh</span><span class="o">=</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">unw</span><span class="o">=</span><span class="n">unwrap_np</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span><span class="n">coh</span><span class="p">,</span><span class="n">defomax</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">tmpdir</span><span class="o">=</span><span class="n">tmpunwdir</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span><span class="n">deltemp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">unw</span> <span class="o">=</span> <span class="n">unw</span> <span class="o">*</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">.</span><span class="n">values</span>
        <span class="n">unw</span><span class="p">[</span><span class="n">unw</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># 2022-07-28: seems not good idea to correct by median...</span>
        <span class="c1">#nanmed = np.nanmedian(unw)</span>
        <span class="c1">#unw = unw - nanmed</span>
        <span class="n">ifg_ml</span><span class="o">.</span><span class="n">unw</span><span class="o">.</span><span class="n">values</span><span class="o">=</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">unw</span><span class="o">.</span><span class="n">values</span><span class="o">+</span><span class="n">unw</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span>
        <span class="c1"># so now we have it all done - let&#39;s return origpha from pre-filt state</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># now let&#39;s do the old way (not really recommended anymore, as the gaussian would not follow the phase gradient as fine as goldstein filter..</span>
        <span class="c1"># if not, do the original &#39;smooth&#39; approach, just to get proper mask</span>
        <span class="c1">#print(&#39;finally, filter using (adapted) gauss filter&#39;)</span>
        <span class="k">if</span> <span class="n">ml</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">calc_coh_from_delta</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># that part takes ages and it is not that big improvement..</span>
            <span class="n">calc_coh_from_delta</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># calculate gauss_coh, as a measure of spatial consistence</span>
        <span class="c1"># ok, but let&#39;s have the radius of Gaussian kernel tightier - just 10x10 pixels, i.e.</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">get_resolution</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">)</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">filter_ifg_ml</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">calc_coh_from_delta</span> <span class="o">=</span> <span class="n">calc_coh_from_delta</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;consistence&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mask_gauss</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">consistence</span> <span class="o">&gt;</span> <span class="n">thres</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span>
        <span class="c1">#return (unmask) pixels that have coh &gt; 0.25</span>
        <span class="n">mask_gauss</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">mask_gauss</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span> <span class="o">&gt;</span> <span class="mf">0.25</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">mask_gauss</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask_gauss</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># additionally remove islands of size smaller than... 2x2 km...?</span>
        <span class="n">lenthres</span> <span class="o">=</span> <span class="mi">2000</span> <span class="c1"># m</span>
        <span class="n">mlres</span> <span class="o">=</span> <span class="n">get_resolution</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">in_m</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">maxpx</span> <span class="o">=</span> <span class="mi">8</span><span class="o">*</span><span class="mi">8</span>
        <span class="n">pixels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">lenthres</span> <span class="o">/</span> <span class="n">mlres</span><span class="p">))</span>
        <span class="n">pixelsno</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pixels</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">maxpx</span><span class="p">)</span>
        <span class="c1"># or scale it just in pixels, so 7x7 px^2 area</span>
        <span class="c1">#pixelsno = 7*7</span>
        <span class="n">npa</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_coh&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_coh&#39;</span><span class="p">]</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">remove_islands</span><span class="p">(</span><span class="n">npa</span><span class="p">,</span> <span class="n">pixelsno</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="c1">#ifg_ml[&#39;mask_coh&#39;] = ifg_ml[&#39;mask&#39;].where(ifg_ml.gauss_coh &gt; thres).where(ifg_ml.coh &gt; thres).fillna(0)</span>
    <span class="c1">#if lowpass:</span>
        <span class="c1"># let&#39;s do longwave filtering also:</span>
        <span class="c1">#ifg_ml = lowpass_gauss(ifg_ml)</span>
    <span class="c1">#try without modal filter..</span>
    <span class="c1">#ifg_ml = filter_mask_modal(ifg_ml, &#39;mask_coh&#39;, &#39;mask_coh&#39;, 8)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;interpolate coh-based masked areas of gauss pha&#39;</span><span class="p">)</span>
    <span class="c1">#tofillpha = ifg_ml.pha.fillna(0).where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
    <span class="k">if</span> <span class="n">fillby</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
        <span class="c1"># keep smooth always on - much better...</span>
        <span class="k">if</span> <span class="n">smooth</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lowpass</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_pha</span>
        <span class="c1">#trying astropy approach now:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filling through Gaussian kernel&#39;</span><span class="p">)</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># create a &quot;fixed&quot; image with NaNs replaced by interpolated values</span>
        <span class="n">tempar_mag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="p">)</span>
        <span class="c1">#cpxarr = magpha2RI_array(tempar_mag1, ifg_ml.pha.fillna(0).values)</span>
        <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx_tofill&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx_tofill&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxarr</span>
        <span class="c1"># using only extent - avoiding landmask as rivers would have problems</span>
        <span class="c1">#tofill = ifg_ml[&#39;cpx_tofill&#39;].where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
        <span class="c1">#tofill = ifg_ml[&#39;cpx_tofill&#39;].where(ifg_ml.mask_coh.where(ifg_ml.mask_extent == 1).fillna(1) == 1)</span>
        <span class="c1"># or not... let&#39;s mask fully</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">tofill</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx_tofill&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_extent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tofillR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">tofill</span><span class="p">)</span>
        <span class="n">tofillI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">tofill</span><span class="p">)</span>
        <span class="n">filledR</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">tofillR</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="n">filledI</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">tofillI</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">filledR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">filledI</span><span class="p">)</span>
        <span class="c1">#sometimes the whole area is not within gauss kernel</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gapfilling iteration &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
                <span class="c1"># no need to add more heavy iterations</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filling by nearest neighbours&#39;</span><span class="p">)</span>
                <span class="c1">#tofillpha = ifg_ml.pha.where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
                <span class="c1">#tofillpha = ifg_ml.pha.where(ifg_ml.mask_full.where(ifg_ml.mask_extent == 1).fillna(1) == 1)</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx_tofill&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxarr</span>
                <span class="n">tofill</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx_tofill&#39;</span><span class="p">]</span>
                <span class="n">tofillR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">tofill</span><span class="p">)</span>
                <span class="n">tofillI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">tofill</span><span class="p">)</span>
                <span class="n">filledR</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">tofillR</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
                <span class="n">filledI</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">tofillI</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">filledR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">filledI</span><span class="p">)</span>
        <span class="c1">#sometimes the whole area is not within gauss kernel - use NN for that:</span>
        <span class="c1">#if np.max(np.isnan(ifg_ml[&#39;pha&#39;].values)):</span>
        <span class="c1">#    # no, this would be too far. using only filling by zero</span>
        <span class="c1">#    ifg_ml[&#39;pha&#39;] = ifg_ml[&#39;pha&#39;].fillna(0)</span>
        <span class="c1">#    #ifg_ml[&#39;pha&#39;].values = interpolate_nans(ifg_ml[&#39;pha&#39;].values, method=&#39;nearest&#39;)</span>
        <span class="c1">#ifg_ml.pha.fillna(0).where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
        <span class="c1">#ifg_ml[&#39;pha&#39;].values = interpolate_replace_nans(tofillpha.values, kernel)</span>
    <span class="k">elif</span> <span class="n">fillby</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;skipping any nan filling&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">smooth</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lowpass</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_pha</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filling by nearest neighbours&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">smooth</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">lowpass</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_pha</span>
        <span class="c1">#tofillpha = ifg_ml.pha.fillna(0).where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
        <span class="c1">#tofillpha = ifg_ml.pha.fillna(0).where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
        <span class="n">tofillpha</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_extent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">tofillpha</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="c1">#ifg_ml[&#39;gauss_pha&#39;] = ifg_ml[&#39;gauss_pha&#39;].fillna(0)</span>
    <span class="c1">#print(&#39;debug: now pha is fine-filled layer but with some noise at edges - why is that? not resolved. so adding one extra gauss filter&#39;)</span>
    <span class="c1"># ok, i see some high freq signal is still there.. so filtering once more (should also help after the nan filling)</span>
    <span class="k">if</span> <span class="n">smooth</span><span class="p">:</span>
        <span class="c1"># OBSOLETE - do not use with lowpass!</span>
        <span class="c1">#ifg_ml = filter_ifg_ml(ifg_ml)</span>
        <span class="c1"># 2022/07: adding strong filter, say radius 1.5 km ... or... rather 15 pixels - this way it should be relatively long-wave signal</span>
        <span class="c1"># actually i prepared &#39;low-pass&#39; solution, so keep it calm... and also change it to Goldstein!</span>
        <span class="c1">#radius = 15*get_resolution(ifg_ml)</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">get_resolution</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;an extra Gaussian smoothing here, of &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">radius</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; m radius&#39;</span><span class="p">)</span>
        <span class="c1">#ifg_ml = filter_ifg_ml(ifg_ml, radius = 1500)</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">filter_ifg_ml</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_pha&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">goldstein</span><span class="p">:</span>
        <span class="c1"># i did unw before...</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;goldstein is in use - need to update it to have prevest possible..&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#exporting for snaphu</span>
        <span class="c1">#normalise mag from the final pha</span>
        <span class="n">tempar_mag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="p">)</span>
        <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="c1">#no need to fillna, but just in case...</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxarr</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;unwrapping by snaphu&#39;</span><span class="p">)</span>
        <span class="n">binmask</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;gaussmask.bin&#39;</span><span class="p">)</span>
        <span class="c1">#bincoh = os.path.join(tmpdir,&#39;gausscoh.bin&#39;)</span>
        <span class="n">bincoh</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;coh.bin&#39;</span><span class="p">)</span>
        <span class="c1">#binR = os.path.join(tmpdir,&#39;gaussR.bin&#39;)</span>
        <span class="c1">#binI = os.path.join(tmpdir,&#39;gaussI.bin&#39;)</span>
        <span class="n">binCPX</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;cpxgaussifg.bin&#39;</span><span class="p">)</span>
        <span class="n">outunwbin</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;gaussunwrapped.bin&#39;</span><span class="p">)</span>
        <span class="c1">#print(&#39;exporting to bin files&#39;)</span>
        <span class="c1">#ifg_ml.mask_coh.fillna(0).values.astype(np.byte).tofile(binmask)</span>
        <span class="c1"># full masking may be too much for snaphu here:</span>
        <span class="c1">#ifg_ml.mask_full.fillna(0).values.astype(np.byte).tofile(binmask)</span>
        <span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">binmask</span><span class="p">)</span>
        <span class="c1">#ifg_ml.gauss_coh.fillna(0.001).values.astype(np.float32).tofile(bincoh)</span>
        <span class="c1"># we should use the orig coh for weights... and perhaps very low coh values instead of 0</span>
        <span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">bincoh</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_cpx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="c1">#.tofile(binR)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_cpx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="c1">#.tofile(binI)</span>
        <span class="n">RI2cpx</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">binCPX</span><span class="p">)</span>
        <span class="c1">#unwrapping itself</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">prevest</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="c1">#resizing previous ML step and using to unwrap</span>
            <span class="n">bin_pre</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;prevest.bin&#39;</span><span class="p">)</span>
            <span class="n">bin_est</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;prevest.rescaled.bin&#39;</span><span class="p">)</span>
            <span class="n">bin_pre_remove</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;prevest.rescaled.remove.bin&#39;</span><span class="p">)</span>
            <span class="c1">#binI_pre = os.path.join(tmpdir,&#39;prevest.I.bin&#39;)</span>

            <span class="c1"># that is not the best we can do - need to change it</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">prevest</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">prevest</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">prevest</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
            <span class="c1">#prevest.values = interpolate_replace_nans(prevest.values, kernel)</span>

            <span class="c1"># let&#39;s interpolate the (smaller?) prevest to ifg_ml shape</span>
            <span class="n">prevest</span> <span class="o">=</span> <span class="n">prevest</span><span class="o">.</span><span class="n">interp_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="c1"># in some cases it might still contain nans, so just.. interpolate them... how?:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prevest</span><span class="p">)):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
                <span class="c1">#method = &#39;nearest&#39;</span>
                <span class="n">prevest</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">prevest</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
            <span class="c1">#filling other nans to 0 - this can happen if null regions are too large (larger than the kernel accepts)</span>
            <span class="c1">#prevest.astype(np.float32).fillna(0).values.tofile(bin_pre)</span>
            <span class="n">prevest</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">bin_est</span><span class="p">)</span>
            <span class="c1">#width_pre = len(prevest.lon)</span>
            <span class="c1">#length_pre = len(prevest.lat)</span>
            <span class="c1">#resize_bin(bin_pre, width_pre, length_pre, bin_est, width, length, dtype = np.float32, intertype = cv2.INTER_CUBIC)</span>
            <span class="c1">#resize_bin(bin_pre, width_pre, length_pre, bin_est, width, length, dtype = np.float32, intertype = cv2.INTER_LINEAR)</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">bin_pre_remove</span><span class="p">)</span>
            <span class="n">main_unwrap</span><span class="p">(</span><span class="n">binCPX</span><span class="p">,</span> <span class="n">bincoh</span><span class="p">,</span> <span class="n">binmask</span><span class="p">,</span> <span class="n">outunwbin</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">bin_est</span><span class="p">,</span> <span class="n">bin_pre_remove</span> <span class="o">=</span> <span class="n">bin_pre_remove</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#print(&#39;unwrapping&#39;)</span>
            <span class="c1">#main_unwrap(binCPX, bincoh, binmask, outunwbin, width, defomax = defomax, printout=False)</span>
            <span class="c1"># 2022-01-14 - avoiding mask here - it does only worse</span>
            <span class="c1">#main_unwrap(binCPX, bincoh, None, outunwbin, width, defomax = defomax, printout=False)</span>
            <span class="c1"># 2022-04-04 - returning the mask! result is really bad with it, at least at islands!</span>
            <span class="n">main_unwrap</span><span class="p">(</span><span class="n">binCPX</span><span class="p">,</span> <span class="n">bincoh</span><span class="p">,</span> <span class="n">binmask</span><span class="p">,</span> <span class="n">outunwbin</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">printout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;importing snaphu result to ifg_ml&#39;</span><span class="p">)</span>
        <span class="n">binfile</span> <span class="o">=</span> <span class="n">outunwbin</span>
        <span class="c1">#toxr = ifg_ml</span>
        <span class="n">daname</span> <span class="o">=</span> <span class="s1">&#39;unw&#39;</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="n">unw1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">binfile</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">unw1</span> <span class="o">=</span> <span class="n">unw1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1">#unw1 = np.flip(unw1,axis=0)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="c1">#.copy(deep=True)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">unw1</span>
        <span class="c1">#ok, so the gauss-based coh mask is not the best to do... so exporting &#39;all pixels&#39;</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask&#39;]</span>
        <span class="c1">#print(&#39;20210722 - testing now - using gauss-based coh mask, ignore the next message:&#39;)</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask_coh&#39;]</span>
        <span class="c1">#this would do median correction, not doing it now:</span>
        <span class="c1">#ifg_ml[daname].values = ifg_ml[daname].values - np.nanmedian(ifg_ml[daname].where(ifg_ml.mask_coh&gt;0).values)</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml.mask_coh</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml.mask</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask_coh&#39;]</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">*</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span>
        <span class="c1">#print(&#39;unwrap also residuals from the filtered cpx, and add to the final unw - mask only waters..&#39;)</span>
        <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">origpha</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origcpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_cpx&#39;</span><span class="p">]</span> <span class="c1">#.copy(deep=True)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origcpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxarr</span>
        <span class="k">if</span> <span class="n">add_resid</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;unwrapping residuals and adding back to the final unw output&#39;</span><span class="p">)</span>
            <span class="c1"># maybe can use this somehow? by yma. i checked and it is correct</span>
            <span class="c1"># delta = np.angle(np.exp(np.complex(0+1j)*( np.angle(ifg_filt) - np.angle(ifg_unfilt))))</span>
            <span class="c1"># delta = np.angle(np.exp(0+1j)*( np.angle(ifg_filt) - np.angle(ifg_unfilt)))</span>
            <span class="c1"># delta = np.angle(np.exp(0+1j)*( pha_filt - pha_unfilt ) )</span>
            <span class="c1"># ifg_unw_unfilt = ifg_unw_filt - delta</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;resid_cpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">origcpx</span> <span class="o">*</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_cpx</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="c1">#* ifg_ml.mask_full</span>
            <span class="n">incpx</span> <span class="o">=</span> <span class="s1">&#39;resid_cpx&#39;</span>
            <span class="c1">#binR = os.path.join(tmpdir,incpx+&#39;.R.bin&#39;)</span>
            <span class="c1">#binI = os.path.join(tmpdir,incpx+&#39;.I.bin&#39;)</span>
            <span class="n">binCPX</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="n">incpx</span><span class="o">+</span><span class="s1">&#39;.cpx.bin&#39;</span><span class="p">)</span>
            <span class="n">outunwbin</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="n">incpx</span><span class="o">+</span><span class="s1">&#39;.unw.bin&#39;</span><span class="p">)</span>
            <span class="n">binfile</span> <span class="o">=</span> <span class="n">outunwbin</span>
            <span class="n">daname</span> <span class="o">=</span> <span class="n">incpx</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span>
            <span class="c1">#</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="n">incpx</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="c1">#.tofile(binR)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="n">incpx</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="c1">#.tofile(binI)</span>
            <span class="n">RI2cpx</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">binCPX</span><span class="p">)</span>
            <span class="c1">#main_unwrap(binCPX, bincoh, binmask, outunwbin, width, defomax = defomax/2)</span>
            <span class="c1"># ok, just hold the defomax low - discontinuities are not wanted or expected here..or not?</span>
            <span class="n">main_unwrap</span><span class="p">(</span><span class="n">binCPX</span><span class="p">,</span> <span class="n">bincoh</span><span class="p">,</span> <span class="n">binmask</span><span class="p">,</span> <span class="n">outunwbin</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">printout</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">unw1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">binfile</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">unw1</span> <span class="o">=</span> <span class="n">unw1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="c1">#.copy()</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">unw1</span>
            <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask&#39;]</span>
            <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask_coh&#39;]</span>
            <span class="c1"># ensure values are correctly surrounded by zeroes - i.e. shifting by points masked away</span>
            <span class="c1"># 2022/02 - actually seems weird to me. skipping. also, i added mask binary to update snaphu cost solution..</span>
            <span class="c1">#ifg_ml[daname] = ifg_ml[daname] - np.nanmedian(ifg_ml[daname].where(ifg_ml.mask_extent==0).values)</span>
            <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask_full&#39;]</span>
            <span class="c1">#ifg_ml[daname] = ifg_ml[daname] - np.nanmedian(ifg_ml[daname].where(ifg_ml.mask_extent==1).values)</span>
            <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask_full&#39;]</span>
            <span class="c1">#nanmed = np.nanmedian(ifg_ml[daname].where(ifg_ml.mask_coh&gt;0).values)</span>
            <span class="n">nanmed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">nanmed</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">*</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span>
            <span class="c1">#print(&#39;debug - avoiding median correction now, although maybe ok for add_resid: median was {} rad&#39;.format(str(nanmed)))</span>
            <span class="c1">#ifg_ml[daname].values = ifg_ml[daname].values - np.nanmedian(ifg_ml[daname].where(ifg_ml.mask_coh&gt;0).values)</span>
            <span class="c1">#print(&#39;again, masking the final product by gauss coh threshold&#39;)</span>
            <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml.mask_coh</span>
            <span class="c1">#</span>
            <span class="c1">#</span>
            <span class="c1">#ifg_ml[&#39;resid_&#39;].plot()</span>
            <span class="c1">#now the unw will have the residual phase added back</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span>
    <span class="c1">#if gacoscorr:</span>
    <span class="c1">#    #we have removed GACOS estimate from unw, now time to add it back!</span>
    <span class="c1">#    ifg_ml[&#39;unw&#39;] = ifg_ml[&#39;unw&#39;] + ifg_ml[&#39;gacos&#39;]</span>
    <span class="c1"># add back what we have removed before..</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span>
    <span class="c1">#mask it</span>
    <span class="c1">#ifg_ml[&#39;unw&#39;] = ifg_ml[&#39;unw&#39;].where(ifg_ml.mask&gt;0)</span>
    <span class="c1"># ok ok.... let&#39;s mask by the gauss mask.. although, can be quite missing lot of areas</span>
    <span class="c1">#ifg_ml[&#39;unw&#39;] = ifg_ml[&#39;unw&#39;].where(ifg_ml.mask_coh&gt;0)</span>
    <span class="c1"># hmmm... just to make it nicer...</span>
    <span class="c1">#ifg_ml[&#39;unw&#39;] = ifg_ml[&#39;unw&#39;].where(ifg_ml.mask&gt;0)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># but this may be wrong!</span>
    <span class="c1"># 2022-04-04 - ok, but gacos and some other corrections based on model would bring full shift,</span>
    <span class="c1"># including the one already inside range offsets during coreg. so we should indeed shift by median:</span>
    <span class="c1"># 2022-07-28: seems not good idea to correct by median...</span>
    <span class="c1">#ifg_ml[&#39;unw&#39;] = ifg_ml[&#39;unw&#39;] - ifg_ml[&#39;unw&#39;].median()</span>
    <span class="k">if</span> <span class="n">rampit</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw_orig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">filter_nan_gaussian_conserving</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">trunc</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_extent</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#else:</span>
    <span class="c1">#    ifg_ml[&#39;unw&#39;] = ifg_ml[&#39;unw&#39;].where(ifg_ml.mask_full&gt;0)</span>
    <span class="c1"># finally clip again, without border pixels:</span>
    <span class="k">if</span> <span class="n">cliparea_geo</span><span class="p">:</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">),</span> <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">add_resid</span><span class="p">:</span>
        <span class="c1"># 2022-04-04 - fixing for final residuals - without unwrapping them - in case the unw had some spatially propagating error</span>
        <span class="c1"># BUT ALSO the &#39;weird vertical lines&#39; sometimes induced after snaphu unwrapping. those lines have, however, values very close to 0, but not 0</span>
        <span class="c1"># it generally should not be needed though!</span>
        <span class="k">if</span> <span class="s1">&#39;origpha_noremovals&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="p">:</span>
            <span class="n">residpha</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">wrap2phase</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">origpha_noremovals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tempar_mag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="p">)</span>
            <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unwcpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_cpx&#39;</span><span class="p">]</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unwcpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxarr</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;resid_final&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">unwcpx</span> <span class="o">*</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">origcpx</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="c1">#* ifg_ml.mask_full</span>
            <span class="c1"># but ignoring the overall shift as we do the median shifting before</span>
            <span class="n">residpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;resid_final&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># 2022-07-28: seems not good idea to correct by median...</span>
        <span class="c1">#medres = np.nanmedian(residpha)</span>
        <span class="c1">#residpha = residpha - medres</span>
        <span class="c1"># ifg_ml[&#39;resid_final&#39;].values = residpha; ifg_ml[&#39;resid_final&#39;].plot(); plt.show()</span>
        <span class="c1">#print(&#39;final check for residuals: their std is &#39;+str(np.nanstd(residpha)))</span>
        <span class="c1"># ok, so i assume that the unw would not help anymore, so just adding to unw as it is</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">residpha</span>
    <span class="c1"># now, we may need to save without gacos itself:</span>
    <span class="k">if</span> <span class="n">subtract_gacos</span><span class="p">:</span>    <span class="c1"># so even if we did not use gacos to support unwrapping, we should remove it if subtract_gacos is on. and that&#39;s just for loop closures!</span>
        <span class="k">if</span> <span class="s1">&#39;gacos&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span>   <span class="c1"># (ifg_ml[&#39;gacos&#39;] - ifg_ml[&#39;gacos&#39;].median())    # better not remove median</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">outtif</span><span class="p">:</span>
        <span class="c1">#ifg_ml.pha.fillna(0).where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
        <span class="c1">#ifg_ml[&#39;unw&#39;].to_netcdf(outtif+&#39;.nc&#39;)</span>
        <span class="n">toexp</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">export_xr2tif</span><span class="p">(</span><span class="n">toexp</span><span class="p">,</span> <span class="n">outtif</span><span class="p">)</span>
        <span class="c1">#toexp.values = np.flipud(toexp.values)</span>
        <span class="c1"># this does not work, probably due to multilooking... yikes</span>
        <span class="c1">#ifg_ml[&#39;unw&#39;].to_netcdf(outtif+&#39;.nc&#39;)</span>
        <span class="c1">#rc = os.system(&#39;gmt grdconvert -G{0}=gd:GTiff -R{1} {0}.nc&#39;.format(outtif, ifg_pha_file))</span>
        <span class="c1">#rc = os.system(&#39;source {0}/lib/LiCSAR_bash_lib.sh; create_preview_unwrapped {1} {2}&#39;.format(os.environ[&#39;LiCSARpath&#39;], outtif, frame))</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;source </span><span class="si">{0}</span><span class="s1">/lib/LiCSAR_bash_lib.sh; create_preview_unwrapped </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSARpath&#39;</span><span class="p">],</span> <span class="n">outtif</span><span class="p">))</span>
        <span class="c1">#try:</span>
        <span class="c1">#    os.remove(outtif+&#39;.nc&#39;)</span>
        <span class="c1">#except:</span>
        <span class="c1">#    print(&#39;ERROR removing the nc file - something wrong with export&#39;)</span>
    <span class="k">return</span> <span class="n">ifg_ml</span>


<div class="viewcode-block" id="process_frame"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.process_frame">[docs]</a><span class="k">def</span> <span class="nf">process_frame</span><span class="p">(</span><span class="n">frame</span> <span class="o">=</span> <span class="s1">&#39;dummy&#39;</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cascade</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">only10</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">lowpass</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">goldstein</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pairsetfile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="n">export_to_tif</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dolocal</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">specmag</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
            <span class="n">use_amp_stab</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">use_coh_stab</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main function to process whole LiCSAR frame (i.e. unwrap all available interferograms within the frame). Works only at JASMIN.</span>

<span class="sd">    Args:</span>
<span class="sd">        frame (string): LiCSAR frame ID</span>
<span class="sd">        ml (int): multilooking factor used to reduce the interferogram in lon/lat</span>
<span class="sd">        thres (float): threshold between 0-1 for gaussian-based coherence-like measure (spatial phase consistence?); higher number - more is masked prior to unwrapping</span>
<span class="sd">        smooth (boolean): switch to use extra Gaussian filtering for 2-pass unwrapping, can be wrong - not preferred anymore.</span>
<span class="sd">        lowpass (boolean): switch to use lowpass filter (Gaussian-based, with masking high gradients and interpolating inbetween), preferred option</span>
<span class="sd">        goldstein (boolean): switch to use extra Goldstein filter - would cause longer run, but it is very recommended option to use</span>
<span class="sd">        cascade (boolean): switch to perform cascade unwrapping</span>
<span class="sd">        </span>
<span class="sd">        hgtcorr (boolean): switch to perform correction for height-phase correlation</span>
<span class="sd">        gacoscorr (boolean): switch to apply GACOS corrections (if detected)</span>
<span class="sd">        </span>
<span class="sd">        cliparea_geo (string or None): use GMT/LiCSBAS string to identify area to clip, in geo-coordinates: e.g. ``&#39;lon1/lon2/lat1/lat2&#39;``</span>
<span class="sd">        pairsetfile (string or None): path to file containing list of pairs to unwrap</span>
<span class="sd">        export_to_tif (boolean): switch to export unwrapped data to geotiffs (default: False, generate only binaries, as used by LiCSBAS)</span>
<span class="sd">        subtract_gacos (boolean): switch whether to return the interferograms with GACOS being subtracted (by default, GACOS is used only to support unwrapping and would be added back)</span>
<span class="sd">        nproc (int): use multiprocessing (one core per interferogram), not well tested, uses pathos</span>
<span class="sd">        dolocal (boolean): switch to use local directory to find interferograms, rather than search for LiCSAR_public directory in JASMIN</span>
<span class="sd">        </span>
<span class="sd">        use_amp_stab (boolean): apply amplitude stability index instead of coherence-per-interferogram for unwrapping</span>
<span class="sd">        use_coh_stab (boolean): apply (experimental) coherence stability index. not recommended (seems not logical to me) - worth investigating though (maybe helps against loop closure errors)</span>
<span class="sd">        keep_coh_debug (boolean): only in combination with use_coh_stab - whether or not to keep original (downsampled) ifg coherence after using the coh_stab to weight the phase during multilooking</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: multilooked interferogram with additional layers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#if cascade and ml&gt;1:</span>
    <span class="c1">#    print(&#39;error - the cascade approach is ready only for ML1&#39;)</span>
    <span class="c1">#    return False</span>
    <span class="c1">#the best to run in directory named by the frame id</span>
    <span class="n">pubdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">track</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">geoframedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pubdir</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">track</span><span class="p">),</span><span class="n">frame</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dolocal</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;using fake frame id, continuing (local proc.)&#39;</span><span class="p">)</span>
            <span class="n">geoframedir</span><span class="o">=</span><span class="n">frame</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;provided wrong frame id&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">dolocal</span><span class="p">:</span>
        <span class="n">geoifgdir</span> <span class="o">=</span> <span class="s1">&#39;GEOC&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR: the GEOC directory does not exist, cancelling&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="n">hgtfile</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;GEOC/*.geo.hgt.tif&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hgtfile</span><span class="o">=</span><span class="n">hgtfile</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR: GEOC/*.geo.hgt.tif is not existing, cancelling (although might just avoid it?)&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;please generate this file first - tip: use gdal2warp.py $anydem.tif $anygoodfile.tif GEOC/any.geo.hgt.tif&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">geoifgdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;interferograms&#39;</span><span class="p">)</span>
        <span class="n">hgtfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;metadata&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.hgt.tif&#39;</span><span class="p">)</span>
    <span class="n">inputifgdir</span> <span class="o">=</span> <span class="n">geoifgdir</span>
    <span class="n">raster</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">)</span>
    <span class="n">framewid</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterXSize</span>
    <span class="n">framelen</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterYSize</span>
    
    <span class="k">if</span> <span class="n">dolocal</span><span class="p">:</span>
        <span class="n">landmask_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;GEOC&#39;</span><span class="p">,</span><span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.landmask.tif&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">landmask_file</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;preparing land mask clip&#39;</span><span class="p">)</span>
            <span class="n">landmask_frame</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;metadata&#39;</span><span class="p">,</span><span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.landmask.tif&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">landmask_frame</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: landmask does not exist for this frame, will continue without it&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">landmask_frame</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">landmask_frame</span><span class="p">)</span>
                <span class="n">hgt</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">)</span>
                <span class="n">landmask</span> <span class="o">=</span> <span class="n">landmask_frame</span><span class="o">.</span><span class="n">interp_like</span><span class="p">(</span><span class="n">hgt</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                <span class="n">export_xr2tif</span><span class="p">(</span><span class="n">landmask</span><span class="p">,</span> <span class="n">landmask_file</span><span class="p">,</span> <span class="n">dogdal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="c1">#if cliparea_geo:</span>
    <span class="c1">#    import rioxarray as rio</span>
    <span class="c1">#    hgt = xr.open_dataarray(hgtfile)</span>
    <span class="n">cohratio</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">use_amp_stab</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calculating amplitude stability&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ampstabfile</span> <span class="o">=</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;_ampstab.nc&#39;</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ampstabfile</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;using existing ampstabfile&#39;</span><span class="p">)</span>
                <span class="n">ampstab</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataarray</span><span class="p">(</span><span class="n">ampstabfile</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ampavg</span><span class="p">,</span> <span class="n">ampstd</span> <span class="o">=</span> <span class="n">build_amp_avg_std</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
                <span class="n">ampstab</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ampstd</span><span class="o">/</span><span class="n">ampavg</span>
                <span class="n">ampstab</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ampstab</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
                <span class="n">ampstab</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">ampstabfile</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error happened, disabling use of amplitude stability&#39;</span><span class="p">)</span>
            <span class="n">use_amp_stab</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">use_coh_stab</span><span class="p">:</span>
        <span class="n">cohstabdays</span> <span class="o">=</span> <span class="mi">12</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calculating coherence stability, using only </span><span class="si">{}</span><span class="s1"> days coherences&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cohstabdays</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cohratiofile</span> <span class="o">=</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;_cohratio.nc&#39;</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cohratiofile</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;using existing cohratiofile&#39;</span><span class="p">)</span>
                <span class="n">cohratio</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataarray</span><span class="p">(</span><span class="n">cohratiofile</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cohavg</span><span class="p">,</span> <span class="n">cohstd</span> <span class="o">=</span> <span class="n">build_coh_avg_std</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">days</span> <span class="o">=</span> <span class="n">cohstabdays</span><span class="p">,</span> <span class="n">monthly</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
                <span class="c1"># ok, original coh_stab = 1 - coh_dispersion, i.e.:</span>
                <span class="n">cohratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cohstd</span><span class="o">/</span><span class="n">cohavg</span>
                <span class="n">cohratio</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">cohratio</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;storing DQ=1-cohstd/cohavg to &#39;</span><span class="o">+</span><span class="n">cohratiofile</span><span class="p">)</span>
                <span class="n">cohratio</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">cohratiofile</span><span class="p">)</span>
                <span class="c1"># but i want now to have it logarithmic, so:</span>
                <span class="c1">#cohratio = cohavg/cohstd</span>
                <span class="c1">#hmm... not really any difference. so using the orig way</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error happened, disabling use of coh stability&#39;</span><span class="p">)</span>
            <span class="n">use_coh_stab</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">pairset</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">pairsetfile</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pairset</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">pairsetfile</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">pairset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pairset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error loading pairset, doing all&#39;</span><span class="p">)</span>
            <span class="n">pairset</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pairset</span><span class="p">:</span>
        <span class="n">pairset</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">inputifgdir</span><span class="p">)</span>
    <span class="c1"># functions for multiprocessing</span>
    <span class="k">def</span> <span class="nf">check_and_process_ifg</span><span class="p">(</span><span class="n">pair</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">pair</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
            <span class="c1">#check its dimensions..</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            raster = gdal.Open(os.path.join(geoifgdir, pair, pair+&#39;.geo.diff_pha.tif&#39;))</span>
<span class="sd">            if (framewid != raster.RasterXSize) or (framelen != raster.RasterYSize):</span>
<span class="sd">                #use tolerance of max pixels</span>
<span class="sd">                maxpixels = 4</span>
<span class="sd">                if ((abs(framewid - raster.RasterXSize) &gt; maxpixels) or (abs(framelen - raster.RasterYSize) &gt; maxpixels)):</span>
<span class="sd">                    print(&#39;ERROR - the file {} has unexpected dimensions, skipping&#39;.format(os.path.join(geoifgdir, pair, pair+&#39;.geo.diff_pha.tif&#39;)))</span>
<span class="sd">                    return False</span>
<span class="sd">                else:</span>
<span class="sd">                    print(&#39;ERROR - the file {} has unexpected dimensions, trying to fix&#39;.format(os.path.join(geoifgdir, pair, pair+&#39;.geo.diff_pha.tif&#39;)))</span>
<span class="sd">                    for tif in glob.glob(os.path.join(geoifgdir, pair, pair+&#39;.geo.*.tif&#39;)):</span>
<span class="sd">                        outfile = tif+&#39;.tmp.tif&#39;</span>
<span class="sd">                        try:</span>
<span class="sd">                            filedone = reproject_to_match(tif, hgtfile, outfile)</span>
<span class="sd">                            if os.path.exists(outfile):</span>
<span class="sd">                                shutil.move(outfile, tif)</span>
<span class="sd">                        except:</span>
<span class="sd">                            print(&#39;something wrong during reprojection, skipping&#39;)</span>
<span class="sd">                            #continue</span>
<span class="sd">                            return False</span>
<span class="sd">                    #os.system(&#39;gmt grdsample {0} -G{1}&#39;)</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">raster</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">framewid</span> <span class="o">!=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">framelen</span> <span class="o">!=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR - the file </span><span class="si">{}</span><span class="s1"> has unexpected dimensions, skipping&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)))</span>
                    <span class="c1">#continue</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error processing file </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)))</span>
                <span class="c1">#continue</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;processing pair &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">export_to_tif</span><span class="p">:</span>
                    <span class="n">outtif</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outtif</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">dolocal</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">cascade</span><span class="p">:</span>
                            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">cascade_unwrap</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">downtoml</span> <span class="o">=</span> <span class="n">ml</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">only10</span> <span class="o">=</span> <span class="n">only10</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span> <span class="n">dolocal</span><span class="o">=</span><span class="n">dolocal</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">ml</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>   <span class="c1"># nov 2022, orig was gauss</span>
                                <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">cohratio</span> <span class="o">=</span> <span class="n">cohratio</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span>
                                <span class="n">lowpass</span><span class="o">=</span><span class="n">lowpass</span><span class="p">,</span> <span class="n">goldstein</span><span class="o">=</span><span class="n">goldstein</span><span class="p">,</span> <span class="n">specmag</span> <span class="o">=</span> <span class="n">specmag</span><span class="p">,</span>
                                <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="n">keep_coh_debug</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="n">gacoscorr</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span>
                                <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">dolocal</span><span class="o">=</span><span class="n">dolocal</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">phatif</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)</span>
                        <span class="n">cohtif</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.cc.tif&#39;</span><span class="p">)</span>
                        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg_pair</span><span class="p">(</span><span class="n">phatif</span><span class="p">,</span> <span class="n">cohtif</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">ml</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                                                 <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">cohratio</span> <span class="o">=</span> <span class="n">cohratio</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span>
                                                 <span class="n">lowpass</span><span class="o">=</span><span class="n">lowpass</span><span class="p">,</span> <span class="n">goldstein</span><span class="o">=</span><span class="n">goldstein</span><span class="p">,</span> <span class="n">specmag</span> <span class="o">=</span> <span class="n">specmag</span><span class="p">,</span>
                                                 <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="n">keep_coh_debug</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="n">gacoscorr</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span>
                                                 <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">cascade</span> <span class="o">=</span> <span class="n">cascade</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">unw</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">)</span>
                    <span class="p">((</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.cc&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s1">&#39;conncomp&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="p">:</span>
                        <span class="n">ifg_ml</span><span class="o">.</span><span class="n">conncomp</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.conncomp&#39;</span><span class="p">)</span>
                    <span class="c1"># export </span>
                    <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># use LiCSBAS preview generator</span>
                        <span class="kn">import</span> <span class="nn">SCM</span>
                        <span class="kn">import</span> <span class="nn">LiCSBAS_plot_lib</span> <span class="k">as</span> <span class="nn">plot_lib</span>
                        <span class="n">unwpngfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw.png&#39;</span><span class="p">)</span>
                        <span class="n">cmap_wrap</span> <span class="o">=</span> <span class="n">SCM</span><span class="o">.</span><span class="n">romaO</span>
                        <span class="n">cycle</span> <span class="o">=</span> <span class="mi">3</span>
                        <span class="n">plot_lib</span><span class="o">.</span><span class="n">make_im_png</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">unw</span><span class="o">.</span><span class="n">values</span> <span class="o">/</span> <span class="n">cycle</span><span class="p">)</span> <span class="o">*</span> <span class="n">cycle</span><span class="p">),</span> <span class="n">unwpngfile</span><span class="p">,</span> <span class="n">cmap_wrap</span><span class="p">,</span>
                                             <span class="n">pair</span> <span class="o">+</span> <span class="s1">&#39;.unw&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error with new preview, doing old way&#39;</span><span class="p">)</span>
                        <span class="n">create_preview_bin</span><span class="p">(</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">ftype</span> <span class="o">=</span> <span class="s1">&#39;unw&#39;</span><span class="p">)</span>
                    <span class="c1">#os.system(&#39;rm &#39;+pair+&#39;/&#39;+pair+&#39;.unw.ras&#39;)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -r &#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="s1">&#39;temp_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ml</span><span class="p">))</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -r &#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="s1">&#39;temp_gen&#39;</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR processing of pair &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -r &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error occured and the unw was not processed&#39;</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -r &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
    <span class="k">def</span> <span class="nf">fix_additionals</span><span class="p">():</span>
        <span class="n">hgt</span> <span class="o">=</span> <span class="n">get_ml_hgt</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">,</span> <span class="n">ml</span><span class="o">=</span><span class="n">ml</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">)</span>
        <span class="n">framewid</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">hgt</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">framelen</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">hgt</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">mlipar</span> <span class="o">=</span> <span class="s1">&#39;slc.mli.par&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">mlipar</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">mlipar</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;range_samples: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">framewid</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;azimuth_lines: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">framelen</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;radar_frequency: 5405000000.0 Hz</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>  <span class="c1"># for S1. It would be 9650000000.0 Hz for TSX</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;hgt&#39;</span><span class="p">):</span>
            <span class="n">hgt</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="s1">&#39;hgt&#39;</span><span class="p">)</span>  <span class="c1"># should work but i didn&#39;t test it (blind fix)</span>
            <span class="c1">#np.array(raster).astype(np.float32).tofile(&#39;hgt&#39;)</span>
            <span class="c1">#if &#39;hgt&#39; in ifg_ml:</span>
            <span class="c1">#    ifg_ml[&#39;hgt&#39;].astype(np.float32).values.tofile(&#39;hgt&#39;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;EQA.dem_par&#39;</span><span class="p">):</span>
            <span class="n">post_lon</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">hgt</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">hgt</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">post_lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">hgt</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">hgt</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">cor_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">hgt</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">cor_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">hgt</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">create_eqa_file</span><span class="p">(</span><span class="s1">&#39;EQA.dem_par&#39;</span><span class="p">,</span><span class="n">framewid</span><span class="p">,</span><span class="n">framelen</span><span class="p">,</span><span class="n">cor_lat</span><span class="p">,</span><span class="n">cor_lon</span><span class="p">,</span><span class="n">post_lat</span><span class="p">,</span><span class="n">post_lon</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nproc</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pathos.multiprocessing</span> <span class="kn">import</span> <span class="n">ProcessingPool</span> <span class="k">as</span> <span class="n">Pool</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pathos not installed - no parallelism&#39;</span><span class="p">)</span>
            <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">nproc</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">nproc</span><span class="p">)</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">check_and_process_ifg</span><span class="p">,</span> <span class="n">pairset</span><span class="p">)</span>  <span class="c1"># out is one output per pair -&gt; list</span>
            <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># or not?</span>
            <span class="c1">#fix_additionals()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error appeared - please try manually (debug). now, just returning to no parallelism&#39;</span><span class="p">)</span>
            <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">nproc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairset</span><span class="p">:</span>
            <span class="n">check_and_process_ifg</span><span class="p">(</span><span class="n">pair</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">fix_additionals</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;debug - function fix_additionals() failed&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_ml_hgt"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.get_ml_hgt">[docs]</a><span class="k">def</span> <span class="nf">get_ml_hgt</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">,</span> <span class="n">ml</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Support function to load DEM of frame, incl. multilook (downsample) and clipping</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#pubdir = os.environ[&#39;LiCSAR_public&#39;]</span>
    <span class="c1">#geoframedir = os.path.join(pubdir, str(int(frame[:3])), frame)</span>
    <span class="c1">#hgtfile = os.path.join(geoframedir, &#39;metadata&#39;, frame + &#39;.geo.hgt.tif&#39;)</span>
    <span class="n">hgt</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ml</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">hgt</span> <span class="o">=</span> <span class="n">hgt</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cliparea_geo</span><span class="p">:</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="n">cliparea_geo2coords</span><span class="p">(</span><span class="n">cliparea_geo</span><span class="p">)</span>
        <span class="n">hgt</span> <span class="o">=</span> <span class="n">hgt</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">),</span> <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">hgt</span></div>


<div class="viewcode-block" id="multilook_normalised"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.multilook_normalised">[docs]</a><span class="k">def</span> <span class="nf">multilook_normalised</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">thres_pxcount</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multilooking function that does much more.</span>
<span class="sd">    </span>
<span class="sd">    This function is normally called by process_ifg. It would use coherence as weights to multilook interferometric phase, and downsample other layers if available to a final datacube.</span>
<span class="sd">    It will apply mask, including based on number of valid pixels in the multilooking window.</span>
<span class="sd">    It will also apply Gaussian filter, mainly to get the Gaussian-based coherence-like measure (used no matter if smooth is ON).</span>

<span class="sd">    Args:</span>
<span class="sd">        ifg (xarray.Dataset): xarray dataset containing interferogram layers, mainly cpx for complex numbers interferogram</span>
<span class="sd">        ml (int): multilooking factor used to reduce the interferogram in both x/y or lon/lat</span>
<span class="sd">        tmpdir (string): path to temporary directory</span>
<span class="sd">        hgtcorr (boolean): switch to perform correction for height-phase correlation</span>
<span class="sd">        pre_detrend (boolean): switch to perform detrending of phase</span>
<span class="sd">        prev_ramp (xarray.DataArray): a previous (ramp) estimate. it can be of different dimensions as it would get interpolated</span>
<span class="sd">        thres_pxcount (int or None): by default, we nullify multilooked pixel that has less than 4/5 non-nan input values. You may change this, e.g. if ml=10, apply thres_pxcount=90 for keeping only pixel with over 9/10 values</span>
<span class="sd">        keep_coh_debug (boolean): for experiments, this would keep the original interferogram coherence instead of use average coherence or amplitude stability etc. for weighting</span>

<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: multilooked interferogram with additional layers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#landmask it and multilook it</span>
    <span class="k">if</span> <span class="n">ml</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># that&#39;s for multilooking - in case of cohratio, we want to only weight phases based on that, and then return to coh</span>
        <span class="n">bagcpx</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">bagcpx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">bagcpx</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>   <span class="c1"># this really equals np.nanmean, or, bagcpx.mean() - same result</span>
        <span class="c1"># if we use coh instead of amplitude, it may get underestimated after ML (as found by Jack McG.), so just averaging it here:</span>
        <span class="c1">#if type(ml_weights) != type(None):</span>
        <span class="n">bagcoh</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[[</span><span class="s1">&#39;coh&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span>
        <span class="c1">#coh_ml = bagcoh.sum() / bagcoh.count()</span>
        <span class="n">coh_ml</span> <span class="o">=</span> <span class="n">bagcoh</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">coh_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># non-nan px count per window</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pxcount&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pxcount&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">bagcpx</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">cpx</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>    <span class="c1"># to use later - evaluate bad ML data, e.g. mask those pxls</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span>
    <span class="c1">#downsample mask</span>
    <span class="k">if</span> <span class="n">ml</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_extent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">mask_extent</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;gacos&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">gacos</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># or median?</span>
        <span class="k">if</span> <span class="s1">&#39;hgt&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">hgt</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_extent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">mask_extent</span>
        <span class="k">if</span> <span class="s1">&#39;gacos&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">gacos</span>
        <span class="k">if</span> <span class="s1">&#39;hgt&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">hgt</span>
    <span class="c1">#keep the original original pha values</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha_noremovals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span> <span class="c1">#.copy(deep=True)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha_noremovals&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="p">)</span> <span class="c1">#.copy(deep=True)</span>
    <span class="c1">#prepare &#39;toremove&#39; layer</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="p">)</span> <span class="c1"># just make them zeroes</span>
    <span class="k">if</span> <span class="n">keep_coh_debug</span><span class="p">:</span>
        <span class="c1">#ok, return coh, phase back to cpx</span>
        <span class="n">cpxa</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">origpha_noremovals</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxa</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#print(&#39;debug: trying to use the cohratio rather than current coh. maybe wrong?&#39;)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;orig_coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">])</span>
    <span class="c1">#remove previous estimates</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">prev_ramp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="c1">#prev_width = len(prev_ramp.lon)</span>
        <span class="c1">#prev_length = len(prev_ramp.lat)</span>
        <span class="c1">#prev_ramp = prev_ramp.fillna(0)</span>
        <span class="c1">#12/2022:</span>
        <span class="c1"># let&#39;s interpolate the (smaller?) prevest to ifg_ml shape</span>
        <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">prev_ramp</span><span class="o">.</span><span class="n">interp_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="c1"># in some cases it might still contain nans, so just.. interpolate them... how?:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prev_ramp</span><span class="p">)):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
            <span class="c1">#method = &#39;nearest&#39;</span>
            <span class="n">prev_ramp</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">prev_ramp</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">prev_ramp</span><span class="p">)):</span>
            <span class="n">prev_ramp</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">prev_ramp</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        
        <span class="n">resized</span> <span class="o">=</span> <span class="n">prev_ramp</span><span class="o">.</span><span class="n">values</span>
        <span class="c1">#resized = cv2.resize(prev_ramp.values,dsize=(width,length), interpolation=cv2.INTER_LINEAR) #or INTER_CUBIC ?</span>
        <span class="c1">#prev_ramp = prev_ramp.interp_like(ifg_ml, method=&#39;linear&#39;)</span>
        <span class="c1"># if gacos is to be applied, need to remove its effect first here:</span>
        <span class="k">if</span> <span class="s1">&#39;gacos&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">resized</span> <span class="o">=</span> <span class="n">resized</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">resized</span>
        <span class="c1"># apply the correction - wrapping it and conjugate in complex realm</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">resized</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">resized</span><span class="p">)</span>
        <span class="n">cpx_corr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">correction</span><span class="p">)</span>
        <span class="c1">#a trick to apply the correction only to non-nan values.. &#39;other&#39;</span>
        <span class="c1">#da = da.where(xrda.isnull(), other=da.values * np.conjugate(cpx_corr))</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">cpx_corr</span><span class="p">)</span>
        <span class="n">resized</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">pre_detrend</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no need to detrend if prev_ramp is here, cancelling to avoid extra noise&#39;</span><span class="p">)</span>
            <span class="n">pre_detrend</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="p">)</span>
    <span class="c1">#if type(ml_weights) == type(None):</span>
    <span class="c1">#    #have the orig coh here:</span>
    <span class="c1">#    ifg_ml[&#39;coh&#39;] = ifg_ml[&#39;pha&#39;]</span>
    <span class="c1">#    ifg_ml.coh.values = np.abs(ifg_ml.cpx)</span>
    <span class="c1">#have gacos removed first, prior to doing height corr:</span>
    <span class="k">if</span> <span class="s1">&#39;gacos&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39; removing this check, because we want to FORCE-apply GACOS.. otherwise we get loop closure errors...</span>
<span class="sd">        pha_no_gacos = wrap2phase(ifg_ml[&#39;pha&#39;] - ifg_ml[&#39;gacos&#39;])</span>
<span class="sd">        #if np.nanstd(pha_no_gacos) &gt;= np.nanstd(ifg_ml.pha.values):</span>
<span class="sd">        if get_fft_std(pha_no_gacos) &gt;= get_fft_std(ifg_ml[&#39;pha&#39;].values):</span>
<span class="sd">            print(&#39;GACOS correction would increase overall phase std - dropping&#39;)</span>
<span class="sd">            #ifg_ml = ifg_ml.drop(&#39;gacos&#39;)</span>
<span class="sd">        else:</span>
<span class="sd">            ifg_ml[&#39;pha&#39;].values = pha_no_gacos</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cpx</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">stdbeforegacos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span>
        <span class="c1">#stdbeforegacos = np.nanstd(ifg_ml.pha.where(ifg_ml.mask&gt;0).values)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">])</span>
        <span class="n">cpx</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="c1">#stdaftergacos = np.nanstd(ifg_ml.pha.where(ifg_ml.mask&gt;0).values)</span>
        <span class="n">stdaftergacos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stdaftergacos</span> <span class="o">&gt;</span> <span class="n">stdbeforegacos</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING, GACOS increases stddev here, from </span><span class="si">{0}</span><span class="s1"> to </span><span class="si">{1}</span><span class="s1"> rad - not using GACOS to help unwrapping&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">stdbeforegacos</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">stdaftergacos</span><span class="p">)))</span>
            <span class="c1"># just .. returning it back..</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">#ok, return coh, phase back to cpx</span>
        <span class="n">cpxa</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxa</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">pre_detrend</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">],</span> <span class="n">correction</span> <span class="o">=</span> <span class="n">detrend_ifg_xr</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">],</span> <span class="n">isphase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_correction</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="p">)</span>
        <span class="c1">#ifg_ml[&#39;pha&#39;] = ifg_ml[&#39;pha&#39;].where(ifg_ml.mask&gt;0)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">correction</span>
    <span class="c1">#</span>
    <span class="c1"># just mask it</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="s1">&#39;hgt&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># perform Gaussian filtering</span>
    <span class="c1">#ifg_ml = filter_ifg_ml(ifg_ml)</span>
    <span class="c1">#now fix the correlation with heights:</span>
    <span class="k">if</span> <span class="n">hgtcorr</span><span class="p">:</span>
        <span class="c1">#ifg_ml[&#39;toremove&#39;] = ifg_ml[&#39;toremove&#39;] + </span>
        <span class="c1"># dounw=False may be faster!</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calculating correlation with DEM&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">toremove_hgt</span> <span class="o">=</span> <span class="n">remove_height_corr</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">,</span> <span class="n">dounw</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">nonlinear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">pha_no_hgt</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">toremove_hgt</span><span class="p">)</span>
            <span class="n">cpx_no_hgt</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">pha_no_hgt</span><span class="p">)</span>
            <span class="c1">#if np.nanstd(pha_no_hgt) &gt;= np.nanstd(ifg_ml.pha.values):</span>
            <span class="c1">#    print(&#39;but the correction would increase overall phase std - dropping&#39;)</span>
            <span class="c1">#    hgtcorr = False</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">cpx_no_hgt</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="o">.</span><span class="n">values</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;but the correction would increase overall complex std - dropping&#39;</span><span class="p">)</span>
                <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">toremove_hgt</span>
                <span class="c1"># need to remove hgt only here, as the &#39;toremove&#39; was already removed before..</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">pha_no_hgt</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1">#ok, return coh, phase back to cpx</span>
                <span class="n">cpxa</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxa</span>
                <span class="k">if</span> <span class="n">pre_detrend</span><span class="p">:</span>
                    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">],</span> <span class="n">correction</span> <span class="o">=</span> <span class="n">detrend_ifg_xr</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">],</span> <span class="n">isphase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_correction</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="p">)</span>
                    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">correction</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error trying correlate with DEM. continuing without it&#39;</span><span class="p">)</span>
    <span class="c1"># maybe not the best, but have gacos correction inside the toremove variable</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># oh, ok, also masking pixels with small number of pre-multilooked points (landmasked)</span>
    <span class="k">if</span> <span class="s1">&#39;pxcount&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
        <span class="c1"># try setting to something like 90 if ML10</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">thres_pxcount</span><span class="p">:</span>
            <span class="c1">#thres_pxcount = int(round((ml**2)/2))</span>
            <span class="c1"># if not set, we will auto-set it to mask multilooked pixels with less than 80% input (non-nan) pixels</span>
            <span class="n">thres_pxcount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">ml</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="o">/</span><span class="mi">5</span><span class="p">))</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pxcount</span> <span class="o">&gt;=</span> <span class="n">thres_pxcount</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_coh_debug</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;orig_coh&#39;</span><span class="p">]</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ifg_ml</span></div>


<span class="c1">################################################################################</span>
<span class="c1"># Helping functions</span>
<span class="c1">################################################################################</span>


<span class="k">def</span> <span class="nf">load_tif</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;unw&#39;</span><span class="p">,</span><span class="n">cliparea_geo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">pubdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">]</span>
    <span class="n">geoframedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pubdir</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">])),</span><span class="n">frame</span><span class="p">)</span>
    <span class="n">geoifgdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;interferograms&#39;</span><span class="p">,</span><span class="n">pair</span><span class="p">)</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.&#39;</span><span class="o">+</span><span class="n">dtype</span><span class="o">+</span><span class="s1">&#39;.tif&#39;</span><span class="p">)</span>
    <span class="k">return</span>  <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span><span class="n">cliparea_geo</span><span class="o">=</span><span class="n">cliparea_geo</span><span class="p">)</span>


<div class="viewcode-block" id="get_resolution"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.get_resolution">[docs]</a><span class="k">def</span> <span class="nf">get_resolution</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">in_m</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gets resolution of the xr.dataset (or dataarray), either in metres or degrees</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">resdeg</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ifg</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ifg</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">in_m</span><span class="p">:</span>
        <span class="n">latres</span> <span class="o">=</span> <span class="mf">111.32</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span> <span class="o">*</span> <span class="mi">1000</span> <span class="c1"># in m</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">latres</span> <span class="o">*</span> <span class="n">resdeg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">resdeg</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">load_from_tifs</span><span class="p">(</span><span class="n">phatif</span><span class="p">,</span> <span class="n">cohtif</span><span class="p">,</span> <span class="n">landmask_tif</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">inpha</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">phatif</span><span class="p">)</span>
    <span class="n">incoh</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">cohtif</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">incoh</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">incoh</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">incoh</span><span class="o">.</span><span class="n">values</span><span class="o">/</span><span class="mi">255</span>
    <span class="n">inmask</span> <span class="o">=</span> <span class="n">incoh</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">inmask</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">(</span><span class="n">incoh</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">landmask_tif</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">landmask_tif</span><span class="p">):</span>
            <span class="n">landmask</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">landmask_file</span><span class="p">)</span>
            <span class="n">inmask</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">landmask</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">inmask</span><span class="o">.</span><span class="n">values</span>
    <span class="n">ifg</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inpha</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">incoh</span><span class="o">.</span><span class="n">values</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">inmask</span><span class="o">.</span><span class="n">values</span>
    <span class="c1"># just to clean from memory</span>
    <span class="n">inpha</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
    <span class="n">incoh</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask_extent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cliparea_geo</span><span class="p">:</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipy</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minclipy</span> <span class="o">&gt;</span> <span class="n">maxclipy</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (latitude). fixing&#39;</span><span class="p">)</span>
            <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipy</span>
            <span class="n">minclipy</span><span class="o">=</span><span class="n">maxclipy</span>
            <span class="n">maxclipy</span><span class="o">=</span><span class="n">tmpcl</span>
        <span class="k">if</span> <span class="n">minclipx</span> <span class="o">&gt;</span> <span class="n">maxclipx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (longitude). fixing&#39;</span><span class="p">)</span>
            <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipx</span>
            <span class="n">minclipx</span><span class="o">=</span><span class="n">maxclipx</span>
            <span class="n">maxclipx</span><span class="o">=</span><span class="n">tmpcl</span>
        <span class="c1"># now will clip it - lat is opposite-sorted, so need to slice from max to min in y</span>
        <span class="n">ifg</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">),</span> <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ifg</span>


<span class="k">def</span> <span class="nf">load_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">unw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dolocal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">pubdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">]</span>
    <span class="n">geoframedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pubdir</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">])),</span><span class="n">frame</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dolocal</span><span class="p">:</span>
        <span class="n">geoifgdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;GEOC&#39;</span><span class="p">,</span><span class="n">pair</span><span class="p">)</span>
        <span class="n">hgtfile</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;GEOC/*.geo.hgt.tif&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">landmask_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;GEOC&#39;</span><span class="p">,</span><span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.landmask.tif&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">geoifgdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;interferograms&#39;</span><span class="p">,</span><span class="n">pair</span><span class="p">)</span>
        <span class="n">hgtfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;metadata&#39;</span><span class="p">,</span><span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.hgt.tif&#39;</span><span class="p">)</span>
        <span class="n">landmask_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;metadata&#39;</span><span class="p">,</span><span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.landmask.tif&#39;</span><span class="p">)</span>
    <span class="c1">#orig files</span>
    <span class="c1"># will use only the filtered ifgs now..</span>
    <span class="n">ifg_pha_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)</span>
    <span class="n">coh_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.cc.tif&#39;</span><span class="p">)</span>
    <span class="c1">#landmask_file = os.path.join(geoframedir,&#39;metadata&#39;,frame+&#39;.geo.landmask.tif&#39;)</span>
    <span class="c1"># load the files</span>
    <span class="n">inpha</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">ifg_pha_file</span><span class="p">)</span>
    <span class="n">incoh</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">coh_file</span><span class="p">)</span>
    <span class="n">incoh</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">incoh</span><span class="o">.</span><span class="n">values</span><span class="o">/</span><span class="mi">255</span>
    <span class="n">inmask</span> <span class="o">=</span> <span class="n">incoh</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">inmask</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">(</span><span class="n">incoh</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">landmask_file</span><span class="p">):</span>
        <span class="n">landmask</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">landmask_file</span><span class="p">)</span>
        <span class="c1">#landmask = xr.open_dataset(landmasknc)</span>
        <span class="n">inmask</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">landmask</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">inmask</span><span class="o">.</span><span class="n">values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">landmask</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># create datacube</span>
    <span class="n">ifg</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inpha</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">incoh</span><span class="o">.</span><span class="n">values</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">inmask</span><span class="o">.</span><span class="n">values</span>
    <span class="c1"># just to clean from memory</span>
    <span class="n">inpha</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
    <span class="n">incoh</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
    <span class="c1"># to load orig unw_file</span>
    <span class="k">if</span> <span class="n">unw</span><span class="p">:</span>
        <span class="n">unw_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">)</span>
        <span class="n">inunw</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">unw_file</span><span class="p">)</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">inunw</span><span class="o">.</span><span class="n">values</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask_extent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># including hgt anyway - would be useful later</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">inhgt</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">)</span>
            <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
            <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">inhgt</span><span class="o">.</span><span class="n">values</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR in importing heights!&#39;</span><span class="p">)</span>
            <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">cliparea_geo</span><span class="p">:</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipy</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minclipy</span> <span class="o">&gt;</span> <span class="n">maxclipy</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (latitude). fixing&#39;</span><span class="p">)</span>
            <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipy</span>
            <span class="n">minclipy</span><span class="o">=</span><span class="n">maxclipy</span>
            <span class="n">maxclipy</span><span class="o">=</span><span class="n">tmpcl</span>
        <span class="k">if</span> <span class="n">minclipx</span> <span class="o">&gt;</span> <span class="n">maxclipx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (longitude). fixing&#39;</span><span class="p">)</span>
            <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipx</span>
            <span class="n">minclipx</span><span class="o">=</span><span class="n">maxclipx</span>
            <span class="n">maxclipx</span><span class="o">=</span><span class="n">tmpcl</span>
        <span class="c1"># now will clip it - lat is opposite-sorted, so need to slice from max to min in y</span>
        <span class="n">ifg</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">),</span> <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ifg</span>


<span class="k">def</span> <span class="nf">gaussfill</span><span class="p">(</span><span class="n">dapha</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">tempar_mag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">dapha</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
    <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">dapha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">i</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">dapha</span><span class="o">.</span><span class="n">values</span><span class="p">)):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gapfilling iteration &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
            <span class="c1"># no need to add more heavy iterations</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filling by nearest neighbours&#39;</span><span class="p">)</span>
            <span class="n">dapha</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">dapha</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tofill</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">dapha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="n">tofillR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">tofill</span><span class="p">)</span>
            <span class="n">tofillI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">tofill</span><span class="p">)</span>
            <span class="n">filledR</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">tofillR</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
            <span class="n">filledI</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">tofillI</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
            <span class="n">dapha</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">filledR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">filledI</span><span class="p">)</span>
    <span class="c1"># but i need to finally smooth it a bit</span>
    <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">dapha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">gauss_cpx</span> <span class="o">=</span> <span class="n">filter_nan_gaussian_conserving</span><span class="p">(</span><span class="n">cpxarr</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">trunc</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">dapha</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">gauss_cpx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dapha</span>



<span class="k">def</span> <span class="nf">lowpass_gauss</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">thres</span><span class="o">=</span><span class="mf">0.35</span><span class="p">,</span> <span class="n">defomax</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_gold</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">goldwin</span><span class="o">=</span><span class="mi">16</span><span class="p">):</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">use_gold</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;warning, switched fully from Gaussian filtering to Goldstein fashion, also for lowpass&#39;</span><span class="p">)</span>
        <span class="c1"># change gauss filter to goldstein - takes longer but should be better</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">values</span>
        <span class="n">dapha</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">dapha</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="n">dd</span><span class="p">,</span><span class="n">cc</span> <span class="o">=</span> <span class="n">goldstein_filter_xr</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">],</span> <span class="n">blocklen</span><span class="o">=</span><span class="n">goldwin</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">values</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">cc</span><span class="o">&gt;</span><span class="n">thres</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">*</span><span class="n">mask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="mi">15</span><span class="o">*</span><span class="n">get_resolution</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">)</span>  <span class="c1">#in 30x30 window.. should be ok to do</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">filter_ifg_ml</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">radius</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_pha&#39;</span><span class="p">]</span>  <span class="c1"># pha is to unwrap</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_coh</span><span class="o">&gt;</span><span class="n">thres</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># additionally remove islands that are smaller than 2x2 km</span>
    <span class="n">lenthres</span> <span class="o">=</span> <span class="mi">2000</span> <span class="c1"># m</span>
    <span class="c1"># resolution of orig ifg is expected 0.1 km</span>
    <span class="n">mlres</span> <span class="o">=</span> <span class="n">get_resolution</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">in_m</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pixels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">lenthres</span><span class="o">/</span><span class="n">mlres</span><span class="p">))</span>
    <span class="n">maxpx</span> <span class="o">=</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">16</span>
    <span class="n">pixelsno</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pixels</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">maxpx</span><span class="p">)</span>
    <span class="c1">#pixelsno = 7*7 # let&#39;s just have it in pixels</span>
    <span class="n">npa</span><span class="o">=</span><span class="n">mask</span><span class="o">*</span><span class="mf">1.0</span>
    <span class="n">npa</span><span class="p">[</span><span class="n">npa</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">mask</span><span class="o">=</span><span class="n">remove_islands</span><span class="p">(</span><span class="n">npa</span><span class="p">,</span> <span class="n">pixelsno</span><span class="p">)</span>
    <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    
    <span class="c1">#dapha = ifg_ml.pha.where(mask*ifg_ml.mask_full != 0)</span>
    <span class="n">dapha</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">cpx</span> <span class="o">=</span> <span class="n">pha2cpx</span><span class="p">(</span><span class="n">dapha</span><span class="p">)</span>
    <span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span>
    <span class="n">imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span>
    <span class="c1"># linearly interpolate in both real and imag - better than nearest but not perfect (gaussian fill would do better job)</span>
    <span class="n">real</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="n">imag</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">imag</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="n">cpx</span> <span class="o">=</span> <span class="n">real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">imag</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span>
    <span class="c1">#ifg_ml[&#39;pha&#39;].values = interpolate_nans(dapha.values, method=&#39;nearest&#39;)</span>
    <span class="c1">#ifg_ml[&#39;pha&#39;].values = interpolate_nans(dapha.values, method=&#39;linear&#39;) # should be better here..</span>
    <span class="c1">#if not use_gold:</span>
    <span class="c1">#    # second filter</span>
    <span class="c1">#    ifg_ml = filter_ifg_ml(ifg_ml, radius = radius)</span>
    <span class="c1">#    ifg_ml[&#39;pha&#39;] = ifg_ml[&#39;gauss_pha&#39;]  # pha is to unwrap</span>
    <span class="c1">#ifg_ml[&#39;pha&#39;].values = gaussfill(dapha, sigma=2)   # low pass filter   # gives ugly results</span>
    <span class="c1"># unwrap and reduce that</span>
    <span class="n">coh</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="n">tempar_mag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="p">)</span>
    <span class="c1">#cpxarr = magpha2RI_array(tempar_mag1, ifg_ml.pha.values)</span>
    <span class="n">cpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">(</span><span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
    <span class="c1">#unw = unwrap_np(cpx, coh, mask = mask, defomax = defomax, deltemp=True)      # it doesn&#39;t work well with mask!</span>
    <span class="n">unw</span> <span class="o">=</span> <span class="n">unwrap_np</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">deltemp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">unw</span> <span class="o">=</span> <span class="n">filter_nan_gaussian_conserving</span><span class="p">(</span><span class="n">unw</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">trunc</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># a stronger filter should help...</span>
    <span class="k">if</span> <span class="s1">&#39;toremove&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">unw</span> <span class="c1"># adding the lowpass to &#39;toremove&#39; layer</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
        <span class="n">ifg_ml</span><span class="o">.</span><span class="n">toremove</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">unw</span>
    <span class="k">if</span> <span class="s1">&#39;origpha&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">unw</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>  <span class="c1"># needed in later stage</span>
    <span class="k">if</span> <span class="s1">&#39;cpx&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">origpha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unwlow&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unwlow&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">unw</span>
    <span class="k">return</span> <span class="n">ifg_ml</span>


<div class="viewcode-block" id="interpolate_nans"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.interpolate_nans">[docs]</a><span class="k">def</span> <span class="nf">interpolate_nans</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolation of NaN values in a grid</span>

<span class="sd">    Args:</span>
<span class="sd">        array (np.array): numpy array with nans to interpolate</span>
<span class="sd">        method (string): interpolation method for griddata function, e.g. cubic</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: interpolated grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">xx</span><span class="p">[</span><span class="o">~</span><span class="n">array</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">yy</span><span class="p">[</span><span class="o">~</span><span class="n">array</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">newarr</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="o">~</span><span class="n">array</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">GD1</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">griddata</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">newarr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">),</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="n">GD1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">GD1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GD1</span></div>


<div class="viewcode-block" id="runcmd"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.runcmd">[docs]</a><span class="k">def</span> <span class="nf">runcmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">printcmd</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Runs command through os.system</span>

<span class="sd">    Args:</span>
<span class="sd">        cmd (string): command to run</span>
<span class="sd">        printcmd (boolean): if True, will do verbose</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">printcmd</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#with nostdout():</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="o">+</span><span class="s1">&#39; &gt;/dev/null 2&gt;/dev/null&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING - command did not exit as OK&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="magpha2RI_array"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.magpha2RI_array">[docs]</a><span class="k">def</span> <span class="nf">magpha2RI_array</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">pha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts arrays of magnitude and phase to complex number array (real and imaginary)</span>

<span class="sd">    Args:</span>
<span class="sd">        mag (np.array): numpy array with magnitude values</span>
<span class="sd">        pha (np.array): numpy array with phase values</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: complex number array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">pha</span><span class="p">)</span> <span class="o">*</span> <span class="n">mag</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">pha</span><span class="p">)</span> <span class="o">*</span> <span class="n">mag</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">I</span>
    <span class="k">return</span> <span class="n">out</span></div>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def coh_from_phadiff(phadiff, winsize = 3):</span>
<span class="sd">    &quot;&quot;&quot;Calculates coherence based on variance of interferogram, computed in window with given size</span>

<span class="sd">    Args:</span>
<span class="sd">        phadiff (np.array): interferogram</span>
<span class="sd">        winsize (int): window size</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: coherence based on the variance</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    variance = ndimage.generic_filter(phadiff, np.var, size=winsize)</span>
<span class="sd">    outcoh = 1/np.sqrt(1+winsize*winsize*variance)</span>
<span class="sd">    return outcoh</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="coh_from_phadiff"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.coh_from_phadiff">[docs]</a><span class="k">def</span> <span class="nf">coh_from_phadiff</span><span class="p">(</span><span class="n">phadiff</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates coherence based on variance of interferogram, computed in window with given size</span>

<span class="sd">    Args:</span>
<span class="sd">        phadiff (np.array): interferogram</span>
<span class="sd">        winsize (int): window size</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: coherence based on the variance</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cpxdiff</span> <span class="o">=</span> <span class="n">pha2cpx</span><span class="p">(</span><span class="n">phadiff</span><span class="p">)</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">generic_filter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">cpxdiff</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">winsize</span><span class="p">)</span>
    <span class="n">outcohr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">winsize</span> <span class="o">*</span> <span class="n">winsize</span> <span class="o">*</span> <span class="n">variance</span><span class="p">)</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">generic_filter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">cpxdiff</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">winsize</span><span class="p">)</span>
    <span class="n">outcohi</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">winsize</span> <span class="o">*</span> <span class="n">winsize</span> <span class="o">*</span> <span class="n">variance</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">outcohr</span> <span class="o">+</span> <span class="n">outcohi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span></div>


<div class="viewcode-block" id="filter_cpx_gauss"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.filter_cpx_gauss">[docs]</a><span class="k">def</span> <span class="nf">filter_cpx_gauss</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">trunc</span> <span class="o">=</span> <span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gaussian-based spatial filter on complex numbers (interferogram)</span>

<span class="sd">    Args:</span>
<span class="sd">        ifg_ml (xr.Dataset): xarray dataset of the interferogram, must contain &#39;cpx&#39; dataarray</span>
<span class="sd">        sigma (int): sigma parameter to gaussian filter</span>
<span class="sd">        trunc (int): trunc parameter to gaussian filter</span>

<span class="sd">    Returns:</span>
<span class="sd">        xr.Dataarray: filtered complex numbers dataarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># tried with R, I separately --- EXACT same result as if using cpx numbers...</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="n">gR</span> <span class="o">=</span> <span class="n">filter_nan_gaussian_conserving</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">trunc</span><span class="o">=</span><span class="n">trunc</span><span class="p">)</span>
    <span class="n">gI</span> <span class="o">=</span> <span class="n">filter_nan_gaussian_conserving</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">trunc</span><span class="o">=</span><span class="n">trunc</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="n">gauss_cpx</span> <span class="o">=</span> <span class="n">gR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">gI</span>
    <span class="c1"># ok, but this is possible only with new numpy:</span>
    <span class="c1">#gauss_cpx = filter_nan_gaussian_conserving(ifg_ml.cpx.values, sigma=sigma, trunc=trunc)</span>
    <span class="n">gauss_xr</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="n">gauss_xr</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">gauss_cpx</span>
    <span class="k">return</span> <span class="n">gauss_xr</span></div>


<div class="viewcode-block" id="filter_nan_gaussian_conserving"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.filter_nan_gaussian_conserving">[docs]</a><span class="k">def</span> <span class="nf">filter_nan_gaussian_conserving</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">trunc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply a gaussian filter to an array with nans.</span>
<span class="sd">    </span>
<span class="sd">    based on:</span>
<span class="sd">    https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python</span>
<span class="sd">    </span>
<span class="sd">    Intensity is only shifted between not-nan pixels and is hence conserved.</span>
<span class="sd">    The intensity redistribution with respect to each single point</span>
<span class="sd">    is done by the weights of available pixels according</span>
<span class="sd">    to a gaussian distribution.</span>
<span class="sd">    All nans in arr, stay nans in gauss.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        arr (np.array): array of real numbers to filter by Gaussian kernel</span>
<span class="sd">        sigma (int): sigma parameter to gaussian filter</span>
<span class="sd">        trunc (int): trunc parameter to gaussian filter</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: filtered real numbers array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nan_msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">loss</span><span class="p">[</span><span class="n">nan_msk</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span>
            <span class="n">loss</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="n">trunc</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gauss</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">gauss</span><span class="p">[</span><span class="n">nan_msk</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">gauss</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span>
            <span class="n">gauss</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="n">trunc</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">gauss</span><span class="p">[</span><span class="n">nan_msk</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">gauss</span> <span class="o">+=</span> <span class="n">loss</span> <span class="o">*</span> <span class="n">arr</span>
    <span class="k">return</span> <span class="n">gauss</span></div>


<div class="viewcode-block" id="create_preview_bin"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.create_preview_bin">[docs]</a><span class="k">def</span> <span class="nf">create_preview_bin</span><span class="p">(</span><span class="n">binfile</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">ftype</span> <span class="o">=</span> <span class="s1">&#39;unw&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use of cpxfiddle to create simple preview PNG rasters from binary files</span>

<span class="sd">    Args:</span>
<span class="sd">        binfile (string): path to the binary file to generate preview from</span>
<span class="sd">        width (int): width of the binary file</span>
<span class="sd">        ftype (string): filetype. Supported types: unw, pha, coh, mag</span>

<span class="sd">    Returns:</span>
<span class="sd">        string: filename of the generated preview png file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;unw&#39;</span><span class="p">:</span>
        <span class="n">q</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span>
        <span class="n">f</span><span class="o">=</span><span class="s1">&#39;r4&#39;</span>
        <span class="n">c</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span>
        <span class="n">r</span><span class="o">=</span><span class="s1">&#39;-r -20,20&#39;</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;pha&#39;</span><span class="p">:</span>
        <span class="n">q</span><span class="o">=</span><span class="s1">&#39;phase&#39;</span>
        <span class="n">f</span><span class="o">=</span><span class="s1">&#39;cr4&#39;</span>
        <span class="n">c</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;coh&#39;</span><span class="p">:</span>
        <span class="n">q</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span>
        <span class="n">f</span><span class="o">=</span><span class="s1">&#39;r4&#39;</span>
        <span class="n">c</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span>
        <span class="n">r</span><span class="o">=</span><span class="s1">&#39;-r 0,1&#39;</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span><span class="p">:</span>
        <span class="n">q</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span>
        <span class="n">f</span><span class="o">=</span><span class="s1">&#39;cr4&#39;</span>
        <span class="n">c</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;wrong ftype - choose one of: unw,pha,coh,mag&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="n">binfile</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span>
    <span class="n">runcmd</span><span class="p">(</span><span class="s1">&#39;cpxfiddle -w </span><span class="si">{0}</span><span class="s1"> -o sunraster -q </span><span class="si">{1}</span><span class="s1"> -f </span><span class="si">{2}</span><span class="s1"> -c </span><span class="si">{3}</span><span class="s1"> </span><span class="si">{4}</span><span class="s1"> </span><span class="si">{5}</span><span class="s1"> &gt; </span><span class="si">{6}</span><span class="s1"> 2&gt;/dev/null&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">width</span><span class="p">),</span> <span class="n">q</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">binfile</span><span class="p">,</span> <span class="n">binfile</span><span class="o">+</span><span class="s1">&#39;.ras&#39;</span><span class="p">))</span>
    <span class="n">runcmd</span><span class="p">(</span><span class="s1">&#39;convert -resize 700x </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">binfile</span><span class="o">+</span><span class="s1">&#39;.ras&#39;</span><span class="p">,</span><span class="n">outfile</span><span class="p">))</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">binfile</span><span class="o">+</span><span class="s1">&#39;.ras&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">outfile</span></div>


<span class="k">try</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">resize_bin</span><span class="p">(</span><span class="n">inbin</span><span class="p">,</span> <span class="n">inwid</span><span class="p">,</span> <span class="n">inlen</span><span class="p">,</span> <span class="n">outbin</span><span class="p">,</span> <span class="n">outwid</span><span class="p">,</span> <span class="n">outlen</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">,</span> <span class="n">intertype</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_NEAREST</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use of cv2 to interpolate/resize binary file to new dimensions</span>

<span class="sd">        Args:</span>
<span class="sd">            inbin (string): path to the binary file</span>
<span class="sd">            inwid (int): width of the input binary file</span>
<span class="sd">            inlen (int): length of the input binary file</span>
<span class="sd">            outbin (string): path to the output binary file</span>
<span class="sd">            outwid (int): target width of the output binary file</span>
<span class="sd">            outlen (int): target length of the output binary file</span>
<span class="sd">            dtype (string): data type of the binary, e.g. np.byte</span>
<span class="sd">            intertype (string): type of interpolation for cv2, e.g. cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">inbin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">inlen</span><span class="p">,</span> <span class="n">inwid</span><span class="p">)</span>
        <span class="c1">#use cv2.INTER_CUBIC for upsample np.float32 data ...</span>
        <span class="c1">#a = a - np.nanmedian(a)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">dsize</span><span class="o">=</span><span class="p">(</span><span class="n">outwid</span><span class="p">,</span><span class="n">outlen</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">intertype</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">outbin</span><span class="p">)</span>
        <span class="k">return</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error loading resize_bin function - cascade will not work (install cv2)&#39;</span><span class="p">)</span>



<div class="viewcode-block" id="RI2cpx"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.RI2cpx">[docs]</a><span class="k">def</span> <span class="nf">RI2cpx</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">cpxfile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert real and imaginary binary files to a complex number binary file. Obsolete function.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        R (string): path to the binary file with real values</span>
<span class="sd">        I (string): path to the binary file with imaginary values</span>
<span class="sd">        cpxfile (string): path to the binary file for complex output</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># we may either load R, I from file:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">cpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">cpx</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="n">cpx</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">cpxfile</span><span class="p">)</span></div>


<div class="viewcode-block" id="remove_islands"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.remove_islands">[docs]</a><span class="k">def</span> <span class="nf">remove_islands</span><span class="p">(</span><span class="n">npa</span><span class="p">,</span> <span class="n">pixelsno</span> <span class="o">=</span> <span class="mi">50</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Removes isolated clusters of pixels from numpy array npa having less than pixelsno pixels.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        npa (np.array): (unwrapped) interferogram with NaNs</span>
<span class="sd">        pixelsno (int): minimum number of pixels in isolated clusters (connected components)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        np.array: array after removing islands</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#check the mask - should be 1 for islands and 0 for nans</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">npa</span><span class="p">)</span>
    <span class="n">islands</span><span class="p">,</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncomp</span><span class="p">):</span>
        <span class="c1">#island = islands == i # need to get this one right</span>
        <span class="c1">#island = npa[islands==i]</span>
        <span class="n">numofpixels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">islands</span><span class="o">==</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">numofpixels</span> <span class="o">&lt;</span> <span class="n">pixelsno</span><span class="p">:</span>
            <span class="n">npa</span><span class="p">[</span><span class="n">islands</span><span class="o">==</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">npa</span></div>


<div class="viewcode-block" id="main_unwrap"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.main_unwrap">[docs]</a><span class="k">def</span> <span class="nf">main_unwrap</span><span class="p">(</span><span class="n">cpxbin</span><span class="p">,</span> <span class="n">cohbin</span><span class="p">,</span> <span class="n">maskbin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">outunwbin</span> <span class="o">=</span> <span class="s1">&#39;unwrapped.bin&#39;</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">est</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bin_pre_remove</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">conncomp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">printout</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Main function to perform unwrapping with snaphu.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        cpxbin (string): path to cpxfloat32 binary interferogram to unwrap</span>
<span class="sd">        cohbin (string): path to float32 binary for coherence</span>
<span class="sd">        maskbin (string or None): path to mask binary</span>
<span class="sd">        outunwbin (string): path to output unwrapped binary</span>
<span class="sd">        width (int): width of binary raster</span>
<span class="sd">        est (string or None): path to coarse estimate binary (float32)</span>
<span class="sd">        bin_pre_remove (string or None): path to float32 binary to remove from est, prior to unwrapping</span>
<span class="sd">        conncomp (boolean): whether to save connected components</span>
<span class="sd">        defomax (float): max defo cycles</span>
<span class="sd">        printout (boolean): controls verbosity of text output</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#print(&#39;WARNING - we skip using mask here, as snaphu -M really does not do good job. need to change for AH+KS solution soon&#39;)</span>
    <span class="c1">#maskbin = None</span>
    <span class="k">if</span> <span class="n">width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error - width is zero&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">bin_pre_remove</span> <span class="ow">and</span> <span class="n">est</span><span class="p">:</span>
        <span class="c1"># we will remove phase from the est, prior to processing</span>
        <span class="n">est_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">est</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">est_rem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">bin_pre_remove</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">est_np</span> <span class="o">=</span> <span class="n">est_np</span> <span class="o">-</span> <span class="n">est_rem</span>
        <span class="n">est_np</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">est</span><span class="p">)</span>
        <span class="n">est_np</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">est_rem</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">printout</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;processing by snaphu&#39;</span><span class="p">)</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">cpxbin</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;/&#39;</span>
    <span class="n">snaphuconffile</span> <span class="o">=</span> <span class="n">make_snaphu_conf</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">defomax</span><span class="p">)</span>
    <span class="n">extracmd</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">est</span><span class="p">:</span>
        <span class="n">extracmd</span> <span class="o">=</span> <span class="s2">&quot;-e </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">est</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">conncomp</span><span class="p">:</span>
        <span class="n">conncompfile</span><span class="o">=</span><span class="n">outunwbin</span><span class="o">+</span><span class="s1">&#39;.conncomp&#39;</span>
        <span class="n">extracmd</span> <span class="o">=</span> <span class="n">extracmd</span><span class="o">+</span><span class="s1">&#39; -g </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">conncompfile</span><span class="p">)</span>
    <span class="n">starttime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">maskbin</span><span class="p">:</span>
        <span class="n">snaphucmd</span> <span class="o">=</span> <span class="s1">&#39;snaphu -f </span><span class="si">{0}</span><span class="s1"> -o </span><span class="si">{1}</span><span class="s1"> -c </span><span class="si">{2}</span><span class="s1"> </span><span class="si">{3}</span><span class="s1"> </span><span class="si">{4}</span><span class="s1"> </span><span class="si">{5}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">snaphuconffile</span><span class="p">,</span> <span class="n">outunwbin</span><span class="p">,</span> <span class="n">cohbin</span><span class="p">,</span> <span class="n">extracmd</span><span class="p">,</span> <span class="n">cpxbin</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">width</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">snaphucmd</span> <span class="o">=</span> <span class="s1">&#39;snaphu -f </span><span class="si">{0}</span><span class="s1"> -M </span><span class="si">{1}</span><span class="s1"> -o </span><span class="si">{2}</span><span class="s1"> -c </span><span class="si">{3}</span><span class="s1"> </span><span class="si">{4}</span><span class="s1"> </span><span class="si">{5}</span><span class="s1"> </span><span class="si">{6}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">snaphuconffile</span><span class="p">,</span> <span class="n">maskbin</span><span class="p">,</span> <span class="n">outunwbin</span><span class="p">,</span> <span class="n">cohbin</span><span class="p">,</span> <span class="n">extracmd</span><span class="p">,</span> <span class="n">cpxbin</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">width</span><span class="p">))</span>
    <span class="n">runcmd</span><span class="p">(</span><span class="n">snaphucmd</span><span class="p">,</span> <span class="n">printout</span><span class="p">)</span> <span class="c1">#True)</span>
    <span class="k">if</span> <span class="n">printout</span><span class="p">:</span>
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">starttime</span>
        <span class="n">hour</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elapsed_time</span><span class="o">/</span><span class="mi">3600</span><span class="p">)</span>
        <span class="n">minite</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">((</span><span class="n">elapsed_time</span><span class="o">/</span><span class="mi">60</span><span class="p">),</span><span class="mi">60</span><span class="p">))</span>
        <span class="n">sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span><span class="mi">60</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Elapsed time: </span><span class="si">{0:02}</span><span class="s2">h </span><span class="si">{1:02}</span><span class="s2">m </span><span class="si">{2:02}</span><span class="s2">s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hour</span><span class="p">,</span><span class="n">minite</span><span class="p">,</span><span class="n">sec</span><span class="p">))</span>
    <span class="k">return</span></div>



<div class="viewcode-block" id="create_preview"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.create_preview">[docs]</a><span class="k">def</span> <span class="nf">create_preview</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">ftype</span> <span class="o">=</span> <span class="s1">&#39;unwrapped&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates preview of interferogram (wrapped or unwrapped) - works only with licsar_proc</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        infile (string): path to input tif to generate preview</span>
<span class="sd">        ftype (string): type of the input file. can be: &#39;wrapped&#39;, &#39;unwrapped&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;wrapped&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ftype</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;wrong ftype&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;wrapped&#39;</span><span class="p">:</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">tosource</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSARpath&#39;</span><span class="p">],</span><span class="s1">&#39;lib&#39;</span><span class="p">,</span><span class="s1">&#39;LiCSAR_bash_lib.sh&#39;</span><span class="p">)</span>
    <span class="n">command</span> <span class="o">=</span> <span class="s1">&#39;create_preview_&#39;</span><span class="o">+</span><span class="n">ftype</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;source </span><span class="si">{0}</span><span class="s1">; </span><span class="si">{1}</span><span class="s1"> </span><span class="si">{2}</span><span class="s1"> </span><span class="si">{3}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tosource</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">infile</span><span class="p">,</span> <span class="n">extra</span><span class="p">))</span></div>


<div class="viewcode-block" id="make_snaphu_conf"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_snaphu_conf">[docs]</a><span class="k">def</span> <span class="nf">make_snaphu_conf</span><span class="p">(</span><span class="n">sdir</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates snaphu configuration file</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        sdir (string): directory where to generate snaphu.conf</span>
<span class="sd">        defomax (float): DEFOMAX parameter to snaphu</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        string: path to generated snaphu.conf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">snaphuconf</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;STATCOSTMODE  DEFO</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;INFILEFORMAT  COMPLEX_DATA</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;CORRFILEFORMAT  FLOAT_DATA</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;OUTFILEFORMAT FLOAT_DATA</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ESTFILEFORMAT FLOAT_DATA</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;DEFOMAX_CYCLE &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">defomax</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;RMTMPTILE TRUE</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">snaphuconffile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sdir</span><span class="p">,</span><span class="s1">&#39;snaphu.conf&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">snaphuconffile</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">snaphuconf</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">snaphuconffile</span></div>


<div class="viewcode-block" id="make_gacos_ifg"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_gacos_ifg">[docs]</a><span class="k">def</span> <span class="nf">make_gacos_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates GACOS correction for the interferogram. works only at JASMIN</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        frame (string): frame ID</span>
<span class="sd">        pair (string): pair ID (e.g. &#39;20201001_20201201&#39;)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        string: path to generated GACOS correction, or False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;preparing GACOS correction&#39;</span><span class="p">)</span>
    <span class="n">pubdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">]</span>
    <span class="n">geoframedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pubdir</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">])),</span><span class="n">frame</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
        <span class="n">epochgacos</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;epochs&#39;</span><span class="p">,</span><span class="n">epoch</span><span class="p">,</span><span class="n">epoch</span><span class="o">+</span><span class="s1">&#39;.sltd.geo.tif&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">epochgacos</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="n">epoch1</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">epoch2</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">gacos1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;epochs&#39;</span><span class="p">,</span><span class="n">epoch1</span><span class="p">,</span><span class="n">epoch1</span><span class="o">+</span><span class="s1">&#39;.sltd.geo.tif&#39;</span><span class="p">)</span>
    <span class="n">gacos2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;epochs&#39;</span><span class="p">,</span><span class="n">epoch2</span><span class="p">,</span><span class="n">epoch2</span><span class="o">+</span><span class="s1">&#39;.sltd.geo.tif&#39;</span><span class="p">)</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;gmt grdmath </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1"> SUB = </span><span class="si">{2}</span><span class="s1">=gd:GTiff&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gacos2</span><span class="p">,</span> <span class="n">gacos1</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
    <span class="c1">#print(cmd)</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">outfile</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">outfile</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error in GACOS processing of pair &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="remove_height_corr"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.remove_height_corr">[docs]</a><span class="k">def</span> <span class="nf">remove_height_corr</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">corr_thres</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">dounw</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">nonlinear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Removes height-correlated signal</span>
<span class="sd">    </span>
<span class="sd">     first, correlate ```ifg_ml[&#39;pha&#39;]``` and ```ifg_ml[&#39;hgt&#39;]``` in blocks</span>
<span class="sd">      - better to keep dounw=True that unwraps each block by snaphu. but it can be slow</span>
<span class="sd">     get coefficient for correction of correlating areas</span>
<span class="sd">     interpolate the coefficient throughout whole raster</span>
<span class="sd">     multiply by hgt = &#39;to_remove&#39;</span>
<span class="sd">     </span>
<span class="sd">     Args:</span>
<span class="sd">        ifg_ml (xarray.Dataset): input dataset</span>
<span class="sd">        corr_thres (float): threshold of correlation within window to keep</span>
<span class="sd">        tmpdir (string): path to temp directory</span>
<span class="sd">        dounw (boolean): whether to unwrap the small windows, or try correlate with wrapped phase</span>
<span class="sd">        nonlinear (boolean): pass nonlinear parameter to correct_hgt</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataarray: dataarray of height correlation corrections</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ifg_mlc</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ifg_mlc</span> <span class="o">=</span> <span class="n">filter_ifg_ml</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">)</span>
    <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
    <span class="n">minheight</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">hgt</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span><span class="o">+</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">thisisit</span><span class="p">,</span> <span class="n">thistype</span> <span class="o">=</span> <span class="n">correct_hgt</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">,</span> <span class="n">blocklen</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">,</span> <span class="n">dounw</span> <span class="o">=</span> <span class="n">dounw</span><span class="p">,</span> <span class="n">nonlinear</span><span class="o">=</span><span class="n">nonlinear</span><span class="p">,</span> <span class="n">minheight</span><span class="o">=</span><span class="n">minheight</span><span class="p">)</span>
    <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Elapsed time for hgt correction: </span><span class="si">{:f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">))</span>
    <span class="c1">#thisisit can be either False, xr.DataArray, or np.float - ok, adding &#39;thistype&#39; that can be bool, float, xr</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">thistype</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">thistype</span> <span class="o">==</span> <span class="s1">&#39;float&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;we use average value of </span><span class="si">{}</span><span class="s1"> rad/km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">thisisit</span><span class="o">*</span><span class="mi">1000</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;using hgt correlation grid to reduce hgt component&#39;</span><span class="p">)</span>
        <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">thisisit</span><span class="o">*</span><span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">block_hgtcorr</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">hgt</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">dounw</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">block_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># first unwrap the block if conditions are ok</span>
    <span class="n">toret</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">hgt</span><span class="o">=</span><span class="n">hgt</span><span class="o">.</span><span class="n">values</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ok, hgt was already np&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hgt</span><span class="p">[</span><span class="n">hgt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">toret</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">hgt</span><span class="p">[</span><span class="n">hgt</span><span class="o">!=</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">hgt</span><span class="p">[</span><span class="n">hgt</span><span class="o">!=</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">toret</span><span class="p">:</span>
        <span class="c1"># too small coherence... although it may work anyway..</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coh</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.1</span><span class="p">:</span>
            <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1">#if not toret:</span>
    <span class="c1">#    if np.mean(coh)&lt;0.05:</span>
    <span class="c1">#        toret = np.nan</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">toret</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dounw</span><span class="p">:</span>
        <span class="c1">#ok, let&#39;s do it without the unwrapping first....</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">hgt</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cpx</span><span class="p">))</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
                        <span class="n">huber</span> <span class="o">=</span> <span class="n">HuberRegressor</span><span class="p">()</span>
                        <span class="n">rc</span> <span class="o">=</span> <span class="n">huber</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">slope</span> <span class="o">=</span> <span class="n">huber</span><span class="o">.</span><span class="n">coef_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1">#slope = np.polyfit(np.ravel(hgt), np.ravel(np.angle(cpx)), deg=1)[0]</span>
                        <span class="n">toret</span> <span class="o">=</span> <span class="n">slope</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error during pha x hgt corr&#39;</span><span class="p">)</span>
                <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">block_id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">block_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
            <span class="n">unwr</span> <span class="o">=</span> <span class="n">unwrap_np</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">tmpdir</span><span class="o">=</span><span class="n">tmpdir</span><span class="p">)</span>
            <span class="c1"># ok, then correlate - and if higher then 0.4, do linear regression to get rad/m</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">hgt</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">unwr</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.4</span><span class="p">:</span>
                        <span class="n">huber</span> <span class="o">=</span> <span class="n">HuberRegressor</span><span class="p">()</span>
                        <span class="n">rc</span> <span class="o">=</span> <span class="n">huber</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">slope</span> <span class="o">=</span> <span class="n">huber</span><span class="o">.</span><span class="n">coef_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1">#slope = np.polyfit(x, y, deg=1)[0]</span>
                        <span class="n">toret</span> <span class="o">=</span> <span class="n">slope</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error during unw x hgt corr&#39;</span><span class="p">)</span>
                <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">toret</span><span class="p">]])</span>


<div class="viewcode-block" id="unwrap_xr"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.unwrap_xr">[docs]</a><span class="k">def</span> <span class="nf">unwrap_xr</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">tmpdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;Quite direct unwrapping of the xarray Dataset of ifg</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        ifg (xarray.Dataset): ifg dataset</span>
<span class="sd">        mask (boolean): whether to use mask</span>
<span class="sd">        defomax (float): DEFOMAX to snaphu</span>
<span class="sd">        tmpdir (string): temp dir</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: ifg dataset now with unwrapped result</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coh</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span>
    <span class="n">cpx</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">cpx</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="n">unw</span> <span class="o">=</span> <span class="n">unwrap_np</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">tmpdir</span><span class="o">=</span><span class="n">tmpdir</span><span class="p">,</span> <span class="n">deltemp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ifg</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">unw</span>
    <span class="k">return</span> <span class="n">ifg</span></div>


<div class="viewcode-block" id="unwrap_np"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.unwrap_np">[docs]</a><span class="k">def</span> <span class="nf">unwrap_np</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">tmpdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span><span class="s1">&#39;tmpunwnp&#39;</span><span class="p">),</span> <span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">conncomp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">deltemp</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;unwraps given numpy array</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        cpx (numpy.ndarray): array of complex interferogram</span>
<span class="sd">        coh (numpy.ndarray): array of coherence</span>
<span class="sd">        defomax (float): DEFOMAX to snaphu</span>
<span class="sd">        tmpdir (string): temp dir</span>
<span class="sd">        mask (boolean): whether to try use binary mask (if exists)</span>
<span class="sd">        conncomp (boolean): whether to export connected components</span>
<span class="sd">        deltemp (boolean): clean temp dir after processing</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: unwrapped array</span>
<span class="sd">        or + numpy.ndarray: connected components (if requested)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">binmask</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;mask.bin&#39;</span><span class="p">)</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">binmask</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">binmask</span><span class="o">=</span><span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">binmask</span><span class="o">=</span><span class="kc">None</span>
    <span class="n">bincoh</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;coh.bin&#39;</span><span class="p">)</span>
    <span class="c1">#binR = os.path.join(tmpdir,&#39;R.bin&#39;)</span>
    <span class="c1">#binI = os.path.join(tmpdir,&#39;I.bin&#39;)</span>
    <span class="n">binCPX</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;cpxifg.bin&#39;</span><span class="p">)</span>
    <span class="n">unwbin</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;unw.bin&#39;</span><span class="p">)</span>
    <span class="c1"># create R, I -&gt; CPX as expected by snaphu</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span> <span class="c1">#.tofile(binR)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span> <span class="c1">#.tofile(binI)</span>
    <span class="c1">#RI2cpx(binR, binI, binCPX)</span>
    <span class="n">RI2cpx</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">binCPX</span><span class="p">)</span>
    <span class="c1">#and coh</span>
    <span class="n">coh</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">bincoh</span><span class="p">)</span>
    <span class="c1"># unwrap it</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">coh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">#with nostdout():</span>
    <span class="n">main_unwrap</span><span class="p">(</span><span class="n">binCPX</span><span class="p">,</span> <span class="n">bincoh</span><span class="p">,</span> <span class="n">maskbin</span> <span class="o">=</span> <span class="n">binmask</span><span class="p">,</span> <span class="n">outunwbin</span> <span class="o">=</span> <span class="n">unwbin</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">,</span> <span class="n">conncomp</span> <span class="o">=</span> <span class="n">conncomp</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">printout</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="c1"># and load it back</span>
    <span class="n">unw1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">unwbin</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">unw1</span> <span class="o">=</span> <span class="n">unw1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">coh</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">conncomp</span><span class="p">:</span>
        <span class="n">ccom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">unwbin</span><span class="o">+</span><span class="s1">&#39;.conncomp&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">ccom</span> <span class="o">=</span> <span class="n">ccom</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">coh</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">deltemp</span><span class="p">:</span>
        <span class="c1">#shutil - delete tmpdir!!!!!</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">conncomp</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unw1</span><span class="p">,</span> <span class="n">ccom</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unw1</span></div>


<span class="k">def</span> <span class="nf">correct_hgt</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">,</span> <span class="n">blocklen</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">dounw</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nonlinear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">minheight</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">mingausscoh</span><span class="o">=</span><span class="mf">0.4</span><span class="p">):</span>
    <span class="c1">#ifg_ml[&#39;hgtcorr&#39;] = ifg_ml[&#39;pha&#39;]</span>
    <span class="n">winsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocklen</span><span class="p">,</span> <span class="n">blocklen</span><span class="p">)</span>
    <span class="n">cohb</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">gauss_coh</span><span class="o">&gt;</span><span class="n">mingausscoh</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">hgt</span><span class="o">&gt;</span><span class="n">minheight</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.001</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="n">winsize</span><span class="p">)</span>
    <span class="c1">#phab = da.from_array(ifg_ml[&#39;pha&#39;].astype(np.float32).fillna(0), chunks=winsize)</span>
    <span class="n">cpxb</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">gauss_coh</span><span class="o">&gt;</span><span class="n">mingausscoh</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">hgt</span><span class="o">&gt;</span><span class="n">minheight</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="n">winsize</span><span class="p">)</span>
    <span class="n">hgtb</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">gauss_coh</span><span class="o">&gt;</span><span class="n">mingausscoh</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">hgt</span><span class="o">&gt;</span><span class="n">minheight</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="n">winsize</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">block_hgtcorr</span><span class="p">,</span> <span class="n">cpxb</span><span class="p">,</span> <span class="n">cohb</span><span class="p">,</span> <span class="n">hgtb</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">,</span> <span class="n">dounw</span> <span class="o">=</span> <span class="n">dounw</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(()),</span> <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1">#with nostdout():</span>
        <span class="n">hgtcorr</span> <span class="o">=</span>  <span class="n">f</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error in computing hgt correlation grid&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span>
    <span class="c1"># make it to xr:</span>
    <span class="n">aaa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
    <span class="n">aaa</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">blocklen</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">blocklen</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">aaa</span><span class="p">[</span><span class="s1">&#39;hgtcorr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aaa</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span>
    <span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">hgtcorr</span>
    <span class="c1">#count means - number of non-nan data..!</span>
    <span class="k">if</span> <span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="ow">and</span> <span class="n">nonlinear</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#interpolate nans using gaussian 2d kernel.. lower stddev, and iterate till all nans are replaced!</span>
        <span class="k">while</span> <span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="c1">#interpolate it to the higher resolution</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">interp_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="c1"># but here edges are again nans!</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">out</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="n">outype</span> <span class="o">=</span> <span class="s1">&#39;xr&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#so this will take only median, to perform only linear heights correction</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">hgtcorr</span><span class="p">)</span>
        <span class="n">outype</span> <span class="o">=</span> <span class="s1">&#39;float&#39;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;all NaNs in hgt corr&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;almost nothing to reduce for hgt&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;the estimate was: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span>
    <span class="c1">#if we got here, means, now it is up to splining it to the full (ml) resolution... but --- at this moment, i will just use average value</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">outype</span>


<div class="viewcode-block" id="export_xr2tif"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.export_xr2tif">[docs]</a><span class="k">def</span> <span class="nf">export_xr2tif</span><span class="p">(</span><span class="n">xrda</span><span class="p">,</span> <span class="n">tif</span><span class="p">,</span> <span class="n">lonlat</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">debug</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dogdal</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exports xarray dataarray to a geotiff</span>
<span class="sd">    </span>
<span class="sd">     Args:</span>
<span class="sd">        xrda (xarray.Dataarray): dataarray to export</span>
<span class="sd">        tif (string): path to output tif file</span>
<span class="sd">        lonlat (boolean): are the dimensions named as lon, lat?</span>
<span class="sd">        debug (boolean): just load it as float32</span>
<span class="sd">        dogdal (boolean): after exporting, perform gdalwarp (fix for potential issues in output geotiff)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">rioxarray</span>
    <span class="c1">#coordsys = xrda.crs.split(&#39;=&#39;)[1]</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">xrda</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">coordsys</span> <span class="o">=</span> <span class="s2">&quot;epsg:4326&quot;</span>
    <span class="k">if</span> <span class="n">lonlat</span><span class="p">:</span>
        <span class="n">xrda</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">set_spatial_dims</span><span class="p">(</span><span class="n">x_dim</span><span class="o">=</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="n">y_dim</span><span class="o">=</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xrda</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">set_spatial_dims</span><span class="p">(</span><span class="n">x_dim</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y_dim</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">xrda</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">write_crs</span><span class="p">(</span><span class="n">coordsys</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dogdal</span><span class="p">:</span>
        <span class="n">xrda</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">to_raster</span><span class="p">(</span><span class="n">tif</span><span class="o">+</span><span class="s1">&#39;tmp.tif&#39;</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="s1">&#39;deflate&#39;</span><span class="p">)</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;gdalwarp -t_srs EPSG:4326 </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tif</span><span class="o">+</span><span class="s1">&#39;tmp.tif&#39;</span><span class="p">,</span> <span class="n">tif</span><span class="p">)</span>
        <span class="n">runcmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">printcmd</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tif</span><span class="o">+</span><span class="s1">&#39;tmp.tif&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xrda</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">to_raster</span><span class="p">(</span><span class="n">tif</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="s1">&#39;deflate&#39;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">create_eqa_file</span><span class="p">(</span><span class="n">eqafile</span><span class="p">,</span><span class="n">wid</span><span class="p">,</span><span class="n">nlines</span><span class="p">,</span><span class="n">cor_lat</span><span class="p">,</span><span class="n">cor_lon</span><span class="p">,</span><span class="n">post_lat</span><span class="p">,</span><span class="n">post_lon</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">eqafile</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;data_format:        REAL*4</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;DEM_hgt_offset:          0.00000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;DEM_scale:               1.00000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;width: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">wid</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;nlines: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nlines</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;corner_lat: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cor_lat</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;  decimal degrees</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;corner_lon: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cor_lon</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;  decimal degrees</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;post_lat: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">post_lat</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; decimal degrees</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;post_lon: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">post_lon</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; decimal degrees</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ellipsoid_name: WGS 84</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ellipsoid_ra:        6378137.000   m</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ellipsoid_reciprocal_flattening:  298.2572236</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;datum_name: WGS 1984</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<div class="viewcode-block" id="get_fft_std"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.get_fft_std">[docs]</a><span class="k">def</span> <span class="nf">get_fft_std</span><span class="p">(</span><span class="n">inarr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    a is numpy array</span>
<span class="sd">    improvised way, not reading much about it... pure intuition (knowing this is only first step to do it right)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">a</span><span class="o">=</span><span class="n">inarr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">fshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">magnitude_spectrum</span> <span class="o">=</span> <span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fshift</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">magnitude_spectrum</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>


<div class="viewcode-block" id="load_tif2xr"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.load_tif2xr">[docs]</a><span class="k">def</span> <span class="nf">load_tif2xr</span><span class="p">(</span><span class="n">tif</span><span class="p">,</span> <span class="n">cliparea_geo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolonlat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;loads geotiff to xarray.DataArray</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tif (string): path to geotiff</span>
<span class="sd">        cliparea_geo (string): use GMT/LiCSBAS string to identify area to clip, in geo-coordinates, as ``&#39;lon1/lon2/lat1/lat2&#39;``</span>
<span class="sd">        tolonlat (boolean): if True, return as lon lat coordinates</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xr.DataArray: loaded contents</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xrpha</span> <span class="o">=</span> <span class="n">rioxarray</span><span class="o">.</span><span class="n">open_rasterio</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
    <span class="n">xrpha</span> <span class="o">=</span> <span class="n">xrpha</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
    <span class="n">xrpha</span> <span class="o">=</span> <span class="n">xrpha</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">cliparea_geo</span><span class="p">:</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="n">cliparea_geo2coords</span><span class="p">(</span><span class="n">cliparea_geo</span><span class="p">)</span>
        <span class="n">xrpha</span> <span class="o">=</span> <span class="n">xrpha</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">tolonlat</span><span class="p">:</span>
        <span class="n">xrpha</span> <span class="o">=</span> <span class="n">xrpha</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;lat&#39;</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">xrpha</span></div>


<div class="viewcode-block" id="cliparea_geo2coords"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.cliparea_geo2coords">[docs]</a><span class="k">def</span> <span class="nf">cliparea_geo2coords</span><span class="p">(</span><span class="n">cliparea_geo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exports the string to min/max clip values</span>

<span class="sd">    Args:</span>
<span class="sd">        cliparea_geo (str): clip boundaries, e.g. &#39;lon1/lon2/lat1/lat2&#39;</span>

<span class="sd">    Returns:</span>
<span class="sd">        float, float, float, float: minclipx, maxclipx, minclipy, maxclipy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
    <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipy</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">minclipy</span> <span class="o">&gt;</span> <span class="n">maxclipy</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (latitude). fixing&#39;</span><span class="p">)</span>
        <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipy</span>
        <span class="n">minclipy</span> <span class="o">=</span> <span class="n">maxclipy</span>
        <span class="n">maxclipy</span> <span class="o">=</span> <span class="n">tmpcl</span>
    <span class="k">if</span> <span class="n">minclipx</span> <span class="o">&gt;</span> <span class="n">maxclipx</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (longitude). fixing&#39;</span><span class="p">)</span>
        <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipx</span>
        <span class="n">minclipx</span> <span class="o">=</span> <span class="n">maxclipx</span>
        <span class="n">maxclipx</span> <span class="o">=</span> <span class="n">tmpcl</span>
    <span class="k">return</span> <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span></div>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def detrend_block(phablock, maxfringes=4):</span>
<span class="sd">    #if isphase:</span>
<span class="sd">    cpx=pha2cpx(phablock)</span>
<span class="sd">    #else:</span>
<span class="sd">    #block=inblock</span>
<span class="sd">    fftt = np.fft.fft2(cpx)</span>
<span class="sd">    fftt = np.abs(fftt)</span>
<span class="sd">    #remove zero line and column - often has too much of zeroes there..</span>
<span class="sd">    fftt[0] = fftt[0]*0</span>
<span class="sd">    fftt = fftt.transpose()</span>
<span class="sd">    fftt[0] = fftt[0]*0</span>
<span class="sd">    fftt = fftt.transpose()</span>
<span class="sd">    numfringesx = np.argmax(np.sum(fftt,axis=0))</span>
<span class="sd">    numfringesy = np.argmax(np.sum(fftt,axis=1))</span>
<span class="sd">    [Y,X]=fftt.shape</span>
<span class="sd">    if numfringesx &gt; X/2:</span>
<span class="sd">        numfringesx = numfringesx - X</span>
<span class="sd">    if numfringesy &gt; Y/2:</span>
<span class="sd">        numfringesy = numfringesy - Y</span>
<span class="sd">    if (abs(numfringesx) &gt; maxfringes) or (abs(numfringesy) &gt; maxfringes):</span>
<span class="sd">        return phablock*0</span>
<span class="sd">    trendx = np.linspace(0,2*np.pi,X) * numfringesx</span>
<span class="sd">    trendy = np.linspace(0,2*np.pi,Y) * numfringesy</span>
<span class="sd">    trendx = np.tile(trendx, (Y,1))</span>
<span class="sd">    trendy = np.tile(trendy, (X,1)).transpose()</span>
<span class="sd">    correction = trendx + trendy</span>
<span class="sd">    return wrap2phase(phablock - correction)</span>
<span class="sd">&#39;&#39;&#39;</span>

<div class="viewcode-block" id="detrend_ifg_xr"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.detrend_ifg_xr">[docs]</a><span class="k">def</span> <span class="nf">detrend_ifg_xr</span><span class="p">(</span><span class="n">xrda</span><span class="p">,</span> <span class="n">isphase</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_correction</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">maxfringes</span> <span class="o">=</span> <span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimates ramp of (wrapped) interferogram and corrects it. Based on Doris InSARMatlab Toolbox</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        xrda (xarray.Dataarray): input data array (interferogram)</span>
<span class="sd">        isphase (boolean): input array is phase (if not, expect complex ifg)</span>
<span class="sd">        return_correction (boolean): returns also the correction</span>
<span class="sd">        maxfringes (int): max amount of fringes to consider as proper correction</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataarray: dataarray of corrected ifg</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isphase</span><span class="p">:</span>
        <span class="c1">#convert to cpx values first</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">cpx</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cpx</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">values</span>
    <span class="n">fftt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span>
    <span class="n">fftt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftt</span><span class="p">)</span>
    <span class="c1">#remove zero line and column - often has too much of zeroes there..</span>
    <span class="n">fftt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fftt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">fftt</span> <span class="o">=</span> <span class="n">fftt</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">fftt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fftt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">fftt</span> <span class="o">=</span> <span class="n">fftt</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">numfringesx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fftt</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">numfringesy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fftt</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">[</span><span class="n">Y</span><span class="p">,</span><span class="n">X</span><span class="p">]</span><span class="o">=</span><span class="n">fftt</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">numfringesx</span> <span class="o">&gt;</span> <span class="n">X</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">numfringesx</span> <span class="o">=</span> <span class="n">numfringesx</span> <span class="o">-</span> <span class="n">X</span>
    <span class="k">if</span> <span class="n">numfringesy</span> <span class="o">&gt;</span> <span class="n">Y</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">numfringesy</span> <span class="o">=</span> <span class="n">numfringesy</span> <span class="o">-</span> <span class="n">Y</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numfringesx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxfringes</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numfringesy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxfringes</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;too many fringes identified, probably wrong. cancelling detrend&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_correction</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">da</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">da</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;detrending by </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1"> fringes in lon/lat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numfringesx</span><span class="p">,</span> <span class="n">numfringesy</span><span class="p">))</span>
    <span class="n">trendx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="n">numfringesx</span>
    <span class="n">trendy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span> <span class="o">*</span> <span class="n">numfringesy</span>
    <span class="n">trendx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">trendx</span><span class="p">,</span> <span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">trendy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">trendy</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">correction</span> <span class="o">=</span> <span class="n">trendx</span> <span class="o">+</span> <span class="n">trendy</span>
    <span class="k">if</span> <span class="n">isphase</span><span class="p">:</span>
        <span class="c1">#was phase, return phase</span>
        <span class="n">da</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">correction</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">cpx_corr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">correction</span><span class="p">)</span>
        <span class="c1">#a trick to apply the correction only to non-nan values.. &#39;other&#39;</span>
        <span class="c1">#da = da.where(xrda.isnull(), other=da.values * np.conjugate(cpx_corr))</span>
        <span class="n">da</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">cpx_corr</span><span class="p">)</span>
        <span class="c1">#da.where(xrcpx.isnull()) = 0</span>
    <span class="k">if</span> <span class="n">return_correction</span><span class="p">:</span>
        <span class="n">corrda</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">corrda</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">correction</span>
        <span class="k">return</span> <span class="n">da</span><span class="p">,</span> <span class="n">corrda</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">da</span></div>

    
<div class="viewcode-block" id="filter_ifg_ml"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.filter_ifg_ml">[docs]</a><span class="k">def</span> <span class="nf">filter_ifg_ml</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">calc_coh_from_delta</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">trunc</span> <span class="o">=</span> <span class="mi">4</span><span class="p">):</span> <span class="c1">#, sigma = 1, trunc = 2):  #, rotate = False):</span>
    <span class="sd">&quot;&quot;&quot;Normalises interferogram and performs Gaussian filtering (expects proper structure of the ifg dataset).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        ifg_ml (xarray.Dataset): input xr dataset (interferogram) - must contain ``pha`` data_var</span>
<span class="sd">        calc_coh_from_delta (boolean): will calculate local variance and use to improve ``gauss_coh`` measure</span>
<span class="sd">        radius (float): length of the Gaussian window in metres</span>
<span class="sd">        trunc (int): truncation of std dev for Gaussian window, by default trunc=4 and this is recommended for the shape</span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: dataset that includes filtering results (as ``gauss_pha``, ``gauss_coh``, ``gauss_cpx``)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get sigma, trunc from radius [m], converted to pixels using resolution</span>
    <span class="n">resolution</span> <span class="o">=</span> <span class="n">get_resolution</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">in_m</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">radius_px</span> <span class="o">=</span> <span class="n">radius</span><span class="o">/</span><span class="n">resolution</span>
    <span class="c1">#width_filter = 2*int( trunc*sigma + 0.5) +1  # definition within scipy ndimage filters.py - gaussian_filter1d</span>
    <span class="c1">#width_filter = 2*radius_px</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="n">radius_px</span> <span class="o">-</span> <span class="mf">1.5</span><span class="p">)</span><span class="o">/</span><span class="n">trunc</span>
    <span class="c1">#normalise mag</span>
    <span class="n">tempar_mag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;cpx&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filter using gauss filter&#39;</span><span class="p">)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_cpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_cpx_gauss</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">trunc</span> <span class="o">=</span> <span class="n">trunc</span><span class="p">)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_cpx</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="c1">#use magnitude after filtering as coherence</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="c1"># that is great but has problems at maxima of cos or sin</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_cpx</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">calc_coh_from_delta</span><span class="p">:</span>
        <span class="c1"># if using the coh from the phase residuals (based on variance), it </span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_pha&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">])))</span>
        <span class="c1">#aaa = coh_from_phadiff(delta, winsize=5)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calculating coh from phase diff&#39;</span><span class="p">)</span>
        <span class="n">phacoh</span> <span class="o">=</span> <span class="n">coh_from_phadiff</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># this should be much better:</span>
        <span class="c1">#ifg_ml[&#39;gauss_coh&#39;].values = 1-np.abs(delta)/np.pi</span>
        <span class="c1">#but it is not actually. so i am using max of gauss_coh and phacoh:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">phacoh</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ifg_ml</span></div>


<span class="c1"># implementation of the Goldstein filter here:</span>
<span class="k">def</span> <span class="nf">goldstein_AH</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">kernelsigma</span><span class="o">=</span><span class="mf">0.75</span><span class="p">):</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="n">kernelsigma</span><span class="p">)</span> <span class="c1">#sigma 1 gives 9x9 gaussian kernel, 0.75 gives 7x7 kernel</span>
    <span class="c1"># just in case we use phase directly, should be in cpx already...</span>
    <span class="c1">#if not(block.dtype.type == np.complex128 or block.dtype.type == np.complex64):</span>
    <span class="c1">#    block=pha2cpx(block)</span>
    <span class="n">cpx_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
    <span class="n">H</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cpx_fft</span><span class="p">)</span>
    <span class="n">H</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">convolve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="n">kernel</span><span class="p">))</span>
    <span class="n">meanH</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">meanH</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="o">/</span><span class="n">meanH</span>   <span class="c1"># ok but it seems there is no real effect on this!</span>
    <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="o">**</span><span class="n">alpha</span>
    <span class="n">cpxfilt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">cpx_fft</span><span class="o">*</span><span class="n">H</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cpxfilt</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def goldstein_AHML(block, alpha=0.8, kernelsigma=0.75,mask_nyquist=False):</span>
<span class="sd">    kernel = Gaussian2DKernel(x_stddev=kernelsigma) #sigma 1 gives 9x9 gaussian kernel</span>
<span class="sd">    cpx_fft = np.fft.fft2(block)</span>
<span class="sd">    H=np.abs(cpx_fft)</span>
<span class="sd">    H=convolve(np.fft.fftshift(H), kernel)</span>
<span class="sd">    if mask_nyquist:</span>
<span class="sd">        mask=nyquistmask(block)</span>
<span class="sd">        H=H*mask</span>
<span class="sd">    H=np.fft.ifftshift(H)</span>
<span class="sd">    meanH=np.median(H)</span>
<span class="sd">    if meanH != 0:</span>
<span class="sd">        H=H/meanH</span>
<span class="sd">    H=H**alpha</span>
<span class="sd">    cpxfilt=np.fft.ifft2(cpx_fft*H)</span>
<span class="sd">    return cpxfilt</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="k">def</span> <span class="nf">goldstein_AHML</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">kernelsigma</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">mask_nyquist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">returnphadiff</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">cpx_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
    <span class="c1"># get 2d spectral magnitude of the block</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cpx_fft</span><span class="p">)</span>
    <span class="c1">#firstfreq = H[0][0]   # useful to get avg coh if /block.shape</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="c1"># mask frequencies above Nyquist frequency</span>
    <span class="k">if</span> <span class="n">mask_nyquist</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">nyquistmask</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">*</span><span class="n">mask</span>
    <span class="c1"># phase ramps using masked H (i.e. low pass)</span>
    <span class="c1"># cpxm=np.fft.ifft2(cpx_fft*np.fft.fftshift(Hm))</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    if returnphadiff: </span>
<span class="sd">        # this is based on phase difference after convolution within Nyquist freq range - needs improvement, but it works</span>
<span class="sd">        phadiff = wrap2phase(np.angle(block) - np.angle(np.fft.ifft2(cpx_fft * np.fft.ifftshift(H))))  # C[0])</span>
<span class="sd">        #cc = 1 - coh_from_phadiff(phadiff, 3)</span>
<span class="sd">        #cpxfilt = magpha2RI_array(cc, np.angle(cpxfilt))</span>
<span class="sd">        return phadiff</span>
<span class="sd">    # perform cross-correlation of the original cpx block with the low-pass result</span>
<span class="sd">    cc = cpx_fft * np.conj(np.fft.fftshift(Hm))</span>
<span class="sd">    cc = cpx_fft * np.conj(np.fft.fftshift(H))</span>
<span class="sd">    cc = np.abs(np.fft.ifft2(cc))  # now i need to somehow normalise cc - not solved yet</span>
<span class="sd">    #</span>
<span class="sd">    # horrible solution, but maybe works?</span>
<span class="sd">    gh = wrap2phase(np.angle(block) - np.angle(np.fft.ifft2(cpx_fft * np.fft.ifftshift(Hm))))  # C[0])</span>
<span class="sd">    bgr = 1 - coh_from_phadiff(gh, 3)</span>
<span class="sd">    # avgcc=np.max(Hm)/32/32</span>
<span class="sd">    # avgcc=firstfreq/32/32</span>
<span class="sd">    # cc=cc/32/32</span>
<span class="sd">    # cc=10*np.log10(cc)*avgcc/32/32</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># only now convolve with Gaussian kernel to filter (not masking here, although we might consider it)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="n">kernelsigma</span><span class="p">)</span>  <span class="c1"># sigma 1 gives 9x9 gaussian kernel</span>
    <span class="c1">#kernel = Gaussian2DKernel(x_stddev=kernelsigma, x_size = H.shape[1], y_size = H.shape[0] )</span>
    <span class="c1">#H = H * kernel.array</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>   <span class="c1"># but correctly i should only multiply with the gauss window, see above</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="c1"># centering not needed? but maybe yes for mag/specmag</span>
    <span class="c1">#if meanH:</span>
    <span class="n">meanH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">meanH</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">/</span> <span class="n">meanH</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">**</span> <span class="n">alpha</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    # try maxx it</span>
<span class="sd">    mask = nyquistmask(block)</span>
<span class="sd">    Hm = np.fft.ifftshift(H)*mask  # but here i am masking from centre, not from freq that appears most (max H)...</span>
<span class="sd">    noisesum = H.sum() - Hm.sum() + 0.001</span>
<span class="sd">    snr = Hm.sum()/noisesum</span>
<span class="sd">    #nsr = noisesum/Hm.sum()</span>
<span class="sd">    maxH = np.max(Hm)</span>
<span class="sd">    #maxH = np.max(H)</span>
<span class="sd">    #ratioH = block.shape[0]*block.shape[1]/maxH</span>
<span class="sd">    ratioH = 1/maxH</span>
<span class="sd">    #x = 1024/maxH  * valH</span>
<span class="sd">    H = H* ratioH *snr # / 1024)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">nyquistmask</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
    <span class="n">Hm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="o">*</span><span class="n">mask</span>
    <span class="n">maxH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Hm</span><span class="p">)</span>
    <span class="n">ratioH</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">maxH</span>
    <span class="n">Hr</span> <span class="o">=</span> <span class="n">H</span><span class="o">*</span> <span class="n">ratioH</span> <span class="c1"># not bad try! but then some real dark areas as too bright then</span>
    
    <span class="n">noisesum</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">Hm</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.001</span>
    <span class="c1">#snr = Hm.sum()/noisesum</span>
    <span class="n">nsr</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">noisesum</span><span class="o">/</span><span class="n">H</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="c1">#Hs = H *snr</span>
    <span class="n">Hn</span> <span class="o">=</span> <span class="n">H</span> <span class="o">*</span><span class="n">nsr</span>
    <span class="n">Hb</span> <span class="o">=</span> <span class="n">Hn</span> <span class="o">*</span> <span class="n">Hr</span> <span class="c1">#s * H</span>
    <span class="n">H</span><span class="o">=</span><span class="n">Hr</span>
    
    <span class="n">cpxfilt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">cpx_fft</span> <span class="o">*</span> <span class="n">H</span><span class="p">)</span>
    <span class="n">cpxfiltbad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">cpx_fft</span> <span class="o">*</span> <span class="n">Hb</span><span class="p">)</span>
    <span class="c1">#cpxfilt = magpha2RI_array(np.abs(cpxfilt)*(1-nsr), np.angle(cpxfilt))</span>
    <span class="n">cpxfilt</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cpxfilt</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cpxfiltbad</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cpxfilt</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">returnphadiff</span><span class="p">:</span>  <span class="c1"># Oct 28, 2022: using the goldstein-filtered ck to get the phadiff (for coh measure, later)</span>
        <span class="c1"># this is based on phase difference after convolution within Nyquist freq range - needs improvement, but it works</span>
        <span class="c1"># recalc now, from the filtered version</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">nyquistmask</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
        <span class="n">cpx_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">pha2cpx</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cpxfilt</span><span class="p">)))</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cpx_fft</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span> <span class="o">*</span> <span class="n">mask</span>
        <span class="n">cpxnyquistfilt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">cpx_fft</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">H</span><span class="p">))</span>
        <span class="c1"># nah the phase difference can be done easier, just.. for now this:</span>
        <span class="c1">#phadiff = wrap2phase(np.angle(block) - np.angle(cpxnyquistfilt))  # C[0])</span>
        <span class="n">phadiff</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cpxfilt</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cpxnyquistfilt</span><span class="p">))</span>  <span class="c1"># C[0])</span>
        <span class="c1">#cc = 1 - coh_from_phadiff(phadiff, 3) # will calc this only later, to avoid ovlps aliasing</span>
        <span class="n">cpxfilt</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">phadiff</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cpxfilt</span><span class="p">))</span>  <span class="c1"># can mag be negative? i don&#39;t think so</span>
        <span class="c1">#return phadiff</span>
    <span class="c1"># cc=np.abs(cpxfilt)</span>
    <span class="c1"># cc = cpx_fft*np.conj(np.fft.fftshift(Hm))</span>
    <span class="c1"># cc = np.abs(np.fft.ifft2(cc))</span>
    <span class="c1"># now put cc instead of the filtered spectral magnitude</span>
    <span class="k">return</span> <span class="n">cpxfilt</span>


<div class="viewcode-block" id="goldstein_filter_xr"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.goldstein_filter_xr">[docs]</a><span class="k">def</span> <span class="nf">goldstein_filter_xr</span><span class="p">(</span><span class="n">inpha</span><span class="p">,</span> <span class="n">blocklen</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">ovlpx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">returncoh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">mask_nyquist</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># ovlwin=8, nproc=1):</span>
    <span class="sd">&quot;&quot;&quot;Goldstein filtering of phase</span>

<span class="sd">    Args:</span>
<span class="sd">        inpha (xr.DataArray): array of phase (for now, the script will create cpx from phase)</span>
<span class="sd">        blocklen (int): size of rectangular window in pixels</span>
<span class="sd">        alpha (float): Goldstein alpha parameter</span>
<span class="sd">        ovlpx (int): how many pixels should overlap the window</span>
<span class="sd">        nproc (int): number of processors to be used by dask</span>
<span class="sd">        returncoh (boolean): return coherence instead of the spectral magnitude</span>

<span class="sd">    Returns:</span>
<span class="sd">        xr.DataArray,xr.DataArray: filtered phase, magnitude (try np.log to use for masking)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ovlpx</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ovlpx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">blocklen</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># does it make sense? gamma recommends /8 but this might be too much?</span>
    <span class="c1"># dask works by adding extra pixels around the block window. thus calculate the central window here:</span>
    <span class="n">blocklen</span> <span class="o">=</span> <span class="n">blocklen</span> <span class="o">-</span> <span class="n">ovlpx</span>
    <span class="n">outpha</span> <span class="o">=</span> <span class="n">inpha</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">incpx</span> <span class="o">=</span> <span class="n">pha2cpx</span><span class="p">(</span><span class="n">inpha</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">winsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocklen</span><span class="o">-</span><span class="n">ovlpx</span><span class="p">,</span> <span class="n">blocklen</span><span class="o">-</span><span class="n">ovlpx</span><span class="p">)</span>
    <span class="n">incpxb</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">incpx</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="n">winsize</span><span class="p">)</span>
    <span class="c1"># f=cpxb.map_overlap(goldstein_AH, alpha=alpha, depth=ovlpx, boundary=&#39;reflect&#39;, meta=np.array((), dtype=np.complex128), chunks = (1,1))</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">incpxb</span><span class="o">.</span><span class="n">map_overlap</span><span class="p">(</span><span class="n">goldstein_AHML</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">mask_nyquist</span><span class="o">=</span><span class="n">mask_nyquist</span><span class="p">,</span> <span class="n">returnphadiff</span> <span class="o">=</span> <span class="n">returncoh</span><span class="p">,</span>
                         <span class="n">depth</span><span class="o">=</span><span class="n">ovlpx</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
                         <span class="n">meta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">cpxb</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">num_workers</span><span class="o">=</span><span class="n">nproc</span><span class="p">)</span>
    <span class="n">outpha</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cpxb</span><span class="p">)</span>
    <span class="n">outmag</span> <span class="o">=</span> <span class="n">outpha</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">outmag</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cpxb</span><span class="p">)</span>
    <span class="n">outmag</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">outmag</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># just in case..</span>
    <span class="k">if</span> <span class="n">returncoh</span><span class="p">:</span>
        <span class="c1"># obsolete, will probably remove it</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;better use specmag - we will probably remove the returncoh function&#39;</span><span class="p">)</span>
        <span class="n">outmag</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">coh_from_phadiff</span><span class="p">(</span><span class="n">outmag</span><span class="o">.</span><span class="n">values</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">phadiff</span> <span class="o">=</span> <span class="n">outpha</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">phadiff</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">incpx</span><span class="p">)</span> <span class="o">-</span> <span class="n">outpha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">phadiff</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">coh_from_phadiff</span><span class="p">(</span><span class="n">phadiff</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">phadiff</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phadiff</span><span class="o">.</span><span class="n">values</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">outmag</span> <span class="o">=</span> <span class="n">phadiff</span> <span class="o">*</span> <span class="n">outmag</span>
    <span class="k">return</span> <span class="n">outpha</span><span class="p">,</span> <span class="n">outmag</span></div>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def goldstein_AHML(block, alpha=0.8, kernelsigma=0.75, mask_nyquist=False, returnphadiff=True):</span>
<span class="sd">    cpx_fft = np.fft.fft2(block)</span>
<span class="sd">    # get 2d spectral magnitude of the block</span>
<span class="sd">    H = np.abs(cpx_fft)</span>
<span class="sd">    #firstfreq = H[0][0]   # useful to get avg coh if /block.shape</span>
<span class="sd">    H = np.fft.fftshift(H)</span>
<span class="sd">    # mask frequencies above Nyquist frequency</span>
<span class="sd">    if mask_nyquist:</span>
<span class="sd">        mask = nyquistmask(block)</span>
<span class="sd">        H = H*mask</span>
<span class="sd">    # phase ramps using masked H (i.e. low pass)</span>
<span class="sd">    # cpxm=np.fft.ifft2(cpx_fft*np.fft.fftshift(Hm))</span>
<span class="sd">    </span>
<span class="sd">    if returnphadiff: </span>
<span class="sd">        # this is based on phase difference after convolution within Nyquist freq range - needs improvement, but it works</span>
<span class="sd">        phadiff = wrap2phase(np.angle(block) - np.angle(np.fft.ifft2(cpx_fft * np.fft.ifftshift(H))))  # C[0])</span>
<span class="sd">        #cc = 1 - coh_from_phadiff(phadiff, 3)</span>
<span class="sd">        #cpxfilt = magpha2RI_array(cc, np.angle(cpxfilt))</span>
<span class="sd">        return phadiff</span>
<span class="sd">    # perform cross-correlation of the original cpx block with the low-pass result</span>
<span class="sd">    cc = cpx_fft * np.conj(np.fft.fftshift(Hm))</span>
<span class="sd">    cc = cpx_fft * np.conj(np.fft.fftshift(H))</span>
<span class="sd">    cc = np.abs(np.fft.ifft2(cc))  # now i need to somehow normalise cc - not solved yet</span>
<span class="sd">    #</span>
<span class="sd">    # horrible solution, but maybe works?</span>
<span class="sd">    gh = wrap2phase(np.angle(block) - np.angle(np.fft.ifft2(cpx_fft * np.fft.ifftshift(Hm))))  # C[0])</span>
<span class="sd">    bgr = 1 - coh_from_phadiff(gh, 3)</span>
<span class="sd">    # avgcc=np.max(Hm)/32/32</span>
<span class="sd">    # avgcc=firstfreq/32/32</span>
<span class="sd">    # cc=cc/32/32</span>
<span class="sd">    # cc=10*np.log10(cc)*avgcc/32/32</span>
<span class="sd">    </span>
<span class="sd">    # only now convolve with Gaussian kernel to filter (not masking here, although we might consider it)</span>
<span class="sd">    kernel = Gaussian2DKernel(x_stddev=kernelsigma)  # sigma 1 gives 9x9 gaussian kernel</span>
<span class="sd">    H = convolve(H, kernel)</span>
<span class="sd">    H = np.fft.ifftshift(H)</span>
<span class="sd">    # centering not needed? but maybe yes for mag/specmag</span>
<span class="sd">    #if meanH:</span>
<span class="sd">    meanH = np.median(H)</span>
<span class="sd">    if meanH != 0:</span>
<span class="sd">        H = H / meanH</span>
<span class="sd">    H = H ** alpha</span>
<span class="sd">    cpxfilt = np.fft.ifft2(cpx_fft * H)</span>
<span class="sd">    if returnphadiff:  # Oct 28, 2022: using the goldstein-filtered block to get the phadiff (for coh measure, later)</span>
<span class="sd">        # this is based on phase difference after convolution within Nyquist freq range - needs improvement, but it works</span>
<span class="sd">        # recalc now, from the filtered version</span>
<span class="sd">        mask = nyquistmask(block)</span>
<span class="sd">        cpx_fft = np.fft.fft2(pha2cpx(np.angle(cpxfilt)))</span>
<span class="sd">        H = np.abs(cpx_fft)</span>
<span class="sd">        H = np.fft.fftshift(H)</span>
<span class="sd">        H = H * mask</span>
<span class="sd">        cpxnyquistfilt = np.fft.ifft2(cpx_fft * np.fft.ifftshift(H))</span>
<span class="sd">        # nah the phase difference can be done easier, just.. for now this:</span>
<span class="sd">        #phadiff = wrap2phase(np.angle(block) - np.angle(cpxnyquistfilt))  # C[0])</span>
<span class="sd">        phadiff = wrap2phase(np.angle(cpxfilt) - np.angle(cpxnyquistfilt))  # C[0])</span>
<span class="sd">        #cc = 1 - coh_from_phadiff(phadiff, 3) # will calc this only later, to avoid ovlps aliasing</span>
<span class="sd">        cpxfilt = magpha2RI_array(phadiff+np.pi, np.angle(cpxfilt))  # can mag be negative? i don&#39;t think so</span>
<span class="sd">        #return phadiff</span>
<span class="sd">    # cc=np.abs(cpxfilt)</span>
<span class="sd">    # cc = cpx_fft*np.conj(np.fft.fftshift(Hm))</span>
<span class="sd">    # cc = np.abs(np.fft.ifft2(cc))</span>
<span class="sd">    # now put cc instead of the filtered spectral magnitude</span>
<span class="sd">    return cpxfilt</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def goldstein_filter_xr(inpha, blocklen=16, alpha=0.8, ovlpx=None, nproc=1, returncoh=True,</span>
<span class="sd">                        mask_nyquist=False):  # ovlwin=8, nproc=1):</span>
<span class="sd">    &quot;&quot;&quot;Goldstein filtering of phase</span>

<span class="sd">    Args:</span>
<span class="sd">        inpha (xr.DataArray): array of phase (for now, the script will create cpx from phase)</span>
<span class="sd">        blocklen (int): size of rectangular window in pixels</span>
<span class="sd">        alpha (float): Goldstein alpha parameter</span>
<span class="sd">        ovlpx (int): how many pixels should overlap the window</span>
<span class="sd">        nproc (int): number of processors to be used by dask</span>
<span class="sd">        returncoh (boolean): return coherence instead of the spectral magnitude</span>

<span class="sd">    Returns:</span>
<span class="sd">        xr.DataArray,xr.DataArray: filtered phase, magnitude (try np.log to use for masking)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    if ovlpx == None:</span>
<span class="sd">        ovlpx = int(blocklen / 4)  # does it make sense? gamma recommends /8 but this might be too much?</span>
<span class="sd">    # dask works by adding extra pixels around the block window. thus calculate the central window here:</span>
<span class="sd">    blocklen = blocklen - ovlpx</span>
<span class="sd">    outpha = inpha.copy()</span>
<span class="sd">    incpx = pha2cpx(inpha.fillna(0).values)</span>
<span class="sd">    winsize = (blocklen, blocklen)</span>
<span class="sd">    incpxb = da.from_array(incpx, chunks=winsize)</span>
<span class="sd">    # f=cpxb.map_overlap(goldstein_AH, alpha=alpha, depth=ovlpx, boundary=&#39;reflect&#39;, meta=np.array((), dtype=np.complex128), chunks = (1,1))</span>
<span class="sd">    f = incpxb.map_overlap(goldstein_AHML, alpha=alpha, mask_nyquist=mask_nyquist, returnphadiff = returncoh,</span>
<span class="sd">                         depth=ovlpx, boundary=&#39;reflect&#39;,</span>
<span class="sd">                         meta=np.array((), dtype=np.complex128), chunks=(1, 1))</span>
<span class="sd">    cpxb = f.compute(num_workers=nproc)</span>
<span class="sd">    outpha.values = np.angle(cpxb)</span>
<span class="sd">    outmag = outpha.copy()</span>
<span class="sd">    outmag.values = np.abs(cpxb)</span>
<span class="sd">    if returncoh:</span>
<span class="sd">        outmag.values = coh_from_phadiff(outmag.values-np.pi, 3)</span>
<span class="sd">        </span>
<span class="sd">        # calculating the fake coh from freqs below nyquist, proper way (although longer - need to improve it:</span>
<span class="sd">        f = incpxb.map_overlap(goldstein_AHML, alpha=alpha, mask_nyquist=True, returnphadiff=True,</span>
<span class="sd">                             depth=ovlpx, boundary=&#39;reflect&#39;,</span>
<span class="sd">                             meta=np.array((), dtype=np.float32), chunks=(1, 1))</span>
<span class="sd">        phadiff = f.compute(num_workers=nproc)</span>
<span class="sd">        outmag.values = 1 - coh_from_phadiff(phadiff, 3)</span>
<span class="sd">        </span>
<span class="sd">        #outmag[outmag==1]=0</span>
<span class="sd">    return outpha, outmag</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">def goldstein_filter_xr(inpha, blocklen=16, alpha=0.8, ovlpx=None, nproc=1, returncoh=True, mask_nyquist=False): #ovlwin=8, nproc=1):</span>
<span class="sd">    &quot;&quot;&quot;Goldstein filtering of phase</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        inpha (xr.DataArray): array of phase (for now, the script will create cpx from phase)</span>
<span class="sd">        blocklen (int): size of rectangular window in pixels</span>
<span class="sd">        alpha (float): Goldstein alpha parameter</span>
<span class="sd">        ovlpx (int): how many pixels should overlap the window</span>
<span class="sd">        nproc (int): number of processors to be used by dask</span>
<span class="sd">        returncoh (boolean): return coherence instead of the spectral magnitude</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        xr.DataArray,xr.DataArray: filtered phase, magnitude (try np.log to use for masking)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="sd">    if ovlpx==None:</span>
<span class="sd">        ovlpx=int(blocklen/4) # does it make sense? gamma recommends /8 but this might be too much?</span>
<span class="sd">    # dask works by adding extra pixels around the block window. thus calculate the central window here:</span>
<span class="sd">    blocklen=blocklen-ovlpx</span>
<span class="sd">    outpha=inpha.copy()</span>
<span class="sd">    incpx=pha2cpx(inpha.fillna(0).values)</span>
<span class="sd">    winsize = (blocklen, blocklen)</span>
<span class="sd">    cpxb = da.from_array(incpx, chunks=winsize)</span>
<span class="sd">    # f=cpxb.map_overlap(goldstein_AH, alpha=alpha, depth=ovlpx, boundary=&#39;reflect&#39;, meta=np.array((), dtype=np.complex128), chunks = (1,1))</span>
<span class="sd">    f = cpxb.map_overlap(goldstein_AHML, alpha=alpha, mask_nyquist=mask_nyquist, depth=ovlpx, boundary=&#39;reflect&#39;,</span>
<span class="sd">                         meta=np.array((), dtype=np.complex128), chunks=(1, 1))</span>
<span class="sd">    cpxb=f.compute(num_workers=nproc)</span>
<span class="sd">    outpha.values=np.angle(cpxb)</span>
<span class="sd">    outmag=outpha.copy()</span>
<span class="sd">    if returncoh:</span>
<span class="sd">        phadiff = wrap2phase(outpha-inpha)</span>
<span class="sd">        outmag.values = coh_from_phadiff(phadiff)</span>
<span class="sd">    else:</span>
<span class="sd">        outmag.values=np.abs(cpxb)</span>
<span class="sd">    return outpha,outmag</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span> <span class="nf">unit_circle</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">A</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dists</span><span class="o">&lt;</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1">#return (np.abs(dists-r)&lt;0.5).astype(int) # outline only</span>


<span class="k">def</span> <span class="nf">nyquistmask</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
    <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1">#should be square</span>
    <span class="n">nyquistlen</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">#+ extrapx</span>
    <span class="n">circle</span><span class="o">=</span><span class="n">unit_circle</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nyquistlen</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mf">0.5</span><span class="p">))</span> <span class="c1">#will contain +1 px for zero</span>
    <span class="n">i</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">circle</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">j</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">circle</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">circle</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">j</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="n">circle</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">circle</span>
    <span class="k">return</span> <span class="n">mask</span>


<div class="viewcode-block" id="pha2cpx"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.pha2cpx">[docs]</a><span class="k">def</span> <span class="nf">pha2cpx</span><span class="p">(</span><span class="n">pha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates normalised cpx interferogram from phase</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">pha</span><span class="p">)</span></div>


<div class="viewcode-block" id="wrap2phase"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.wrap2phase">[docs]</a><span class="k">def</span> <span class="nf">wrap2phase</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wraps array to -pi,pi (or 0,2pi?)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">A</span><span class="p">))</span></div>


<div class="viewcode-block" id="make_avg_amp"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_avg_amp">[docs]</a><span class="k">def</span> <span class="nf">make_avg_amp</span><span class="p">(</span><span class="n">mlitiflist</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates average amplitude from list of MLI tiffs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avgamp</span> <span class="o">=</span> <span class="n">hgtxr</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">nopixels</span> <span class="o">=</span> <span class="n">avgamp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ampf</span> <span class="ow">in</span> <span class="n">mlitiflist</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">read_geotiff</span><span class="p">(</span><span class="n">ampf</span><span class="p">)</span> <span class="c1">#/ 255</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error reading &#39;</span><span class="o">+</span><span class="n">ampf</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">amp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">amp</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nopixels</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">amp</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">avgamp</span> <span class="o">=</span> <span class="n">avgamp</span> <span class="o">+</span> <span class="n">amp</span>
    <span class="n">avgamp</span> <span class="o">=</span> <span class="n">avgamp</span><span class="o">/</span><span class="n">nopixels</span>
    <span class="k">return</span> <span class="n">avgamp</span></div>


<div class="viewcode-block" id="make_std_amp"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_std_amp">[docs]</a><span class="k">def</span> <span class="nf">make_std_amp</span><span class="p">(</span><span class="n">mlitiflist</span><span class="p">,</span> <span class="n">avgamp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates standard deviation of amplitude from list of MLI tiffs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">avgvar</span> <span class="o">=</span> <span class="n">avgamp</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">nopixels</span> <span class="o">=</span> <span class="n">avgvar</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ampf</span> <span class="ow">in</span> <span class="n">mlitiflist</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">read_geotiff</span><span class="p">(</span><span class="n">ampf</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error reading &#39;</span><span class="o">+</span><span class="n">ampf</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">amp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">amp</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nopixels</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">amp</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">avgvar</span> <span class="o">=</span> <span class="n">avgvar</span> <span class="o">+</span> <span class="p">(</span><span class="n">amp</span> <span class="o">-</span> <span class="n">avgamp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># correct for ddof</span>
    <span class="n">sumpx</span> <span class="o">=</span> <span class="n">nopixels</span> <span class="o">-</span> <span class="n">ddof</span>
    <span class="c1">#sumpx[sumpx&lt;1] = np.nan</span>
    <span class="n">sumpx</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">sumpx</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">avgstd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">avgvar</span><span class="o">/</span><span class="n">sumpx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">avgstd</span></div>


<div class="viewcode-block" id="make_avg_coh"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_avg_coh">[docs]</a><span class="k">def</span> <span class="nf">make_avg_coh</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates average coherence from &#39;group&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avgcoh</span> <span class="o">=</span> <span class="n">hgtxr</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">nopixels</span> <span class="o">=</span> <span class="n">avgcoh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cohf</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;cohf&#39;</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">read_geotiff</span><span class="p">(</span><span class="n">cohf</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error reading &#39;</span><span class="o">+</span><span class="n">cohf</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">coh</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coh</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nopixels</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">coh</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">avgcoh</span> <span class="o">=</span> <span class="n">avgcoh</span> <span class="o">+</span> <span class="n">coh</span>
    <span class="n">avgcoh</span> <span class="o">=</span> <span class="n">avgcoh</span><span class="o">/</span><span class="n">nopixels</span>
    <span class="k">return</span> <span class="n">avgcoh</span></div>


<div class="viewcode-block" id="make_std_coh"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_std_coh">[docs]</a><span class="k">def</span> <span class="nf">make_std_coh</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">avgcoh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates standard deviation of coherence from &#39;group&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">avgvar</span> <span class="o">=</span> <span class="n">avgcoh</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">nopixels</span> <span class="o">=</span> <span class="n">avgvar</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cohf</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;cohf&#39;</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">read_geotiff</span><span class="p">(</span><span class="n">cohf</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error reading &#39;</span><span class="o">+</span><span class="n">cohf</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">coh</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coh</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nopixels</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">coh</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">avgvar</span> <span class="o">=</span> <span class="n">avgvar</span> <span class="o">+</span> <span class="p">(</span><span class="n">coh</span> <span class="o">-</span> <span class="n">avgcoh</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># correct for ddof</span>
    <span class="n">sumpx</span> <span class="o">=</span> <span class="n">nopixels</span> <span class="o">-</span> <span class="n">ddof</span>
    <span class="c1">#sumpx[sumpx&lt;1] = np.nan</span>
    <span class="n">sumpx</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">sumpx</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">avgstd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">avgvar</span><span class="o">/</span><span class="n">sumpx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">avgstd</span></div>


<span class="k">def</span> <span class="nf">get_date_matrix</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
    <span class="n">date_matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">])</span>
    <span class="n">date_matrix</span><span class="p">[</span><span class="s1">&#39;date1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">date_matrix</span><span class="o">.</span><span class="n">pair</span><span class="o">.</span><span class="n">str</span><span class="p">[:</span><span class="mi">8</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">date_matrix</span><span class="p">[</span><span class="s1">&#39;date2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">date_matrix</span><span class="o">.</span><span class="n">pair</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">9</span><span class="p">:],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">date_matrix</span><span class="p">[</span><span class="s1">&#39;btemp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">date_matrix</span><span class="o">.</span><span class="n">date2</span> <span class="o">-</span> <span class="n">date_matrix</span><span class="o">.</span><span class="n">date1</span>
    <span class="n">date_matrix</span> <span class="o">=</span> <span class="n">date_matrix</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;pair&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">date_matrix</span>


<div class="viewcode-block" id="build_amp_avg_std"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.build_amp_avg_std">[docs]</a><span class="k">def</span> <span class="nf">build_amp_avg_std</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">return_ampstab</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Builds amplitude stability map (or just avg/std amplitude) of a frame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">framecare</span> <span class="k">as</span> <span class="nn">fc</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;framecare not loaded - amplitude stability will not work&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">track</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>
    <span class="n">epochsdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">],</span> <span class="n">track</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="s1">&#39;epochs&#39;</span><span class="p">)</span>
    <span class="n">hgtfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">],</span> <span class="n">track</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="s1">&#39;metadata&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.hgt.tif&#39;</span><span class="p">)</span>
    <span class="n">hgtxr</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_rasterio</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">))</span>
    <span class="n">hgtxr</span> <span class="o">=</span> <span class="n">hgtxr</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
    <span class="n">mlitiflist</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">get_epochs</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">return_mli_tifs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;generating amp average&#39;</span><span class="p">)</span>
    <span class="n">ampavg</span> <span class="o">=</span> <span class="n">make_avg_amp</span><span class="p">(</span><span class="n">mlitiflist</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;generating amp std&#39;</span><span class="p">)</span>
    <span class="n">ampstd</span> <span class="o">=</span> <span class="n">make_std_amp</span><span class="p">(</span><span class="n">mlitiflist</span><span class="p">,</span> <span class="n">ampavg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_ampstab</span><span class="p">:</span>
        <span class="n">ampstab</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ampstd</span><span class="o">/</span><span class="n">ampavg</span>
        <span class="n">ampstab</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ampstab</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
        <span class="k">return</span> <span class="n">ampstab</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ampavg</span><span class="p">,</span> <span class="n">ampstd</span></div>


<div class="viewcode-block" id="build_coh_avg_std"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.build_coh_avg_std">[docs]</a><span class="k">def</span> <span class="nf">build_coh_avg_std</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">ifgdir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">days</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">monthly</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">outnopx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">do_std</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">do_tif</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Builds coherence stability map (or just avg/std coherence) of a frame</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        frame (str):  frame id to generate coherence map(s) from</span>
<span class="sd">        ifgdir (str): path to directory containing the input interferograms. By default None = set source directory from LiCSAR_public</span>
<span class="sd">        days (str or int): for what Btemp to generate mean coherence map. By default &#39;all&#39; = process all Btemps</span>
<span class="sd">        monthly (boolean): if True, generate the coh maps per calendar month (generates 12 geotiff files). By default: False</span>
<span class="sd">        outnopx (boolean): if True, outputs also map of number of non-NaN pixels used to generate the mean coh map. By default: False</span>
<span class="sd">        do_std (boolean): if True, generates also std dev of coherence in time. By default: False</span>
<span class="sd">        do_tif (boolean): if True, exports the output geotiff to LiCSAR_public (as e.g. FRAME.geo.meancoh.all.tif)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xr.DataArray [, xr.DataArray, xr.DataArray]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">track</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ifgdir</span><span class="p">:</span>
        <span class="n">ifgdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">],</span> <span class="n">track</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="s1">&#39;interferograms&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">get_ifgdates</span><span class="p">(</span><span class="n">ifgdir</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error, dropping frame &#39;</span><span class="o">+</span><span class="n">frame</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">pairsall</span> <span class="o">=</span> <span class="n">get_date_matrix</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
    <span class="n">pairsall</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pairsall</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">pairsall</span><span class="p">[</span><span class="s1">&#39;cohf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifgdir</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">pairsall</span><span class="o">.</span><span class="n">pair</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">pairsall</span><span class="o">.</span><span class="n">pair</span> <span class="o">+</span> <span class="s1">&#39;.geo.cc.tif&#39;</span>
    <span class="k">if</span> <span class="n">days</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">pairsall</span><span class="p">[</span><span class="n">pairsall</span><span class="o">.</span><span class="n">btemp</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">days</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; days&#39;</span><span class="p">]</span>
    <span class="c1">#pairs[&#39;datetocheck&#39;] = pairs.date1 + pd.Timedelta(&#39;6 days&#39;)</span>
    <span class="c1">#pairs[&#39;month&#39;] = pairs[&#39;datetocheck&#39;].dt.month</span>
    <span class="n">hgtfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">],</span> <span class="n">track</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="s1">&#39;metadata&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.hgt.tif&#39;</span><span class="p">)</span>
    <span class="n">hgtxr</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_rasterio</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">))</span>
    <span class="n">hgtxr</span> <span class="o">=</span> <span class="n">hgtxr</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">monthly</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;generating coh average&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">days</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fast written solution, will output xr Dataset of avg cohs&#39;</span><span class="p">)</span>
            <span class="n">coherences</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
            <span class="c1">#ndays = pairsall.btemp.dt.days.unique()</span>
            <span class="c1">#ndays.sort()</span>
            <span class="n">daygroups</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="mi">24</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">42</span><span class="p">),</span> <span class="p">(</span><span class="mi">48</span><span class="p">,</span><span class="mi">72</span><span class="p">),</span> <span class="p">(</span><span class="mi">78</span><span class="p">,</span><span class="mi">96</span><span class="p">),</span> <span class="p">(</span><span class="mi">102</span><span class="p">,</span><span class="mi">156</span><span class="p">),</span> <span class="p">(</span><span class="mi">162</span><span class="p">,</span><span class="mi">200</span><span class="p">),</span> <span class="p">(</span><span class="mi">201</span><span class="p">,</span><span class="mi">300</span><span class="p">),</span> <span class="p">(</span><span class="mi">301</span><span class="p">,</span><span class="mi">400</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">daygroup</span> <span class="ow">in</span> <span class="n">daygroups</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;preparing coh avgs for btemp between </span><span class="si">{0}</span><span class="s1"> and </span><span class="si">{1}</span><span class="s1"> days&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">daygroup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">daygroup</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">pairs</span> <span class="o">=</span> <span class="n">pairsall</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">pairsall</span><span class="o">.</span><span class="n">btemp</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">days</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">daygroup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">daygroup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))]</span>
                <span class="c1">#now, this will select in periods between 1st March and 1st September</span>
                <span class="k">for</span> <span class="n">setX</span> <span class="ow">in</span> <span class="p">[([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="s1">&#39;summer&#39;</span><span class="p">),</span> <span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;winter&#39;</span><span class="p">)]:</span>
                    <span class="n">setX_time</span> <span class="o">=</span> <span class="n">setX</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">setX_label</span> <span class="o">=</span> <span class="n">setX</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">center_date</span> <span class="o">=</span> <span class="n">pairs</span><span class="o">.</span><span class="n">date1</span><span class="o">+</span><span class="p">(</span><span class="n">pairs</span><span class="o">.</span><span class="n">date2</span><span class="o">-</span><span class="n">pairs</span><span class="o">.</span><span class="n">date1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
                    <span class="n">setA</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">center_date</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="p">,</span><span class="n">setX_time</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">setA</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">cohavgA</span> <span class="o">=</span> <span class="n">make_avg_coh</span><span class="p">(</span><span class="n">setA</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">)</span>
                        <span class="n">cohavgA</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;number of input cohs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">setA</span><span class="p">)</span>
                        <span class="n">nameA</span> <span class="o">=</span> <span class="s1">&#39;mean coh </span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1"> days </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">daygroup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">daygroup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">setX_label</span><span class="p">)</span>
                        <span class="n">coherences</span><span class="p">[</span><span class="n">nameA</span><span class="p">]</span> <span class="o">=</span> <span class="n">cohavgA</span>
                        <span class="k">if</span> <span class="n">do_tif</span><span class="p">:</span>
                            <span class="c1"># ok, export it to current folder</span>
                            <span class="n">outtif</span> <span class="o">=</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.meancoh.</span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1">days.</span><span class="si">{2}</span><span class="s1">.tif&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">daygroup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">daygroup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">setX_label</span><span class="p">)</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">cohavgE</span> <span class="o">=</span> <span class="n">cohavgA</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;lat&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">sortby</span><span class="p">([</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span>
                            <span class="k">except</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;debug: cohavgA is already with lon, lat - check it further&#39;</span><span class="p">)</span>
                                <span class="n">cohavgE</span> <span class="o">=</span> <span class="n">cohavgA</span><span class="o">.</span><span class="n">sortby</span><span class="p">([</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span>
                            <span class="n">export_xr2tif</span><span class="p">(</span><span class="n">cohavgE</span><span class="p">,</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
                <span class="c1"># cohavgB.plot(vmin=0,vmax=0.9)</span>
                <span class="c1"># plt.show()</span>
                <span class="c1">#for ddays in days:</span>
                <span class="c1"># </span>
            <span class="k">return</span> <span class="n">coherences</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cohavg</span> <span class="o">=</span> <span class="n">make_avg_coh</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">do_std</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;generating coh std&#39;</span><span class="p">)</span>
                <span class="n">cohstd</span> <span class="o">=</span> <span class="n">make_std_coh</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">cohavg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cohstd</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pairs</span><span class="p">[</span><span class="s1">&#39;month&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="s1">&#39;date1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">pairs</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;month&#39;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;preparing month &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; from </span><span class="si">{}</span><span class="s1"> coh maps&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))))</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">make_avg_coh</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">)</span>
            <span class="n">outtif</span> <span class="o">=</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.avg_coh.month&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.tif&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;exporting to &#39;</span><span class="o">+</span><span class="n">outtif</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">write_crs</span><span class="p">(</span><span class="s2">&quot;epsg:4326&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">to_raster</span><span class="p">(</span><span class="n">outtif</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">do_tif</span><span class="p">:</span>
        <span class="c1">#outtif = os.path.join(os.environ[&#39;LiCSAR_public&#39;], track, frame, &#39;metadata&#39;, frame+&#39;.geo.meancoh.&#39;+str(days)+&#39;.tif&#39;)</span>
        <span class="n">outtif</span> <span class="o">=</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.meancoh.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">days</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.tif&#39;</span>
        <span class="n">nopx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        <span class="n">cohavg</span> <span class="o">=</span> <span class="p">(</span><span class="n">cohavg</span><span class="o">*</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">cohavg</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;NUMBER_OF_INPUT_FILES&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nopx</span>
        <span class="n">cohavg</span> <span class="o">=</span> <span class="n">cohavg</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;lat&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">sortby</span><span class="p">([</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span>
        <span class="n">export_xr2tif</span><span class="p">(</span><span class="n">cohavg</span><span class="p">,</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">outnopx</span><span class="p">:</span>
        <span class="n">nopx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cohavg</span><span class="p">,</span> <span class="n">cohstd</span><span class="p">,</span> <span class="n">nopx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cohavg</span><span class="p">,</span> <span class="n">cohstd</span></div>



<span class="c1"># Solution by Andy and Karsten to recalculate costs for masked (NN-filled) areas - not used here yet</span>

<span class="c1">################################################################################</span>
<span class="c1"># Get edges function</span>
<span class="c1">################################################################################</span>
<span class="k">def</span> <span class="nf">get_edges</span><span class="p">(</span><span class="n">ph</span><span class="p">,</span><span class="n">zeroix</span><span class="p">):</span>
    <span class="n">length</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">ph</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">zeroix</span><span class="p">)</span>
    <span class="n">datapoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ph</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">iq</span><span class="p">,</span><span class="n">jq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
    <span class="n">dq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">iq</span><span class="p">,</span><span class="n">jq</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">nntree</span> <span class="o">=</span> <span class="n">spat</span><span class="o">.</span><span class="n">cKDTree</span><span class="p">(</span><span class="n">datapoints</span><span class="p">,</span><span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">compact_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">balanced_tree</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">distq</span><span class="p">,</span> <span class="n">gridix</span> <span class="o">=</span> <span class="n">nntree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span><span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rowedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">gridix</span><span class="p">[:</span><span class="o">-</span><span class="n">width</span><span class="p">],</span>
                         <span class="n">gridix</span><span class="p">[</span><span class="n">width</span><span class="p">:]))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">gridixT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gridix</span><span class="p">,(</span><span class="n">length</span><span class="p">,</span><span class="n">width</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">coledges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">gridixT</span><span class="p">[:</span><span class="o">-</span><span class="n">length</span><span class="p">],</span>
                         <span class="n">gridixT</span><span class="p">[</span><span class="n">length</span><span class="p">:]))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">grid_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">rowedges</span><span class="p">,</span><span class="n">coledges</span><span class="p">))</span>
    <span class="n">sortix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">grid_edges</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sort_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">grid_edges</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">edge_sign</span> <span class="o">=</span> <span class="n">sortix</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">sortix</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sort_edges_flat</span> <span class="o">=</span> <span class="n">sort_edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">sort_edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">sort_edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dummy</span><span class="p">,</span> <span class="n">alledge_ix</span><span class="p">,</span> <span class="n">inverse_ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sort_edges_flat</span><span class="p">,</span>
                                              <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                              <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">alledges</span> <span class="o">=</span> <span class="n">sort_edges</span><span class="p">[</span><span class="n">alledge_ix</span><span class="p">,:]</span>
    <span class="n">alledges</span><span class="p">[</span><span class="n">alledges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">alledges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">alledges_flat</span> <span class="o">=</span> <span class="n">alledges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">alledges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">alledges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dummy</span><span class="p">,</span> <span class="n">edge_ix</span><span class="p">,</span> <span class="n">inverse_ix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">alledges_flat</span><span class="p">,</span>
                                            <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                                            <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">alledges</span><span class="p">[</span><span class="n">edge_ix</span><span class="p">,:]</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">n_edge</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_edge</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">edges</span><span class="p">))</span>
    <span class="n">gridedgeix</span> <span class="o">=</span> <span class="p">(</span><span class="n">inverse_ix2</span><span class="p">[</span><span class="n">inverse_ix</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sameixval</span> <span class="o">=</span> <span class="n">gridedgeix</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">gridedgeix</span><span class="p">[</span><span class="n">gridedgeix</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sameixval</span>
    <span class="n">gridedgeix</span> <span class="o">*=</span> <span class="n">edge_sign</span>
    <span class="n">rowix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gridedgeix</span><span class="p">[:</span><span class="n">width</span><span class="o">*</span>
                                              <span class="p">(</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">)],</span>
                       <span class="p">(</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">width</span><span class="p">)))</span>
    <span class="n">rowix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">rowix</span><span class="p">)</span> <span class="o">==</span> <span class="n">sameixval</span><span class="p">,</span><span class="n">rowix</span><span class="p">)</span>
    <span class="n">colix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gridedgeix</span><span class="p">[</span><span class="n">width</span><span class="o">*</span>
                                              <span class="p">(</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">):],</span>
                       <span class="p">(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">length</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">colix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">colix</span><span class="p">)</span> <span class="o">==</span> <span class="n">sameixval</span><span class="p">,</span><span class="n">colix</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">edges</span><span class="p">,</span> <span class="n">n_edge</span><span class="p">,</span> <span class="n">rowix</span><span class="p">,</span> <span class="n">colix</span><span class="p">,</span> <span class="n">gridix</span>


<span class="c1">################################################################################</span>
<span class="c1"># Get costs</span>
<span class="c1">################################################################################</span>
<span class="k">def</span> <span class="nf">get_costs</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">n_edge</span><span class="p">,</span> <span class="n">rowix</span><span class="p">,</span> <span class="n">colix</span><span class="p">,</span> <span class="n">zeroix</span><span class="p">):</span>
    <span class="n">length</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">zeroix</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">maxshort</span> <span class="o">=</span> <span class="mi">32000</span>
    <span class="n">costscale</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="n">nshortcycle</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">zeroix</span><span class="p">)</span>
    <span class="n">grid_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">rowix</span><span class="o">.</span><span class="n">compressed</span><span class="p">()[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">colix</span><span class="o">.</span><span class="n">compressed</span><span class="p">()[:,</span><span class="kc">None</span><span class="p">]))</span>
    <span class="n">n_edges</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">grid_edges</span><span class="p">),</span><span class="n">n_edge</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_edge</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">edge_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">sigsq_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">edge_length</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">aps_range</span> <span class="o">=</span> <span class="mi">20000</span>
    <span class="n">sigsq_aps</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">sigsq_noise</span> <span class="o">+=</span> <span class="n">sigsq_aps</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">edge_length</span>
                                       <span class="o">*</span> <span class="mi">80</span>
                                       <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="n">aps_range</span><span class="p">))</span>
    <span class="n">sigsq_noise</span> <span class="o">/=</span> <span class="mi">10</span>
    <span class="n">sigsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">((</span><span class="n">sigsq_noise</span><span class="o">*</span><span class="n">nshortcycle</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">costscale</span><span class="o">*</span><span class="n">n_edges</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>
    <span class="n">sigsq</span><span class="p">[</span><span class="n">sigsq</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">rowcost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">width</span><span class="o">*</span><span class="mi">4</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">colcost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">length</span><span class="p">,(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">rowstdgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">rowix</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">colstdgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">colix</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
    <span class="n">rowcost</span><span class="p">[:,</span><span class="mi">2</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxshort</span>
    <span class="n">colcost</span><span class="p">[:,</span><span class="mi">2</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxshort</span>
    <span class="n">rowcost</span><span class="p">[:,</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">maxshort</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">colcost</span><span class="p">[:,</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">maxshort</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rowix</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span><span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
        <span class="n">rowstdgrid</span><span class="p">[</span><span class="o">~</span><span class="n">rowix</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigsq</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">rowix</span><span class="o">.</span><span class="n">compressed</span><span class="p">())]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">rowstdgrid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">rowstdgrid</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigsq</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">rowix</span><span class="o">.</span><span class="n">compressed</span><span class="p">())]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">rowcost</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">rowstdgrid</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">colix</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span><span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
        <span class="n">colstdgrid</span><span class="p">[</span><span class="o">~</span><span class="n">colix</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigsq</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">colix</span><span class="o">.</span><span class="n">compressed</span><span class="p">())]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">colstdgrid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">colstdgrid</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigsq</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">colix</span><span class="o">.</span><span class="n">compressed</span><span class="p">())]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">colcost</span><span class="p">[:,</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">colstdgrid</span>
    <span class="k">return</span> <span class="n">rowcost</span><span class="p">,</span> <span class="n">colcost</span>



<span class="c1">#### extra functions (not used in the workflow, but considered useful!)</span>

<div class="viewcode-block" id="deramp_unw"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.deramp_unw">[docs]</a><span class="k">def</span> <span class="nf">deramp_unw</span><span class="p">(</span><span class="n">xrda</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span><span class="s1">&#39;lon&#39;</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Deramps unwrapped interferogram</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                    <span class="n">_detrend_2d_ufunc</span><span class="p">,</span>
                    <span class="n">da</span><span class="p">,</span>
                    <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span>
                    <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span>
                    <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span>
                    <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">dt</span></div>


<span class="k">def</span> <span class="nf">_detrend_2d_ufunc</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">col0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">col1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">col2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">col0</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">d_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">m_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">spl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">G</span><span class="p">)),</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">d_obs</span><span class="p">)</span>
    <span class="n">d_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">m_est</span><span class="p">)</span>
    <span class="n">linear_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">d_est</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arr</span> <span class="o">-</span> <span class="n">linear_fit</span>


<div class="viewcode-block" id="deramp_ifg_tif"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.deramp_ifg_tif">[docs]</a><span class="k">def</span> <span class="nf">deramp_ifg_tif</span><span class="p">(</span><span class="n">phatif</span><span class="p">,</span> <span class="n">unwrap_after</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Deramps wrapped interferogram geotiff</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># works fine if the path is to some diff_pha.tif file inside $LiCSAR_public only!</span>
    <span class="n">phatif</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">phatif</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">phatif</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;the input tif does not exist, exiting&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">xrpha</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">phatif</span><span class="p">)</span>
    <span class="n">xrpha_detrended</span> <span class="o">=</span> <span class="n">detrend_ifg_xr</span><span class="p">(</span><span class="n">xrpha</span><span class="p">,</span> <span class="n">isphase</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">xrpha_detrended</span> <span class="o">=</span> <span class="n">xrpha_detrended</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">xrpha</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">phatif_orig</span> <span class="o">=</span> <span class="n">phatif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.diff_pha.orig.tif&#39;</span><span class="p">)</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;mv </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phatif</span><span class="p">,</span> <span class="n">phatif_orig</span><span class="p">))</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;mv </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phatif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.diff.png&#39;</span><span class="p">),</span> 
       <span class="n">phatif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.diff.orig.png&#39;</span><span class="p">)))</span>
    <span class="n">export_xr2tif</span><span class="p">(</span><span class="n">xrpha_detrended</span><span class="p">,</span> <span class="n">phatif</span><span class="p">)</span>
    <span class="c1"># just do also preview</span>
    <span class="n">create_preview</span><span class="p">(</span><span class="n">phatif</span><span class="p">,</span> <span class="s1">&#39;wrapped&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">unwrap_after</span><span class="p">:</span>
        <span class="c1"># and probably reunwrapping is needed...</span>
        <span class="c1"># doing it original way</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">phatif</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="n">phatif</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">unwtif</span> <span class="o">=</span> <span class="n">phatif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">)</span>
        <span class="n">unwtif_orig</span> <span class="o">=</span> <span class="n">unwtif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.unw.orig.tif&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;mv </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unwtif</span><span class="p">,</span> <span class="n">unwtif_orig</span><span class="p">))</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;mv </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unwtif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.unw.png&#39;</span><span class="p">),</span> <span class="n">unwtif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.unw.orig.png&#39;</span><span class="p">)))</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;unwrap_geo.sh </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">))</span></div>
        <span class="c1">#or using this approach? well... it takes some 5x+ longer!!!, so perhaps not</span>
        <span class="c1">#outtif = phatif.replace(&#39;.geo.diff_pha.tif&#39;,&#39;.geo.unw.tif&#39;)</span>
        <span class="c1">#process_ifg(frame, pair, ml = 1, pre_detrend = False, outtif = outtif)</span>
    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, COMET and CEMAC teams.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>