<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>licsar_proc.python.LiCSAR_lib.lics_unwrap &mdash; COMET LiCSAR  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> COMET LiCSAR
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../wiki.html">LiCSAR Wiki</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Main LiCSAR Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../licsar_db/index.html">LiCSInfo db</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../licsar_proc/index.html">LiCSAR proc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../licsar_framebatch/index.html">LiCSAR Framebatch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../licsbas/index.html">LiCSBAS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../daz/index.html">daz</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../licsar_proc/apidoc.html">LiCSAR proc</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Further information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../ciw.html">COMET InSAR Workshop Materials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer comments and advices</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation.html">Notes about documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../documentation.html#admin-or-dev-comments">Admin or dev comments</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">COMET LiCSAR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>licsar_proc.python.LiCSAR_lib.lics_unwrap</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for licsar_proc.python.LiCSAR_lib.lics_unwrap</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="c1">################################################################################</span>
<span class="c1"># LiCSAR Unwrapper</span>
<span class="c1"># by Milan Lazecky, 2021-2022, University of Leeds</span>
<span class="c1">#</span>
<span class="c1"># version: 1.0.0 (2022-06-03)</span>
<span class="c1">#</span>
<span class="c1"># A tool to unwrap LiCSAR (or any other) interferogram, starting from geotiffs</span>
<span class="c1"># Mandatory inputs: geotiffs of phase, coherence</span>
<span class="c1"># Optional inputs: geotiffs with GACOS corrections, DEM, landmask (automatically found for LiCSAR)</span>
<span class="c1">#</span>
<span class="c1"># Pre-requisities: snaphu</span>
<span class="c1"># Optional requisites: GMT, cpxfiddle (doris), ImageMagick</span>
<span class="c1">#</span>
<span class="c1">################################################################################</span>
<span class="c1">#Imports</span>
<span class="c1">################################################################################</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">subprocess</span>

<span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
<span class="n">xr</span><span class="o">.</span><span class="n">set_options</span><span class="p">(</span><span class="n">keep_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">rioxarray</span>
<span class="kn">from</span> <span class="nn">osgeo</span> <span class="k">import</span> <span class="n">gdal</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">gaussian_filter</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="k">import</span> <span class="n">generic_filter</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">stats</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sps</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">spl</span>
<span class="kn">from</span> <span class="nn">astropy.convolution</span> <span class="k">import</span> <span class="n">Gaussian2DKernel</span><span class="p">,</span> <span class="n">interpolate_replace_nans</span><span class="p">,</span> <span class="n">convolve_fft</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="k">import</span> <span class="n">HuberRegressor</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<span class="c1"># avoid cv2 in ipynb</span>
<span class="k">def</span> <span class="nf">in_ipynb</span><span class="p">():</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cfg</span> <span class="o">=</span> <span class="n">get_ipython</span><span class="p">()</span><span class="o">.</span><span class="n">config</span> 
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">if</span> <span class="ow">not</span> <span class="n">in_ipynb</span><span class="p">():</span>
    <span class="c1"># some extra imports, used by additional functions</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cv2 not loaded - cascade will not work&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;at JASMIN notebook service, cv2 does not load - cascade will not work&#39;</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;dask not loaded - hgt correlation will not work&#39;</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">framecare</span> <span class="k">as</span> <span class="nn">fc</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;framecare not loaded - amplitude stability will not work&#39;</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">LiCSAR_lib.LiCSAR_misc</span> <span class="k">import</span> <span class="o">*</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;licsar misc not loaded&#39;</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">LiCSBAS_io_lib</span> <span class="k">as</span> <span class="nn">io</span>
    <span class="kn">from</span> <span class="nn">LiCSBAS_tools_lib</span> <span class="k">import</span> <span class="o">*</span>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;licsbas not loaded - the amplitude/coherence average/stability will fail&#39;</span><span class="p">)</span>


<span class="c1">################################################################################</span>
<span class="c1"># Main functions to perform the unwrapping</span>
<span class="c1">################################################################################</span>

<div class="viewcode-block" id="cascade_unwrap"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.cascade_unwrap">[docs]</a><span class="k">def</span> <span class="nf">cascade_unwrap</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">downtoml</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span>
                   <span class="n">only10</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">thres</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                   <span class="n">outtif</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dolocal</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main function to unwrap a geocoded LiCSAR interferogram using a cascade approach.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        frame (string): LiCSAR frame ID</span>
<span class="sd">        pair (string): identifier of interferometric pair, e.g. &#39;20200120_20200201&#39;</span>
<span class="sd">        downtoml (int): target multilook factor (default: 1, no extra multilooking)</span>
<span class="sd">        procdir (string): path to processing directory</span>
<span class="sd">        only10 (boolean): switch to use only 1 previous ramp, scaled 10x to the downtoml, instead of few cascades</span>
<span class="sd">        smooth (boolean): switch to use extra Gaussian filtering for 2-pass unwrapping</span>
<span class="sd">        thres (float): threshold between 0-1 for gaussian-based coherence-like measure (spatial phase consistence?); higher number - more is masked prior to unwrapping</span>
<span class="sd">        </span>
<span class="sd">        hgtcorr (boolean): switch to perform correction for height-phase correlation.</span>
<span class="sd">        outtif (string or None): path to geotiff file to export result to.</span>
<span class="sd">        cliparea_geo (string or None): use GMT/LiCSBAS string to identify area to clip, in geo-coordinates, as ``&#39;lon1/lon2/lat1/lat2&#39;``</span>
<span class="sd">        subtract_gacos (boolean): switch whether to return the interferograms with GACOS being subtracted (by default, GACOS is used only to support unwrapping and would be added back)</span>
<span class="sd">        dolocal (boolean): switch to use local directory to find interferograms, rather than search for LiCSAR_public directory in JASMIN</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: unwrapped multilooked interferogram with additional layers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;performing cascade unwrapping&#39;</span><span class="p">)</span>
    <span class="n">starttime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">only10</span><span class="p">:</span>
        <span class="c1"># 01/2022: updating parameters:</span>
        <span class="n">ifg_ml10</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">downtoml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">rampit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">downtoml</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># avoiding gauss proc, as seems heavy for memory</span>
            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">downtoml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">ifg_ml10</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">],</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">outtif</span><span class="o">=</span><span class="n">outtif</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">downtoml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">ifg_ml10</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">],</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">outtif</span><span class="o">=</span><span class="n">outtif</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ifg_mlc</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">rampit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">downtoml</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">ifg_mla</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">],</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">rampit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
                <span class="n">ifg_mlc</span> <span class="o">=</span> <span class="n">ifg_mla</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">downtoml</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># avoiding gauss proc, as seems heavy for memory</span>
            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">downtoml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">],</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">outtif</span><span class="o">=</span><span class="n">outtif</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">procdir</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">downtoml</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">],</span> <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">outtif</span><span class="o">=</span><span class="n">outtif</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span>  <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
    <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">starttime</span>
    <span class="n">hour</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elapsed_time</span><span class="o">/</span><span class="mi">3600</span><span class="p">)</span>
    <span class="n">minite</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">((</span><span class="n">elapsed_time</span><span class="o">/</span><span class="mi">60</span><span class="p">),</span><span class="mi">60</span><span class="p">))</span>
    <span class="n">sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span><span class="mi">60</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Total elapsed time: </span><span class="si">{0:02}</span><span class="s2">h </span><span class="si">{1:02}</span><span class="s2">m </span><span class="si">{2:02}</span><span class="s2">s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hour</span><span class="p">,</span><span class="n">minite</span><span class="p">,</span><span class="n">sec</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ifg_ml</span></div>


<span class="k">def</span> <span class="nf">load_tif</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;unw&#39;</span><span class="p">,</span><span class="n">cliparea_geo</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">pubdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">]</span>
    <span class="n">geoframedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pubdir</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">])),</span><span class="n">frame</span><span class="p">)</span>
    <span class="n">geoifgdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;interferograms&#39;</span><span class="p">,</span><span class="n">pair</span><span class="p">)</span>
    <span class="n">infile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.&#39;</span><span class="o">+</span><span class="n">dtype</span><span class="o">+</span><span class="s1">&#39;.tif&#39;</span><span class="p">)</span>
    <span class="k">return</span>  <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span><span class="n">cliparea_geo</span><span class="o">=</span><span class="n">cliparea_geo</span><span class="p">)</span>


<div class="viewcode-block" id="get_resolution"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.get_resolution">[docs]</a><span class="k">def</span> <span class="nf">get_resolution</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">in_m</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gets resolution of the xr.dataset (or dataarray), either in metres or degrees</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">resdeg</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ifg</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ifg</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">in_m</span><span class="p">:</span>
        <span class="n">latres</span> <span class="o">=</span> <span class="mf">111.32</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span> <span class="o">*</span> <span class="mi">1000</span> <span class="c1"># in m</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">latres</span> <span class="o">*</span> <span class="n">resdeg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">resdeg</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">load_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">unw</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dolocal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">pubdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">]</span>
    <span class="n">geoframedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pubdir</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">])),</span><span class="n">frame</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dolocal</span><span class="p">:</span>
        <span class="n">geoifgdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;GEOC&#39;</span><span class="p">,</span><span class="n">pair</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">geoifgdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;interferograms&#39;</span><span class="p">,</span><span class="n">pair</span><span class="p">)</span>
    <span class="c1">#orig files</span>
    <span class="c1"># will use only the filtered ifgs now..</span>
    <span class="n">ifg_pha_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)</span>
    <span class="n">coh_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.cc.tif&#39;</span><span class="p">)</span>
    <span class="n">landmask_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;metadata&#39;</span><span class="p">,</span><span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.landmask.tif&#39;</span><span class="p">)</span>
    <span class="n">hgtfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;metadata&#39;</span><span class="p">,</span><span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.hgt.tif&#39;</span><span class="p">)</span>
    <span class="c1"># load the files</span>
    <span class="n">inpha</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">ifg_pha_file</span><span class="p">)</span>
    <span class="n">incoh</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">coh_file</span><span class="p">)</span>
    <span class="n">incoh</span> <span class="o">=</span> <span class="n">incoh</span><span class="o">/</span><span class="mi">255</span>
    <span class="n">inmask</span> <span class="o">=</span> <span class="n">incoh</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">inmask</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">(</span><span class="n">incoh</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">landmask_file</span><span class="p">):</span>
        <span class="n">landmask</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">landmask_file</span><span class="p">)</span>
        <span class="c1">#landmask = xr.open_dataset(landmasknc)</span>
        <span class="n">inmask</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">landmask</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">inmask</span><span class="o">.</span><span class="n">values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">landmask</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># create datacube</span>
    <span class="n">ifg</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inpha</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">incoh</span><span class="o">.</span><span class="n">values</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">inmask</span><span class="o">.</span><span class="n">values</span>
    <span class="c1"># just to clean from memory</span>
    <span class="n">inpha</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
    <span class="n">incoh</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
    <span class="c1"># to load orig unw_file</span>
    <span class="k">if</span> <span class="n">unw</span><span class="p">:</span>
        <span class="n">unw_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">)</span>
        <span class="n">incoh</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">unw_file</span><span class="p">)</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">inunw</span><span class="o">.</span><span class="n">values</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask_extent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># including hgt anyway - would be useful later</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">inhgt</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">)</span>
            <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
            <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">inhgt</span><span class="o">.</span><span class="n">values</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR in importing heights!&#39;</span><span class="p">)</span>
            <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">ifg</span>


<div class="viewcode-block" id="process_ifg"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.process_ifg">[docs]</a><span class="k">def</span> <span class="nf">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> 
        <span class="n">ml</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="mf">0.35</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prevest</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">coh2var</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>  <span class="n">rampit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dolocal</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cohratio</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main function to unwrap a geocoded LiCSAR interferogram. Works on JASMIN (but can be easily adapted for local use)</span>

<span class="sd">    Args:</span>
<span class="sd">        frame (string): LiCSAR frame ID</span>
<span class="sd">        pair (string): identifier of interferometric pair, e.g. ``&#39;20200120_20200201&#39;``</span>
<span class="sd">        procdir (string): path to processing directory</span>
<span class="sd">        ml (int): multilooking factor used to reduce the interferogram in lon/lat</span>
<span class="sd">        fillby (string): algorithm to fill gaps. use one of values: ``&#39;gauss&#39;``, ``&#39;nearest&#39;``, ``&#39;none&#39;`` (where ``&#39;none&#39;`` would only fill NaNs by zeroes)</span>
<span class="sd">        thres (float): threshold between 0-1 for gaussian-based coherence-like measure (spatial phase consistence?); higher number - more is masked prior to unwrapping</span>
<span class="sd">        smooth (boolean): switch to use extra Gaussian filtering for 2-pass unwrapping</span>
<span class="sd">        defomax (float): parameter to snaphu for maximum deformation in rad per 2pi cycle (DEFOMAX_CYCLE)</span>
<span class="sd">        </span>
<span class="sd">        hgtcorr (boolean): switch to perform correction for height-phase correlation</span>
<span class="sd">        gacoscorr (boolean): switch to apply GACOS corrections (if detected)</span>
<span class="sd">        pre_detrend (boolean): switch to apply detrending on wrapped phase to support unwrapping</span>
<span class="sd">        </span>
<span class="sd">        cliparea_geo (string or None): use GMT/LiCSBAS string to identify area to clip, in geo-coordinates, as ``&#39;lon1/lon2/lat1/lat2&#39;``</span>
<span class="sd">        outtif (string or None): path to geotiff file to export result to.</span>
<span class="sd">        prevest (xarray.DataArray or None): a previous rough estimate to be used by snaphu as the ESTFILE</span>
<span class="sd">        prev_ramp (xarray.DataArray or None): a previous estimate or a ramp that will be removed prior to unwrapping (and added back)</span>
<span class="sd">        </span>
<span class="sd">        coh2var (boolean): convert coherence to variance for weighting. could be useful, but need to change from squared, something to try...</span>
<span class="sd">        add_resid (boolean): switch to add back residuals from spatially filtered unwrapping (makes sense if smooth is ON)</span>
<span class="sd">        rampit (boolean): perform an extra strong gaussian filter to get a very rough unwrapping result. basically a longwave signal ramp. used by cascade approach</span>
<span class="sd">        subtract_gacos (boolean): switch whether to return the interferograms with GACOS being subtracted (by default, GACOS is used only to support unwrapping and would be added back)</span>
<span class="sd">        dolocal (boolean): switch to use local directory to find interferograms, rather than search for LiCSAR_public directory in JASMIN</span>
<span class="sd">        </span>
<span class="sd">        cohratio (xr.DataArray): coherence ratio (or another array) to be used for weighting the phase instead of the original coherence</span>
<span class="sd">        keep_coh_debug (boolean): only in combination with use_coh_stab - whether or not to keep original (downsampled) ifg coherence after using the coh_stab to weight the phase during multilooking</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: unwrapped multilooked interferogram with additional layers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ifg</span> <span class="o">=</span> <span class="n">load_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">dolocal</span><span class="o">=</span><span class="n">dolocal</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error in loading data&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="c1"># prepare tmp dir structure</span>
    <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span><span class="s1">&#39;temp_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ml</span><span class="p">))</span>
    <span class="n">tmpgendir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span><span class="n">pair</span><span class="p">,</span><span class="s1">&#39;temp_gen&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span><span class="n">pair</span><span class="p">)):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span><span class="n">pair</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tmpgendir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmpgendir</span><span class="p">)</span>
    
    <span class="c1"># do gacos if exists</span>
    <span class="k">if</span> <span class="n">gacoscorr</span><span class="p">:</span>
        <span class="n">gacoscorrfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpgendir</span><span class="p">,</span><span class="s1">&#39;gacos.tif&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">gacoscorrfile</span> <span class="o">=</span> <span class="n">make_gacos_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">gacoscorrfile</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error processing gacos data for pair &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
            <span class="n">gacoscorrfile</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gacoscorrfile</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">gacoscorrfile</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;GACOS data found, using to improve unwrapping&#39;</span><span class="p">)</span>
        <span class="c1">#ingacos = xr.open_dataset(gacoscorrfile)</span>
        <span class="n">ingacos</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">gacoscorrfile</span><span class="p">)</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">pha</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">ingacos</span><span class="o">.</span><span class="n">values</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gacoscorr</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># masking by coherence if we do not use multilooking - here the coherence corresponds to reality</span>
    <span class="k">if</span> <span class="n">ml</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">cohthres</span> <span class="o">=</span> <span class="mf">0.15</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cohthres</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hgtcorr</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;hgt&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR in importing heights!&#39;</span><span class="p">)</span>
            <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># now doing multilooking, using coh as mag...</span>
    <span class="c1">#make complex from coh and pha</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">coh2var</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">cohratio</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="c1"># use cohratio for better weights</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="n">cohratio</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span>
        <span class="c1"># if this is better, i will change it and have it fixed</span>
        <span class="n">cohratio</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">coh</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">coh</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">cohratio</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">cohratio</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="c1">#fixing difference in xarray version... perhaps...</span>
    <span class="k">if</span> <span class="s1">&#39;lat&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;warning - perhaps old xarray version - trying anyway&#39;</span><span class="p">)</span>
        <span class="n">ifg</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">rename_dims</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="s1">&#39;lat&#39;</span><span class="p">})</span>
    <span class="c1"># now crop if needed:</span>
    <span class="k">if</span> <span class="n">cliparea_geo</span><span class="p">:</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipy</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minclipy</span> <span class="o">&gt;</span> <span class="n">maxclipy</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (latitude). fixing&#39;</span><span class="p">)</span>
            <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipy</span>
            <span class="n">minclipy</span><span class="o">=</span><span class="n">maxclipy</span>
            <span class="n">maxclipy</span><span class="o">=</span><span class="n">tmpcl</span>
        <span class="k">if</span> <span class="n">minclipx</span> <span class="o">&gt;</span> <span class="n">maxclipx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (longitude). fixing&#39;</span><span class="p">)</span>
            <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipx</span>
            <span class="n">minclipx</span><span class="o">=</span><span class="n">maxclipx</span>
            <span class="n">maxclipx</span><span class="o">=</span><span class="n">tmpcl</span>
        <span class="c1"># now will clip it - lat is opposite-sorted, so need to slice from max to min in y ... plus 10 pixels on all sides</span>
        <span class="n">resdeg</span> <span class="o">=</span> <span class="n">get_resolution</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">in_m</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ifg</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">minclipx</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">,</span> <span class="n">maxclipx</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">),</span> <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">maxclipy</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">,</span> <span class="n">minclipy</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">))</span>
        <span class="c1"># not the best here, as pixels might get slightly shifted, but perhaps not that big deal (anyway prev_ramp is &#39;blurred&#39;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">prev_ramp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">prev_ramp</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">minclipx</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">,</span> <span class="n">maxclipx</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">),</span> <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">maxclipy</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">,</span> <span class="n">minclipy</span><span class="o">-</span><span class="mi">10</span><span class="o">*</span><span class="n">resdeg</span><span class="p">))</span>
    <span class="c1">#WARNING - ONLY THIS FUNCTION HAS GACOS INCLUDED NOW! (and heights fix!!!)</span>
    <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">multilook_normalised</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">ml</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="n">pre_detrend</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">prev_ramp</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="n">keep_coh_debug</span><span class="p">)</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
    <span class="c1">#here we should keep the (not wrapped) phase we remove due to corrections - here, heights, and gacos</span>
    <span class="c1">#mask it ... this worked ok here:</span>
    <span class="c1">#thres = 0.5</span>
    <span class="c1">#gmmm.... it works better if i use the &#39;trick on gauss of normalised ifg....&#39;</span>
    <span class="c1">#thres = 0.25</span>
    <span class="n">mask_gauss</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_coh</span> <span class="o">&gt;</span> <span class="n">thres</span><span class="p">)</span><span class="o">*</span><span class="mi">1</span>
    <span class="c1">#return (unmask) pixels that have coh &gt; 0.25</span>
    <span class="n">mask_gauss</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">mask_gauss</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span> <span class="o">&gt;</span> <span class="mf">0.25</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">mask_gauss</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask_gauss</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># additionally remove islands of size over 7x7 km</span>
    <span class="c1"># how many pixels are in 7x7 km region?</span>
    <span class="n">lenthres</span> <span class="o">=</span> <span class="mi">7000</span> <span class="c1"># m</span>
    <span class="c1"># resolution of orig ifg is expected 0.1 km</span>
    <span class="n">mlres</span> <span class="o">=</span> <span class="n">get_resolution</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">in_m</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">pixels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">lenthres</span><span class="o">/</span><span class="n">mlres</span><span class="p">))</span>
    <span class="c1">#origres = 0.1</span>
    <span class="c1">#resdeg = np.abs(ifg.lat[1]-ifg.lat[0])</span>
    <span class="c1">#latres = 111.32 * np.cos(np.radians(ifg_ml.lat.mean()))</span>
    <span class="c1">#origres = float(latres * resdeg) # in km</span>
    <span class="c1">#</span>
    <span class="c1">#pixels = int(round(lenthres/origres/ml))</span>
    <span class="n">pixelsno</span> <span class="o">=</span> <span class="n">pixels</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">npa</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_coh&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_coh&#39;</span><span class="p">]</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">remove_islands</span><span class="p">(</span><span class="n">npa</span><span class="p">,</span> <span class="n">pixelsno</span><span class="p">)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="c1">#ifg_ml[&#39;mask_coh&#39;] = ifg_ml[&#39;mask&#39;].where(ifg_ml.gauss_coh &gt; thres).where(ifg_ml.coh &gt; thres).fillna(0)</span>
    <span class="c1">#here the origpha is just before the gapfilling filter</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#try without modal filter..</span>
    <span class="c1">#ifg_ml = filter_mask_modal(ifg_ml, &#39;mask_coh&#39;, &#39;mask_coh&#39;, 8)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;interpolate coh-based masked areas of gauss pha&#39;</span><span class="p">)</span>
    <span class="c1">#tofillpha = ifg_ml.pha.fillna(0).where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
    <span class="k">if</span> <span class="n">fillby</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
        <span class="c1"># keep smooth always on - much better...</span>
        <span class="k">if</span> <span class="n">smooth</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_pha</span>
        <span class="c1">#trying astropy approach now:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filling through Gaussian kernel&#39;</span><span class="p">)</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># create a &quot;fixed&quot; image with NaNs replaced by interpolated values</span>
        <span class="n">tempar_mag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="p">)</span>
        <span class="c1">#cpxarr = magpha2RI_array(tempar_mag1, ifg_ml.pha.fillna(0).values)</span>
        <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx_tofill&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx_tofill&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxarr</span>
        <span class="c1"># using only extent - avoiding landmask as rivers would have problems</span>
        <span class="c1">#tofill = ifg_ml[&#39;cpx_tofill&#39;].where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
        <span class="c1">#tofill = ifg_ml[&#39;cpx_tofill&#39;].where(ifg_ml.mask_coh.where(ifg_ml.mask_extent == 1).fillna(1) == 1)</span>
        <span class="c1"># or not... let&#39;s mask fully</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">tofill</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx_tofill&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_extent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tofillR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">tofill</span><span class="p">)</span>
        <span class="n">tofillI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">tofill</span><span class="p">)</span>
        <span class="n">filledR</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">tofillR</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="n">filledI</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">tofillI</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">filledR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">filledI</span><span class="p">)</span>
        <span class="c1">#sometimes the whole area is not within gauss kernel</span>
        <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;gapfilling iteration &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
                <span class="c1"># no need to add more heavy iterations</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filling by nearest neighbours&#39;</span><span class="p">)</span>
                <span class="c1">#tofillpha = ifg_ml.pha.where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
                <span class="c1">#tofillpha = ifg_ml.pha.where(ifg_ml.mask_full.where(ifg_ml.mask_extent == 1).fillna(1) == 1)</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx_tofill&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxarr</span>
                <span class="n">tofill</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx_tofill&#39;</span><span class="p">]</span>
                <span class="n">tofillR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">tofill</span><span class="p">)</span>
                <span class="n">tofillI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">tofill</span><span class="p">)</span>
                <span class="n">filledR</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">tofillR</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
                <span class="n">filledI</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">tofillI</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">filledR</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">filledI</span><span class="p">)</span>
        <span class="c1">#sometimes the whole area is not within gauss kernel - use NN for that:</span>
        <span class="c1">#if np.max(np.isnan(ifg_ml[&#39;pha&#39;].values)):</span>
        <span class="c1">#    # no, this would be too far. using only filling by zero</span>
        <span class="c1">#    ifg_ml[&#39;pha&#39;] = ifg_ml[&#39;pha&#39;].fillna(0)</span>
        <span class="c1">#    #ifg_ml[&#39;pha&#39;].values = interpolate_nans(ifg_ml[&#39;pha&#39;].values, method=&#39;nearest&#39;)</span>
        <span class="c1">#ifg_ml.pha.fillna(0).where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
        <span class="c1">#ifg_ml[&#39;pha&#39;].values = interpolate_replace_nans(tofillpha.values, kernel)</span>
    <span class="k">elif</span> <span class="n">fillby</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;skipping any nan filling&#39;</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_pha</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filling by nearest neighbours&#39;</span><span class="p">)</span>
        <span class="c1">#tofillpha = ifg_ml.pha.fillna(0).where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
        <span class="c1">#tofillpha = ifg_ml.pha.fillna(0).where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
        <span class="n">tofillpha</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_extent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_nans</span><span class="p">(</span><span class="n">tofillpha</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="c1">#ifg_ml[&#39;gauss_pha&#39;] = ifg_ml[&#39;gauss_pha&#39;].fillna(0)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;debug: now pha is fine-filled layer but with some noise at edges - why is that? not resolved. so adding one extra gauss filter&#39;</span><span class="p">)</span>
    <span class="c1"># ok, i see some high freq signal is still there.. so filtering once more (should also help after the nan filling)</span>
    <span class="k">if</span> <span class="n">smooth</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;an extra Gaussian smoothing here&#39;</span><span class="p">)</span>
        <span class="c1">#ifg_ml = filter_ifg_ml(ifg_ml)</span>
        <span class="c1"># 2022/07: adding strong filter, say radius 1 km</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">filter_ifg_ml</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_pha&#39;</span><span class="p">]</span>
    <span class="c1">#exporting for snaphu</span>
    <span class="c1">#normalise mag from the final pha</span>
    <span class="n">tempar_mag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="p">)</span>
    <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="c1">#no need to fillna, but just in case...</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxarr</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;unwrapping by snaphu&#39;</span><span class="p">)</span>
    <span class="n">binmask</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;gaussmask.bin&#39;</span><span class="p">)</span>
    <span class="c1">#bincoh = os.path.join(tmpdir,&#39;gausscoh.bin&#39;)</span>
    <span class="n">bincoh</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;coh.bin&#39;</span><span class="p">)</span>
    <span class="c1">#binR = os.path.join(tmpdir,&#39;gaussR.bin&#39;)</span>
    <span class="c1">#binI = os.path.join(tmpdir,&#39;gaussI.bin&#39;)</span>
    <span class="n">binCPX</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;cpxgaussifg.bin&#39;</span><span class="p">)</span>
    <span class="n">outunwbin</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;gaussunwrapped.bin&#39;</span><span class="p">)</span>
    <span class="c1">#print(&#39;exporting to bin files&#39;)</span>
    <span class="c1">#ifg_ml.mask_coh.fillna(0).values.astype(np.byte).tofile(binmask)</span>
    <span class="c1"># full masking may be too much for snaphu here:</span>
    <span class="c1">#ifg_ml.mask_full.fillna(0).values.astype(np.byte).tofile(binmask)</span>
    <span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">binmask</span><span class="p">)</span>
    <span class="c1">#ifg_ml.gauss_coh.fillna(0.001).values.astype(np.float32).tofile(bincoh)</span>
    <span class="c1"># we should use the orig coh for weights... and perhaps very low coh values instead of 0</span>
    <span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">bincoh</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_cpx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="c1">#.tofile(binR)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_cpx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="c1">#.tofile(binI)</span>
    <span class="n">RI2cpx</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">binCPX</span><span class="p">)</span>
    <span class="c1">#unwrapping itself</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">prevest</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">#resizing previous ML step and using to unwrap</span>
        <span class="n">bin_pre</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;prevest.bin&#39;</span><span class="p">)</span>
        <span class="n">bin_est</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;prevest.rescaled.bin&#39;</span><span class="p">)</span>
        <span class="n">bin_pre_remove</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;prevest.rescaled.remove.bin&#39;</span><span class="p">)</span>
        <span class="c1">#binI_pre = os.path.join(tmpdir,&#39;prevest.I.bin&#39;)</span>
        
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">prevest</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">prevest</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">prevest</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="c1">#prevest.values = interpolate_replace_nans(prevest.values, kernel)</span>
        <span class="c1">#filling other nans to 0 - this can happen if null regions are too large (larger than the kernel accepts)</span>
        <span class="n">prevest</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">bin_pre</span><span class="p">)</span>
        <span class="n">width_pre</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prevest</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">length_pre</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prevest</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="c1">#resize_bin(bin_pre, width_pre, length_pre, bin_est, width, length, dtype = np.float32, intertype = cv2.INTER_CUBIC)</span>
        <span class="n">resize_bin</span><span class="p">(</span><span class="n">bin_pre</span><span class="p">,</span> <span class="n">width_pre</span><span class="p">,</span> <span class="n">length_pre</span><span class="p">,</span> <span class="n">bin_est</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">intertype</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">bin_pre_remove</span><span class="p">)</span>
        <span class="n">main_unwrap</span><span class="p">(</span><span class="n">binCPX</span><span class="p">,</span> <span class="n">bincoh</span><span class="p">,</span> <span class="n">binmask</span><span class="p">,</span> <span class="n">outunwbin</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">bin_est</span><span class="p">,</span> <span class="n">bin_pre_remove</span> <span class="o">=</span> <span class="n">bin_pre_remove</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#print(&#39;unwrapping&#39;)</span>
        <span class="c1">#main_unwrap(binCPX, bincoh, binmask, outunwbin, width, defomax = defomax, printout=False)</span>
        <span class="c1"># 2022-01-14 - avoiding mask here - it does only worse</span>
        <span class="c1">#main_unwrap(binCPX, bincoh, None, outunwbin, width, defomax = defomax, printout=False)</span>
        <span class="c1"># 2022-04-04 - returning the mask! result is really bad with it, at least at islands!</span>
        <span class="n">main_unwrap</span><span class="p">(</span><span class="n">binCPX</span><span class="p">,</span> <span class="n">bincoh</span><span class="p">,</span> <span class="n">binmask</span><span class="p">,</span> <span class="n">outunwbin</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">printout</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;importing snaphu result to ifg_ml&#39;</span><span class="p">)</span>
    <span class="n">binfile</span> <span class="o">=</span> <span class="n">outunwbin</span>
    <span class="c1">#toxr = ifg_ml</span>
    <span class="n">daname</span> <span class="o">=</span> <span class="s1">&#39;unw&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="n">unw1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">binfile</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">unw1</span> <span class="o">=</span> <span class="n">unw1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1">#unw1 = np.flip(unw1,axis=0)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="c1">#.copy(deep=True)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">unw1</span>
    <span class="c1">#ok, so the gauss-based coh mask is not the best to do... so exporting &#39;all pixels&#39;</span>
    <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask&#39;]</span>
    <span class="c1">#print(&#39;20210722 - testing now - using gauss-based coh mask, ignore the next message:&#39;)</span>
    <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask_coh&#39;]</span>
    <span class="c1">#this would do median correction, not doing it now:</span>
    <span class="c1">#ifg_ml[daname].values = ifg_ml[daname].values - np.nanmedian(ifg_ml[daname].where(ifg_ml.mask_coh&gt;0).values)</span>
    <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml.mask_coh</span>
    <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml.mask</span>
    <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask_coh&#39;]</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">*</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span>
    <span class="c1">#print(&#39;unwrap also residuals from the filtered cpx, and add to the final unw - mask only waters..&#39;)</span>
    <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">origpha</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origcpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_cpx&#39;</span><span class="p">]</span> <span class="c1">#.copy(deep=True)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origcpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxarr</span>
    <span class="k">if</span> <span class="n">add_resid</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;unwrapping residuals and adding back to the final unw output&#39;</span><span class="p">)</span>
        <span class="c1"># maybe can use this somehow? by yma. i checked and it is correct</span>
        <span class="c1"># delta = np.angle(np.exp(np.complex(0+1j)*( np.angle(ifg_filt) - np.angle(ifg_unfilt))))</span>
        <span class="c1"># delta = np.angle(np.exp(0+1j)*( np.angle(ifg_filt) - np.angle(ifg_unfilt)))</span>
        <span class="c1"># delta = np.angle(np.exp(0+1j)*( pha_filt - pha_unfilt ) )</span>
        <span class="c1"># ifg_unw_unfilt = ifg_unw_filt - delta</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;resid_cpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">origcpx</span> <span class="o">*</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_cpx</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="c1">#* ifg_ml.mask_full</span>
        <span class="n">incpx</span> <span class="o">=</span> <span class="s1">&#39;resid_cpx&#39;</span>
        <span class="c1">#binR = os.path.join(tmpdir,incpx+&#39;.R.bin&#39;)</span>
        <span class="c1">#binI = os.path.join(tmpdir,incpx+&#39;.I.bin&#39;)</span>
        <span class="n">binCPX</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="n">incpx</span><span class="o">+</span><span class="s1">&#39;.cpx.bin&#39;</span><span class="p">)</span>
        <span class="n">outunwbin</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="n">incpx</span><span class="o">+</span><span class="s1">&#39;.unw.bin&#39;</span><span class="p">)</span>
        <span class="n">binfile</span> <span class="o">=</span> <span class="n">outunwbin</span>
        <span class="n">daname</span> <span class="o">=</span> <span class="n">incpx</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span>
        <span class="c1">#</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="n">incpx</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="c1">#.tofile(binR)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="n">incpx</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span> <span class="c1">#.tofile(binI)</span>
        <span class="n">RI2cpx</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">binCPX</span><span class="p">)</span>
        <span class="c1">#main_unwrap(binCPX, bincoh, binmask, outunwbin, width, defomax = defomax/2)</span>
        <span class="c1"># ok, just hold the defomax down - discontinuities are not wanted or expected here</span>
        <span class="n">main_unwrap</span><span class="p">(</span><span class="n">binCPX</span><span class="p">,</span> <span class="n">bincoh</span><span class="p">,</span> <span class="n">binmask</span><span class="p">,</span> <span class="n">outunwbin</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">printout</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">unw1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">binfile</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">unw1</span> <span class="o">=</span> <span class="n">unw1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="c1">#.copy()</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">unw1</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask&#39;]</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask_coh&#39;]</span>
        <span class="c1"># ensure values are correctly surrounded by zeroes - i.e. shifting by points masked away</span>
        <span class="c1"># 2022/02 - actually seems weird to me. skipping. also, i added mask binary to update snaphu cost solution..</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname] - np.nanmedian(ifg_ml[daname].where(ifg_ml.mask_extent==0).values)</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask_full&#39;]</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname] - np.nanmedian(ifg_ml[daname].where(ifg_ml.mask_extent==1).values)</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml[&#39;mask_full&#39;]</span>
        <span class="c1">#nanmed = np.nanmedian(ifg_ml[daname].where(ifg_ml.mask_coh&gt;0).values)</span>
        <span class="n">nanmed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">nanmed</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span><span class="o">*</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_full&#39;</span><span class="p">]</span>
        <span class="c1">#print(&#39;debug - avoiding median correction now, although maybe ok for add_resid: median was {} rad&#39;.format(str(nanmed)))</span>
        <span class="c1">#ifg_ml[daname].values = ifg_ml[daname].values - np.nanmedian(ifg_ml[daname].where(ifg_ml.mask_coh&gt;0).values)</span>
        <span class="c1">#print(&#39;again, masking the final product by gauss coh threshold&#39;)</span>
        <span class="c1">#ifg_ml[daname] = ifg_ml[daname]*ifg_ml.mask_coh</span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="c1">#ifg_ml[&#39;resid_&#39;].plot()</span>
        <span class="c1">#now the unw will have the residual phase added back</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="n">daname</span><span class="p">]</span>
    <span class="c1">#if gacoscorr:</span>
    <span class="c1">#    #we have removed GACOS estimate from unw, now time to add it back!</span>
    <span class="c1">#    ifg_ml[&#39;unw&#39;] = ifg_ml[&#39;unw&#39;] + ifg_ml[&#39;gacos&#39;]</span>
    <span class="c1"># add back what we have removed before..</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span>
    <span class="c1">#mask it</span>
    <span class="c1">#ifg_ml[&#39;unw&#39;] = ifg_ml[&#39;unw&#39;].where(ifg_ml.mask&gt;0)</span>
    <span class="c1"># ok ok.... let&#39;s mask by the gauss mask.. although, can be quite missing lot of areas</span>
    <span class="c1">#ifg_ml[&#39;unw&#39;] = ifg_ml[&#39;unw&#39;].where(ifg_ml.mask_coh&gt;0)</span>
    <span class="c1"># hmmm... just to make it nicer...</span>
    <span class="c1">#ifg_ml[&#39;unw&#39;] = ifg_ml[&#39;unw&#39;].where(ifg_ml.mask&gt;0)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># but this may be wrong!</span>
    <span class="c1"># 2022-04-04 - ok, but gacos and some other corrections based on model would bring full shift,</span>
    <span class="c1"># including the one already inside range offsets during coreg. so we should indeed shift by median:</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">rampit</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw_orig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">filter_nan_gaussian_conserving</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">trunc</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_extent</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#else:</span>
    <span class="c1">#    ifg_ml[&#39;unw&#39;] = ifg_ml[&#39;unw&#39;].where(ifg_ml.mask_full&gt;0)</span>
    <span class="c1"># finally clip again, without border pixels:</span>
    <span class="k">if</span> <span class="n">cliparea_geo</span><span class="p">:</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lon</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">),</span> <span class="n">lat</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">add_resid</span><span class="p">:</span>
        <span class="c1"># 2022-04-04 - fixing for final residuals - without unwrapping them - in case the unw had some spatially propagating error</span>
        <span class="c1"># BUT ALSO the &#39;weird vertical lines&#39; sometimes induced after snaphu unwrapping. those lines have, however, values very close to 0, but not 0</span>
        <span class="c1"># it generally should not be needed though!</span>
        <span class="k">if</span> <span class="s1">&#39;origpha_noremovals&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="p">:</span>
            <span class="n">residpha</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">wrap2phase</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">origpha_noremovals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tempar_mag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="p">)</span>
            <span class="n">cpxarr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unwcpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_cpx&#39;</span><span class="p">]</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unwcpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxarr</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;resid_final&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">unwcpx</span> <span class="o">*</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">origcpx</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="c1">#* ifg_ml.mask_full</span>
            <span class="c1"># but ignoring the overall shift as we do the median shifting before</span>
            <span class="n">residpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;resid_final&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">medres</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">residpha</span><span class="p">)</span>
        <span class="n">residpha</span> <span class="o">=</span> <span class="n">residpha</span> <span class="o">-</span> <span class="n">medres</span>
        <span class="c1"># ifg_ml[&#39;resid_final&#39;].values = residpha; ifg_ml[&#39;resid_final&#39;].plot(); plt.show()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;final check for residuals: their std is &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">residpha</span><span class="p">)))</span>
        <span class="c1"># ok, so i assume that the unw would not help anymore, so just adding to unw as it is</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">residpha</span>
    <span class="c1"># now, we may need to save without gacos itself:</span>
    <span class="k">if</span> <span class="n">subtract_gacos</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;gacos&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">median</span><span class="p">())</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">outtif</span><span class="p">:</span>
        <span class="c1">#ifg_ml.pha.fillna(0).where(ifg_ml.mask_coh.where(ifg_ml.mask == 1).fillna(1) == 1)</span>
        <span class="c1">#ifg_ml[&#39;unw&#39;].to_netcdf(outtif+&#39;.nc&#39;)</span>
        <span class="n">toexp</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">export_xr2tif</span><span class="p">(</span><span class="n">toexp</span><span class="p">,</span> <span class="n">outtif</span><span class="p">)</span>
        <span class="c1">#toexp.values = np.flipud(toexp.values)</span>
        <span class="c1"># this does not work, probably due to multilooking... yikes</span>
        <span class="c1">#ifg_ml[&#39;unw&#39;].to_netcdf(outtif+&#39;.nc&#39;)</span>
        <span class="c1">#rc = os.system(&#39;gmt grdconvert -G{0}=gd:GTiff -R{1} {0}.nc&#39;.format(outtif, ifg_pha_file))</span>
        <span class="c1">#rc = os.system(&#39;source {0}/lib/LiCSAR_bash_lib.sh; create_preview_unwrapped {1} {2}&#39;.format(os.environ[&#39;LiCSARpath&#39;], outtif, frame))</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;source </span><span class="si">{0}</span><span class="s1">/lib/LiCSAR_bash_lib.sh; create_preview_unwrapped </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSARpath&#39;</span><span class="p">],</span> <span class="n">outtif</span><span class="p">))</span>
        <span class="c1">#try:</span>
        <span class="c1">#    os.remove(outtif+&#39;.nc&#39;)</span>
        <span class="c1">#except:</span>
        <span class="c1">#    print(&#39;ERROR removing the nc file - something wrong with export&#39;)</span>
    <span class="k">return</span> <span class="n">ifg_ml</span></div>


<div class="viewcode-block" id="process_frame"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.process_frame">[docs]</a><span class="k">def</span> <span class="nf">process_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">thres</span> <span class="o">=</span> <span class="mf">0.35</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cascade</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
            <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">pairsetfile</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
            <span class="n">export_to_tif</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dolocal</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">use_amp_stab</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">use_coh_stab</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main function to process whole LiCSAR frame (i.e. unwrap all available interferograms within the frame). Works only at JASMIN.</span>

<span class="sd">    Args:</span>
<span class="sd">        frame (string): LiCSAR frame ID</span>
<span class="sd">        ml (int): multilooking factor used to reduce the interferogram in lon/lat</span>
<span class="sd">        thres (float): threshold between 0-1 for gaussian-based coherence-like measure (spatial phase consistence?); higher number - more is masked prior to unwrapping</span>
<span class="sd">        smooth (boolean): switch to use extra Gaussian filtering for 2-pass unwrapping</span>
<span class="sd">        cascade (boolean): switch to perform cascade unwrapping</span>
<span class="sd">        </span>
<span class="sd">        hgtcorr (boolean): switch to perform correction for height-phase correlation</span>
<span class="sd">        gacoscorr (boolean): switch to apply GACOS corrections (if detected)</span>
<span class="sd">        </span>
<span class="sd">        cliparea_geo (string or None): use GMT/LiCSBAS string to identify area to clip, in geo-coordinates: e.g. ``&#39;lon1/lon2/lat1/lat2&#39;``</span>
<span class="sd">        pairsetfile (string or None): path to file containing list of pairs to unwrap</span>
<span class="sd">        export_to_tif (boolean): switch to export unwrapped data to geotiffs (default: False, generate only binaries, as used by LiCSBAS)</span>
<span class="sd">        subtract_gacos (boolean): switch whether to return the interferograms with GACOS being subtracted (by default, GACOS is used only to support unwrapping and would be added back)</span>
<span class="sd">        nproc (int): use multiprocessing (one core per interferogram), not well tested, uses pathos</span>
<span class="sd">        dolocal (boolean): switch to use local directory to find interferograms, rather than search for LiCSAR_public directory in JASMIN</span>
<span class="sd">        </span>
<span class="sd">        use_amp_stab (boolean): apply amplitude stability index instead of coherence-per-interferogram for unwrapping</span>
<span class="sd">        use_coh_stab (boolean): apply (experimental) coherence stability index. not recommended (seems not logical to me) - worth investigating though (maybe helps against loop closure errors)</span>
<span class="sd">        keep_coh_debug (boolean): only in combination with use_coh_stab - whether or not to keep original (downsampled) ifg coherence after using the coh_stab to weight the phase during multilooking</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: multilooked interferogram with additional layers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#if cascade and ml&gt;1:</span>
    <span class="c1">#    print(&#39;error - the cascade approach is ready only for ML1&#39;)</span>
    <span class="c1">#    return False</span>
    <span class="c1">#the best to run in directory named by the frame id</span>
    <span class="n">pubdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">]</span>
    <span class="n">geoframedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pubdir</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">])),</span><span class="n">frame</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dolocal</span><span class="p">:</span>
        <span class="n">geoifgdir</span> <span class="o">=</span> <span class="s1">&#39;GEOC&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR: the GEOC directory does not exist, cancelling&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">geoifgdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;interferograms&#39;</span><span class="p">)</span>
    <span class="n">inputifgdir</span> <span class="o">=</span> <span class="n">geoifgdir</span>
    <span class="n">hgtfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;metadata&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.hgt.tif&#39;</span><span class="p">)</span>
    <span class="n">raster</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">)</span>
    <span class="n">framewid</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterXSize</span>
    <span class="n">framelen</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterYSize</span>
    <span class="c1">#if cliparea_geo:</span>
    <span class="c1">#    import rioxarray as rio</span>
    <span class="c1">#    hgt = xr.open_dataarray(hgtfile)</span>
    <span class="n">cohratio</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">use_amp_stab</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calculating amplitude stability&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ampstabfile</span> <span class="o">=</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;_ampstab.nc&#39;</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ampstabfile</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;using existing ampstabfile&#39;</span><span class="p">)</span>
                <span class="n">ampstab</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataarray</span><span class="p">(</span><span class="n">ampstabfile</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ampavg</span><span class="p">,</span> <span class="n">ampstd</span> <span class="o">=</span> <span class="n">build_amp_avg_std</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
                <span class="n">ampstab</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ampstd</span><span class="o">/</span><span class="n">ampavg</span>
                <span class="n">ampstab</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ampstab</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
                <span class="n">ampstab</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">ampstabfile</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error happened, disabling use of amplitude stability&#39;</span><span class="p">)</span>
            <span class="n">use_amp_stab</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">use_coh_stab</span><span class="p">:</span>
        <span class="n">cohstabdays</span> <span class="o">=</span> <span class="mi">12</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calculating coherence stability, using only </span><span class="si">{}</span><span class="s1"> days coherences&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cohstabdays</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cohratiofile</span> <span class="o">=</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;_cohratio.nc&#39;</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cohratiofile</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;using existing cohratiofile&#39;</span><span class="p">)</span>
                <span class="n">cohratio</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataarray</span><span class="p">(</span><span class="n">cohratiofile</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cohavg</span><span class="p">,</span> <span class="n">cohstd</span> <span class="o">=</span> <span class="n">build_coh_avg_std</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">days</span> <span class="o">=</span> <span class="n">cohstabdays</span><span class="p">,</span> <span class="n">monthly</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
                <span class="c1"># ok, original coh_stab = 1 - coh_dispersion, i.e.:</span>
                <span class="n">cohratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cohstd</span><span class="o">/</span><span class="n">cohavg</span>
                <span class="n">cohratio</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">cohratio</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;storing DQ=1-cohstd/cohavg to &#39;</span><span class="o">+</span><span class="n">cohratiofile</span><span class="p">)</span>
                <span class="n">cohratio</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">cohratiofile</span><span class="p">)</span>
                <span class="c1"># but i want now to have it logarithmic, so:</span>
                <span class="c1">#cohratio = cohavg/cohstd</span>
                <span class="c1">#hmm... not really any difference. so using the orig way</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error happened, disabling use of coh stability&#39;</span><span class="p">)</span>
            <span class="n">use_coh_stab</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">pairset</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">pairsetfile</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pairset</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">pairsetfile</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">pairset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pairset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error loading pairset, doing all&#39;</span><span class="p">)</span>
            <span class="n">pairset</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pairset</span><span class="p">:</span>
        <span class="n">pairset</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">inputifgdir</span><span class="p">)</span>
    <span class="c1"># functions for multiprocessing</span>
    <span class="k">def</span> <span class="nf">check_and_process_ifg</span><span class="p">(</span><span class="n">pair</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#check its dimensions..</span>
            <span class="n">raster</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">framewid</span> <span class="o">!=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">framelen</span> <span class="o">!=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">):</span>
                <span class="c1">#use tolerance of max pixels</span>
                <span class="n">maxpixels</span> <span class="o">=</span> <span class="mi">4</span>
                <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">framewid</span> <span class="o">-</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxpixels</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">framelen</span> <span class="o">-</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxpixels</span><span class="p">)):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR - the file </span><span class="si">{}</span><span class="s1"> has unexpected dimensions, skipping&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)))</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR - the file </span><span class="si">{}</span><span class="s1"> has unexpected dimensions, trying to fix&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">tif</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.*.tif&#39;</span><span class="p">)):</span>
                        <span class="n">outfile</span> <span class="o">=</span> <span class="n">tif</span><span class="o">+</span><span class="s1">&#39;.tmp.tif&#39;</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">filedone</span> <span class="o">=</span> <span class="n">reproject_to_match</span><span class="p">(</span><span class="n">tif</span><span class="p">,</span> <span class="n">hgtfile</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">outfile</span><span class="p">):</span>
                                <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">tif</span><span class="p">)</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;something wrong during reprojection, skipping&#39;</span><span class="p">)</span>
                            <span class="c1">#continue</span>
                            <span class="k">return</span> <span class="kc">False</span>
                    <span class="c1">#os.system(&#39;gmt grdsample {0} -G{1}&#39;)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">raster</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">framewid</span> <span class="o">!=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">framelen</span> <span class="o">!=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR - the file </span><span class="si">{}</span><span class="s1"> has unexpected dimensions, skipping&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)))</span>
                    <span class="c1">#continue</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error processing file </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)))</span>
                <span class="c1">#continue</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;processing pair &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">export_to_tif</span><span class="p">:</span>
                    <span class="n">outtif</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outtif</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cascade</span><span class="p">:</span>
                        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">cascade_unwrap</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">downtoml</span> <span class="o">=</span> <span class="n">ml</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">outtif</span> <span class="o">=</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span> <span class="n">dolocal</span><span class="o">=</span><span class="n">dolocal</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span>
                        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">ml</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> 
                                 <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">cohratio</span> <span class="o">=</span> <span class="n">cohratio</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span>
                                 <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="n">keep_coh_debug</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="n">gacoscorr</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span>
                                 <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">unw</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">)</span>
                    <span class="p">((</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.cc&#39;</span><span class="p">)</span>
                    <span class="c1"># export </span>
                    <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
                    <span class="n">create_preview_bin</span><span class="p">(</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">ftype</span> <span class="o">=</span> <span class="s1">&#39;unw&#39;</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm &#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw.ras&#39;</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -r &#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="s1">&#39;temp_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ml</span><span class="p">))</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -r &#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="s1">&#39;temp_gen&#39;</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR processing of pair &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -r &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error occured and the unw was not processed&#39;</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -r &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
    <span class="k">def</span> <span class="nf">fix_additionals</span><span class="p">():</span>
        <span class="n">mlipar</span> <span class="o">=</span> <span class="s1">&#39;slc.mli.par&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">mlipar</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">mlipar</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;range_samples: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;azimuth_lines: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;radar_frequency: 5405000000.0 Hz</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;hgt&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;hgt&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="p">:</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="s1">&#39;hgt&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;EQA.dem_par&#39;</span><span class="p">):</span>
            <span class="n">post_lon</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">post_lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">cor_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">cor_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
            <span class="n">create_eqa_file</span><span class="p">(</span><span class="s1">&#39;EQA.dem_par&#39;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">),</span><span class="n">cor_lat</span><span class="p">,</span><span class="n">cor_lon</span><span class="p">,</span><span class="n">post_lat</span><span class="p">,</span><span class="n">post_lon</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nproc</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pathos.multiprocessing</span> <span class="k">import</span> <span class="n">ProcessingPool</span> <span class="k">as</span> <span class="n">Pool</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pathos not installed - not parallelism&#39;</span><span class="p">)</span>
            <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">nproc</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">nproc</span><span class="p">)</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">check_and_process_ifg</span><span class="p">,</span> <span class="n">pairset</span><span class="p">)</span>  <span class="c1"># out is one output per pair -&gt; list</span>
            <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>  <span class="c1"># or not?</span>
            <span class="n">fix_additionals</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error appeared - please try manually (debug). now, just returning to no parallelism&#39;</span><span class="p">)</span>
            <span class="n">nproc</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">nproc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">pairset</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)):</span>
                <span class="c1">#check its dimensions..</span>
                <span class="n">raster</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">framewid</span> <span class="o">!=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">framelen</span> <span class="o">!=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">):</span>
                    <span class="c1">#use tolerance of max pixels</span>
                    <span class="n">maxpixels</span> <span class="o">=</span> <span class="mi">4</span>
                    <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">framewid</span> <span class="o">-</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxpixels</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">framelen</span> <span class="o">-</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxpixels</span><span class="p">)):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR - the file </span><span class="si">{}</span><span class="s1"> has unexpected dimensions, skipping&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)))</span>
                        <span class="k">continue</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR - the file </span><span class="si">{}</span><span class="s1"> has unexpected dimensions, trying to fix&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">tif</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.*.tif&#39;</span><span class="p">)):</span>
                        <span class="n">outfile</span> <span class="o">=</span> <span class="n">tif</span><span class="o">+</span><span class="s1">&#39;.tmp.tif&#39;</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">filedone</span> <span class="o">=</span> <span class="n">reproject_to_match</span><span class="p">(</span><span class="n">tif</span><span class="p">,</span> <span class="n">hgtfile</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">outfile</span><span class="p">):</span>
                                <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="n">tif</span><span class="p">)</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;something wrong during reprojection, skipping&#39;</span><span class="p">)</span>
                            <span class="k">continue</span>
                        <span class="c1">#os.system(&#39;gmt grdsample {0} -G{1}&#39;)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">raster</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">))</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">framewid</span> <span class="o">!=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">framelen</span> <span class="o">!=</span> <span class="n">raster</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR - the file </span><span class="si">{}</span><span class="s1"> has unexpected dimensions, skipping&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)))</span>
                        <span class="k">continue</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error processing file </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoifgdir</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">)))</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">)):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;processing pair &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">export_to_tif</span><span class="p">:</span>
                        <span class="n">outtif</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">outtif</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">cascade</span><span class="p">:</span>
                            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">cascade_unwrap</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">downtoml</span> <span class="o">=</span> <span class="n">ml</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">outtif</span> <span class="o">=</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span> <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span>
                            <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">process_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">ml</span> <span class="o">=</span> <span class="n">ml</span><span class="p">,</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="n">hgtcorr</span><span class="p">,</span> <span class="n">fillby</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> 
                                     <span class="n">thres</span> <span class="o">=</span> <span class="n">thres</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">add_resid</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">outtif</span> <span class="o">=</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">cohratio</span> <span class="o">=</span> <span class="n">cohratio</span><span class="p">,</span> 
                                     <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="n">keep_coh_debug</span><span class="p">,</span> <span class="n">gacoscorr</span> <span class="o">=</span> <span class="n">gacoscorr</span><span class="p">,</span> <span class="n">cliparea_geo</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="p">,</span>
                                     <span class="n">subtract_gacos</span> <span class="o">=</span> <span class="n">subtract_gacos</span><span class="p">,</span> <span class="n">dolocal</span> <span class="o">=</span> <span class="n">dolocal</span><span class="p">,</span> <span class="n">smooth</span> <span class="o">=</span> <span class="n">smooth</span><span class="p">)</span>
                        <span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">unw</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask_full</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">)</span>
                        <span class="p">((</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.cc&#39;</span><span class="p">)</span>
                        <span class="c1"># export </span>
                        <span class="n">mlipar</span> <span class="o">=</span> <span class="s1">&#39;slc.mli.par&#39;</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">mlipar</span><span class="p">):</span>
                            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">mlipar</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;range_samples: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;azimuth_lines: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;radar_frequency: 5405000000.0 Hz</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;hgt&#39;</span><span class="p">):</span>
                            <span class="k">if</span> <span class="s1">&#39;hgt&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="p">:</span>
                                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="s1">&#39;hgt&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s1">&#39;EQA.dem_par&#39;</span><span class="p">):</span>
                            <span class="n">post_lon</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
                            <span class="n">post_lat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
                            <span class="n">cor_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
                            <span class="n">cor_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">6</span><span class="p">)</span>
                            <span class="n">create_eqa_file</span><span class="p">(</span><span class="s1">&#39;EQA.dem_par&#39;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">),</span><span class="n">cor_lat</span><span class="p">,</span><span class="n">cor_lon</span><span class="p">,</span><span class="n">post_lat</span><span class="p">,</span><span class="n">post_lon</span><span class="p">)</span>
                        <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
                        <span class="n">create_preview_bin</span><span class="p">(</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">ftype</span> <span class="o">=</span> <span class="s1">&#39;unw&#39;</span><span class="p">)</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -r &#39;</span><span class="o">+</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;/&#39;</span><span class="o">+</span><span class="s1">&#39;temp_*&#39;</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR processing of pair &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -r &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span><span class="n">pair</span><span class="o">+</span><span class="s1">&#39;.unw&#39;</span><span class="p">)):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error occured and the unw was not processed&#39;</span><span class="p">)</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm -r &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span></div>



<div class="viewcode-block" id="multilook_normalised"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.multilook_normalised">[docs]</a><span class="k">def</span> <span class="nf">multilook_normalised</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">ml</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">pre_detrend</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">prev_ramp</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">thres_pxcount</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keep_coh_debug</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multilooking function that does much more.</span>
<span class="sd">    </span>
<span class="sd">    This function is normally called by process_ifg. It would use coherence as weights to multilook interferometric phase, and downsample other layers if available to a final datacube.</span>
<span class="sd">    It will apply mask, including based on number of valid pixels in the multilooking window.</span>
<span class="sd">    It will also apply Gaussian filter, mainly to get the Gaussian-based coherence-like measure (used no matter if smooth is ON).</span>

<span class="sd">    Args:</span>
<span class="sd">        ifg (xarray.Dataset): xarray dataset containing interferogram layers, mainly cpx for complex numbers interferogram</span>
<span class="sd">        ml (int): multilooking factor used to reduce the interferogram in both x/y or lon/lat</span>
<span class="sd">        tmpdir (string): path to temporary directory</span>
<span class="sd">        hgtcorr (boolean): switch to perform correction for height-phase correlation</span>
<span class="sd">        pre_detrend (boolean): switch to perform detrending of phase</span>
<span class="sd">        prev_ramp (xarray.DataArray): a previous (ramp) estimate. it can be of different dimensions as it would get interpolated</span>
<span class="sd">        thres_pxcount (int or None): by default, we nullify multilooked pixel that has less than 4/5 non-nan input values. You may change this, e.g. if ml=10, apply thres_pxcount=90 for keeping only pixel with over 9/10 values</span>
<span class="sd">        keep_coh_debug (boolean): for experiments, this would keep the original interferogram coherence instead of use average coherence or amplitude stability etc. for weighting</span>

<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: multilooked interferogram with additional layers</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#landmask it and multilook it</span>
    <span class="k">if</span> <span class="n">ml</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># that&#39;s for multilooking - in case of cohratio, we want to only weight phases based on that, and then return to coh</span>
        <span class="n">bagcpx</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">bagcpx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">bagcpx</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>   <span class="c1"># this really equals np.nanmean, or, bagcpx.mean() - same result</span>
        <span class="c1"># if we use coh instead of amplitude, it may get underestimated after ML (as found by Jack McG.), so just averaging it here:</span>
        <span class="c1">#if type(ml_weights) != type(None):</span>
        <span class="n">bagcoh</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[[</span><span class="s1">&#39;coh&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span>
        <span class="c1">#coh_ml = bagcoh.sum() / bagcoh.count()</span>
        <span class="n">coh_ml</span> <span class="o">=</span> <span class="n">bagcoh</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">coh_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># non-nan px count per window</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pxcount&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pxcount&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">bagcpx</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">cpx</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>    <span class="c1"># to use later - evaluate bad ML data, e.g. mask those pxls</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">ifg</span><span class="p">[[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span>
    <span class="c1">#downsample mask</span>
    <span class="k">if</span> <span class="n">ml</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_extent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">mask_extent</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;gacos&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">gacos</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># or median?</span>
        <span class="k">if</span> <span class="s1">&#39;hgt&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">hgt</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">ml</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;trim&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask_extent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">mask_extent</span>
        <span class="k">if</span> <span class="s1">&#39;gacos&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">gacos</span>
        <span class="k">if</span> <span class="s1">&#39;hgt&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">hgt</span>
    <span class="c1">#keep the original original pha values</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha_noremovals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span> <span class="c1">#.copy(deep=True)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;origpha_noremovals&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="p">)</span> <span class="c1">#.copy(deep=True)</span>
    <span class="c1">#prepare &#39;toremove&#39; layer</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="p">)</span> <span class="c1"># just make them zeroes</span>
    <span class="k">if</span> <span class="n">keep_coh_debug</span><span class="p">:</span>
        <span class="c1">#ok, return coh, phase back to cpx</span>
        <span class="n">cpxa</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">origpha_noremovals</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxa</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#print(&#39;debug: trying to use the cohratio rather than current coh. maybe wrong?&#39;)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;orig_coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">])</span>
    <span class="c1">#remove previous estimates</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">prev_ramp</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">lat</span><span class="p">)</span>
        <span class="c1">#prev_width = len(prev_ramp.lon)</span>
        <span class="c1">#prev_length = len(prev_ramp.lat)</span>
        <span class="n">prev_ramp</span> <span class="o">=</span> <span class="n">prev_ramp</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">resized</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">prev_ramp</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">dsize</span><span class="o">=</span><span class="p">(</span><span class="n">width</span><span class="p">,</span><span class="n">length</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">)</span> <span class="c1">#or INTER_CUBIC ?</span>
        <span class="c1"># if gacos is to be applied, need to remove its effect first here:</span>
        <span class="k">if</span> <span class="s1">&#39;gacos&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">resized</span> <span class="o">=</span> <span class="n">resized</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">resized</span>
        <span class="c1"># apply the correction - wrapping it and conjugate in complex realm</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">resized</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">correction</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">resized</span><span class="p">)</span>
        <span class="n">cpx_corr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">correction</span><span class="p">)</span>
        <span class="c1">#a trick to apply the correction only to non-nan values.. &#39;other&#39;</span>
        <span class="c1">#da = da.where(xrda.isnull(), other=da.values * np.conjugate(cpx_corr))</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">cpx_corr</span><span class="p">)</span>
        <span class="n">resized</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">pre_detrend</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no need to detrend if prev_ramp is here, cancelling to avoid extra noise&#39;</span><span class="p">)</span>
            <span class="n">pre_detrend</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="p">)</span>
    <span class="c1">#if type(ml_weights) == type(None):</span>
    <span class="c1">#    #have the orig coh here:</span>
    <span class="c1">#    ifg_ml[&#39;coh&#39;] = ifg_ml[&#39;pha&#39;]</span>
    <span class="c1">#    ifg_ml.coh.values = np.abs(ifg_ml.cpx)</span>
    <span class="c1">#have gacos removed first, prior to doing height corr:</span>
    <span class="k">if</span> <span class="s1">&#39;gacos&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39; removing this check, because we want to FORCE-apply GACOS.. otherwise we get loop closure errors...</span>
<span class="sd">        pha_no_gacos = wrap2phase(ifg_ml[&#39;pha&#39;] - ifg_ml[&#39;gacos&#39;])</span>
<span class="sd">        #if np.nanstd(pha_no_gacos) &gt;= np.nanstd(ifg_ml.pha.values):</span>
<span class="sd">        if get_fft_std(pha_no_gacos) &gt;= get_fft_std(ifg_ml[&#39;pha&#39;].values):</span>
<span class="sd">            print(&#39;GACOS correction would increase overall phase std - dropping&#39;)</span>
<span class="sd">            #ifg_ml = ifg_ml.drop(&#39;gacos&#39;)</span>
<span class="sd">        else:</span>
<span class="sd">            ifg_ml[&#39;pha&#39;].values = pha_no_gacos</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">])</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gacos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1">#ok, return coh, phase back to cpx</span>
        <span class="n">cpxa</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxa</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">pre_detrend</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">],</span> <span class="n">correction</span> <span class="o">=</span> <span class="n">detrend_ifg_xr</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">],</span> <span class="n">isphase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_correction</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="p">)</span>
        <span class="c1">#ifg_ml[&#39;pha&#39;] = ifg_ml[&#39;pha&#39;].where(ifg_ml.mask&gt;0)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">correction</span>
    <span class="c1">#</span>
    <span class="c1"># just mask it</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="s1">&#39;hgt&#39;</span> <span class="ow">in</span> <span class="n">ifg</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># perform Gaussian filtering</span>
    <span class="c1">#ifg_ml = filter_ifg_ml(ifg_ml)</span>
    <span class="c1">#now fix the correlation with heights:</span>
    <span class="k">if</span> <span class="n">hgtcorr</span><span class="p">:</span>
        <span class="c1">#ifg_ml[&#39;toremove&#39;] = ifg_ml[&#39;toremove&#39;] + </span>
        <span class="c1"># dounw=False may be faster!</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calculating correlation with DEM&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">toremove_hgt</span> <span class="o">=</span> <span class="n">remove_height_corr</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">,</span> <span class="n">dounw</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">nonlinear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">pha_no_hgt</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">toremove_hgt</span><span class="p">)</span>
            <span class="n">cpx_no_hgt</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">pha_no_hgt</span><span class="p">)</span>
            <span class="c1">#if np.nanstd(pha_no_hgt) &gt;= np.nanstd(ifg_ml.pha.values):</span>
            <span class="c1">#    print(&#39;but the correction would increase overall phase std - dropping&#39;)</span>
            <span class="c1">#    hgtcorr = False</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">cpx_no_hgt</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="o">.</span><span class="n">values</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;but the correction would increase overall complex std - dropping&#39;</span><span class="p">)</span>
                <span class="n">hgtcorr</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">toremove_hgt</span>
                <span class="c1"># need to remove hgt only here, as the &#39;toremove&#39; was already removed before..</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">pha_no_hgt</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1">#ok, return coh, phase back to cpx</span>
                <span class="n">cpxa</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">cpxa</span>
                <span class="k">if</span> <span class="n">pre_detrend</span><span class="p">:</span>
                    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">],</span> <span class="n">correction</span> <span class="o">=</span> <span class="n">detrend_ifg_xr</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">],</span> <span class="n">isphase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_correction</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="p">)</span>
                    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">correction</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;some error trying correlate with DEM. continuing without it&#39;</span><span class="p">)</span>
    <span class="c1"># maybe not the best, but have gacos correction inside the toremove variable</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># oh, ok, also masking pixels with small number of pre-multilooked points (landmasked)</span>
    <span class="k">if</span> <span class="s1">&#39;pxcount&#39;</span> <span class="ow">in</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
        <span class="c1"># try setting to something like 90 if ML10</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">thres_pxcount</span><span class="p">:</span>
            <span class="c1">#thres_pxcount = int(round((ml**2)/2))</span>
            <span class="c1"># if not set, we will auto-set it to mask multilooked pixels with less than 80% input (non-nan) pixels</span>
            <span class="n">thres_pxcount</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">ml</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="o">/</span><span class="mi">5</span><span class="p">))</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span> <span class="o">*</span> <span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pxcount</span> <span class="o">&gt;=</span> <span class="n">thres_pxcount</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#print(&#39;finally, filter using (adapted) gauss filter&#39;)</span>
    <span class="k">if</span> <span class="n">ml</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">calc_coh_from_delta</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># that part takes ages and it is not that big improvement..</span>
        <span class="n">calc_coh_from_delta</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">ifg_ml</span> <span class="o">=</span> <span class="n">filter_ifg_ml</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">calc_coh_from_delta</span> <span class="o">=</span> <span class="n">calc_coh_from_delta</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_coh_debug</span><span class="p">:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;orig_coh&#39;</span><span class="p">]</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ifg_ml</span></div>


<span class="c1">################################################################################</span>
<span class="c1"># Helping functions</span>
<span class="c1">################################################################################</span>

<div class="viewcode-block" id="interpolate_nans"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.interpolate_nans">[docs]</a><span class="k">def</span> <span class="nf">interpolate_nans</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolation of NaN values in a grid</span>

<span class="sd">    Args:</span>
<span class="sd">        array (np.array): numpy array with nans to interpolate</span>
<span class="sd">        method (string): interpolation method for griddata function, e.g. cubic</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: interpolated grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">xx</span><span class="p">[</span><span class="o">~</span><span class="n">array</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">yy</span><span class="p">[</span><span class="o">~</span><span class="n">array</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">newarr</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="o">~</span><span class="n">array</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">GD1</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">griddata</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">newarr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">),</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="n">GD1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">GD1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GD1</span></div>


<div class="viewcode-block" id="runcmd"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.runcmd">[docs]</a><span class="k">def</span> <span class="nf">runcmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">printcmd</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Runs command through os.system</span>

<span class="sd">    Args:</span>
<span class="sd">        cmd (string): command to run</span>
<span class="sd">        printcmd (boolean): if True, will do verbose</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">printcmd</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#with nostdout():</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="o">+</span><span class="s1">&#39; &gt;/dev/null 2&gt;/dev/null&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING - command did not exit as OK&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="magpha2RI_array"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.magpha2RI_array">[docs]</a><span class="k">def</span> <span class="nf">magpha2RI_array</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">pha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts arrays of magnitude and phase to complex number array (real and imaginary)</span>

<span class="sd">    Args:</span>
<span class="sd">        mag (np.array): numpy array with magnitude values</span>
<span class="sd">        pha (np.array): numpy array with phase values</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: complex number array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">pha</span><span class="p">)</span> <span class="o">*</span> <span class="n">mag</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">pha</span><span class="p">)</span> <span class="o">*</span> <span class="n">mag</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">I</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="coh_from_phadiff"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.coh_from_phadiff">[docs]</a><span class="k">def</span> <span class="nf">coh_from_phadiff</span><span class="p">(</span><span class="n">phadiff</span><span class="p">,</span> <span class="n">winsize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates coherence based on variance of interferogram, computed in window with given size</span>

<span class="sd">    Args:</span>
<span class="sd">        phadiff (np.array): interferogram</span>
<span class="sd">        winsize (int): window size</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: coherence based on the variance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variance</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">generic_filter</span><span class="p">(</span><span class="n">phadiff</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">winsize</span><span class="p">)</span>
    <span class="n">outcoh</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">winsize</span><span class="o">*</span><span class="n">winsize</span><span class="o">*</span><span class="n">variance</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">outcoh</span></div>


<div class="viewcode-block" id="filter_cpx_gauss"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.filter_cpx_gauss">[docs]</a><span class="k">def</span> <span class="nf">filter_cpx_gauss</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">trunc</span> <span class="o">=</span> <span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Gaussian-based spatial filter on complex numbers (interferogram)</span>

<span class="sd">    Args:</span>
<span class="sd">        ifg_ml (xr.Dataset): xarray dataset of the interferogram, must contain &#39;cpx&#39; dataarray</span>
<span class="sd">        sigma (int): sigma parameter to gaussian filter</span>
<span class="sd">        trunc (int): trunc parameter to gaussian filter</span>

<span class="sd">    Returns:</span>
<span class="sd">        xr.Dataarray: filtered complex numbers dataarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># tried with R, I separately --- EXACT same result as if using cpx numbers...</span>
    <span class="c1">#R = np.real(ifg_ml.cpx.values)</span>
    <span class="c1">#I = np.imag(ifg_ml.cpx.values)</span>
    <span class="c1">#</span>
    <span class="c1">#gR = filter_nan_gaussian_conserving(R, sigma=sigma, trunc=trunc)</span>
    <span class="c1">#gI = filter_nan_gaussian_conserving(I, sigma=sigma, trunc=trunc)</span>
    <span class="c1">#</span>
    <span class="c1">#gauss_cpx = gR + 1j*gI</span>
    <span class="n">gauss_cpx</span> <span class="o">=</span> <span class="n">filter_nan_gaussian_conserving</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">cpx</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">trunc</span><span class="o">=</span><span class="n">trunc</span><span class="p">)</span>
    <span class="n">gauss_xr</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="n">gauss_xr</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">gauss_cpx</span>
    <span class="k">return</span> <span class="n">gauss_xr</span></div>


<div class="viewcode-block" id="filter_nan_gaussian_conserving"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.filter_nan_gaussian_conserving">[docs]</a><span class="k">def</span> <span class="nf">filter_nan_gaussian_conserving</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">trunc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply a gaussian filter to an array with nans.</span>
<span class="sd">    </span>
<span class="sd">    based on:</span>
<span class="sd">    https://stackoverflow.com/questions/18697532/gaussian-filtering-a-image-with-nan-in-python</span>
<span class="sd">    </span>
<span class="sd">    Intensity is only shifted between not-nan pixels and is hence conserved.</span>
<span class="sd">    The intensity redistribution with respect to each single point</span>
<span class="sd">    is done by the weights of available pixels according</span>
<span class="sd">    to a gaussian distribution.</span>
<span class="sd">    All nans in arr, stay nans in gauss.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        arr (np.array): array of real numbers to filter by Gaussian kernel</span>
<span class="sd">        sigma (int): sigma parameter to gaussian filter</span>
<span class="sd">        trunc (int): trunc parameter to gaussian filter</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.array: filtered real numbers array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nan_msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">loss</span><span class="p">[</span><span class="n">nan_msk</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span>
            <span class="n">loss</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="n">trunc</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gauss</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">gauss</span><span class="p">[</span><span class="n">nan_msk</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">gauss</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span>
            <span class="n">gauss</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="n">trunc</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">gauss</span><span class="p">[</span><span class="n">nan_msk</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">gauss</span> <span class="o">+=</span> <span class="n">loss</span> <span class="o">*</span> <span class="n">arr</span>
    <span class="k">return</span> <span class="n">gauss</span></div>


<div class="viewcode-block" id="create_preview_bin"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.create_preview_bin">[docs]</a><span class="k">def</span> <span class="nf">create_preview_bin</span><span class="p">(</span><span class="n">binfile</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">ftype</span> <span class="o">=</span> <span class="s1">&#39;unw&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use of cpxfiddle to create simple preview PNG rasters from binary files</span>

<span class="sd">    Args:</span>
<span class="sd">        binfile (string): path to the binary file to generate preview from</span>
<span class="sd">        width (int): width of the binary file</span>
<span class="sd">        ftype (string): filetype. Supported types: unw, pha, coh, mag</span>

<span class="sd">    Returns:</span>
<span class="sd">        string: filename of the generated preview png file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;unw&#39;</span><span class="p">:</span>
        <span class="n">q</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span>
        <span class="n">f</span><span class="o">=</span><span class="s1">&#39;r4&#39;</span>
        <span class="n">c</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span>
        <span class="n">r</span><span class="o">=</span><span class="s1">&#39;-r -20,20&#39;</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;pha&#39;</span><span class="p">:</span>
        <span class="n">q</span><span class="o">=</span><span class="s1">&#39;phase&#39;</span>
        <span class="n">f</span><span class="o">=</span><span class="s1">&#39;cr4&#39;</span>
        <span class="n">c</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;coh&#39;</span><span class="p">:</span>
        <span class="n">q</span><span class="o">=</span><span class="s1">&#39;normal&#39;</span>
        <span class="n">f</span><span class="o">=</span><span class="s1">&#39;r4&#39;</span>
        <span class="n">c</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span>
        <span class="n">r</span><span class="o">=</span><span class="s1">&#39;-r 0,1&#39;</span>
    <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;mag&#39;</span><span class="p">:</span>
        <span class="n">q</span><span class="o">=</span><span class="s1">&#39;mag&#39;</span>
        <span class="n">f</span><span class="o">=</span><span class="s1">&#39;cr4&#39;</span>
        <span class="n">c</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;wrong ftype - choose one of: unw,pha,coh,mag&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="n">binfile</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span>
    <span class="n">runcmd</span><span class="p">(</span><span class="s1">&#39;cpxfiddle -w </span><span class="si">{0}</span><span class="s1"> -o sunraster -q </span><span class="si">{1}</span><span class="s1"> -f </span><span class="si">{2}</span><span class="s1"> -c </span><span class="si">{3}</span><span class="s1"> </span><span class="si">{4}</span><span class="s1"> </span><span class="si">{5}</span><span class="s1"> &gt; </span><span class="si">{6}</span><span class="s1"> 2&gt;/dev/null&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">width</span><span class="p">),</span> <span class="n">q</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">binfile</span><span class="p">,</span> <span class="n">binfile</span><span class="o">+</span><span class="s1">&#39;.ras&#39;</span><span class="p">))</span>
    <span class="n">runcmd</span><span class="p">(</span><span class="s1">&#39;convert -resize 700x </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">binfile</span><span class="o">+</span><span class="s1">&#39;.ras&#39;</span><span class="p">,</span><span class="n">outfile</span><span class="p">))</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;rm </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">binfile</span><span class="o">+</span><span class="s1">&#39;.ras&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">outfile</span></div>


<span class="k">try</span><span class="p">:</span>
<div class="viewcode-block" id="resize_bin"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.resize_bin">[docs]</a>    <span class="k">def</span> <span class="nf">resize_bin</span><span class="p">(</span><span class="n">inbin</span><span class="p">,</span> <span class="n">inwid</span><span class="p">,</span> <span class="n">inlen</span><span class="p">,</span> <span class="n">outbin</span><span class="p">,</span> <span class="n">outwid</span><span class="p">,</span> <span class="n">outlen</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">,</span> <span class="n">intertype</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_NEAREST</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use of cv2 to interpolate/resize binary file to new dimensions</span>

<span class="sd">        Args:</span>
<span class="sd">            inbin (string): path to the binary file</span>
<span class="sd">            inwid (int): width of the input binary file</span>
<span class="sd">            inlen (int): length of the input binary file</span>
<span class="sd">            outbin (string): path to the output binary file</span>
<span class="sd">            outwid (int): target width of the output binary file</span>
<span class="sd">            outlen (int): target length of the output binary file</span>
<span class="sd">            dtype (string): data type of the binary, e.g. np.byte</span>
<span class="sd">            intertype (string): type of interpolation for cv2, e.g. cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">inbin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">inlen</span><span class="p">,</span> <span class="n">inwid</span><span class="p">)</span>
        <span class="c1">#use cv2.INTER_CUBIC for upsample np.float32 data ...</span>
        <span class="c1">#a = a - np.nanmedian(a)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">dsize</span><span class="o">=</span><span class="p">(</span><span class="n">outwid</span><span class="p">,</span><span class="n">outlen</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">intertype</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">outbin</span><span class="p">)</span>
        <span class="k">return</span></div>
<span class="k">except</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error loading resize_bin function - cascade will not work (install cv2)&#39;</span><span class="p">)</span>



<div class="viewcode-block" id="RI2cpx"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.RI2cpx">[docs]</a><span class="k">def</span> <span class="nf">RI2cpx</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">cpxfile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert real and imaginary binary files to a complex number binary file. Obsolete function.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        R (string): path to the binary file with real values</span>
<span class="sd">        I (string): path to the binary file with imaginary values</span>
<span class="sd">        cpxfile (string): path to the binary file for complex output</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># we may either load R, I from file:</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;str&#39;</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">cpx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="n">cpx</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
    <span class="n">cpx</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
    <span class="n">cpx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">cpxfile</span><span class="p">)</span></div>


<div class="viewcode-block" id="remove_islands"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.remove_islands">[docs]</a><span class="k">def</span> <span class="nf">remove_islands</span><span class="p">(</span><span class="n">npa</span><span class="p">,</span> <span class="n">pixelsno</span> <span class="o">=</span> <span class="mi">50</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Removes isolated clusters of pixels from numpy array npa having less than pixelsno pixels.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        npa (np.array): (unwrapped) interferogram with NaNs</span>
<span class="sd">        pixelsno (int): minimum number of pixels in isolated clusters (connected components)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        np.array: array after removing islands</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#check the mask - should be 1 for islands and 0 for nans</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">npa</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span>
    <span class="n">islands</span><span class="p">,</span> <span class="n">ncomp</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncomp</span><span class="p">):</span>
        <span class="c1">#island = islands == i # need to get this one right</span>
        <span class="c1">#island = npa[islands==i]</span>
        <span class="n">numofpixels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">islands</span><span class="o">==</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">numofpixels</span> <span class="o">&lt;</span> <span class="n">pixelsno</span><span class="p">:</span>
            <span class="n">npa</span><span class="p">[</span><span class="n">islands</span><span class="o">==</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">npa</span></div>


<div class="viewcode-block" id="main_unwrap"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.main_unwrap">[docs]</a><span class="k">def</span> <span class="nf">main_unwrap</span><span class="p">(</span><span class="n">cpxbin</span><span class="p">,</span> <span class="n">cohbin</span><span class="p">,</span> <span class="n">maskbin</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">outunwbin</span> <span class="o">=</span> <span class="s1">&#39;unwrapped.bin&#39;</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">est</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bin_pre_remove</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span> <span class="n">printout</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Main function to perform unwrapping with snaphu.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        cpxbin (string): path to cpxfloat32 binary interferogram to unwrap</span>
<span class="sd">        cohbin (string): path to float32 binary for coherence</span>
<span class="sd">        maskbin (string or None): path to mask binary</span>
<span class="sd">        outunwbin (string): path to output unwrapped binary</span>
<span class="sd">        width (int): width of binary raster</span>
<span class="sd">        est (string or None): path to coarse estimate binary (float32)</span>
<span class="sd">        bin_pre_remove (string or None): path to float32 binary to remove from est, prior to unwrapping</span>
<span class="sd">        defomax (float): max defo cycles</span>
<span class="sd">        printout (boolean): controls verbosity of text output</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error - width is zero&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">bin_pre_remove</span> <span class="ow">and</span> <span class="n">est</span><span class="p">:</span>
        <span class="c1"># we will remove phase from the est, prior to processing</span>
        <span class="n">est_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">est</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">est_rem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">bin_pre_remove</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">est_np</span> <span class="o">=</span> <span class="n">est_np</span> <span class="o">-</span> <span class="n">est_rem</span>
        <span class="n">est_np</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">est</span><span class="p">)</span>
        <span class="n">est_np</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">est_rem</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">printout</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;processing by snaphu&#39;</span><span class="p">)</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">cpxbin</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;/&#39;</span>
    <span class="n">snaphuconffile</span> <span class="o">=</span> <span class="n">make_snaphu_conf</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">defomax</span><span class="p">)</span>
    <span class="n">extracmd</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">est</span><span class="p">:</span>
        <span class="n">extracmd</span> <span class="o">=</span> <span class="s2">&quot;-e </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">est</span><span class="p">)</span>
    <span class="n">starttime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">maskbin</span><span class="p">:</span>
        <span class="n">snaphucmd</span> <span class="o">=</span> <span class="s1">&#39;snaphu -f </span><span class="si">{0}</span><span class="s1"> -o </span><span class="si">{1}</span><span class="s1"> -c </span><span class="si">{2}</span><span class="s1"> </span><span class="si">{3}</span><span class="s1"> </span><span class="si">{4}</span><span class="s1"> </span><span class="si">{5}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">snaphuconffile</span><span class="p">,</span> <span class="n">outunwbin</span><span class="p">,</span> <span class="n">cohbin</span><span class="p">,</span> <span class="n">extracmd</span><span class="p">,</span> <span class="n">cpxbin</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">width</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">snaphucmd</span> <span class="o">=</span> <span class="s1">&#39;snaphu -f </span><span class="si">{0}</span><span class="s1"> -M </span><span class="si">{1}</span><span class="s1"> -o </span><span class="si">{2}</span><span class="s1"> -c </span><span class="si">{3}</span><span class="s1"> </span><span class="si">{4}</span><span class="s1"> </span><span class="si">{5}</span><span class="s1"> </span><span class="si">{6}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">snaphuconffile</span><span class="p">,</span> <span class="n">maskbin</span><span class="p">,</span> <span class="n">outunwbin</span><span class="p">,</span> <span class="n">cohbin</span><span class="p">,</span> <span class="n">extracmd</span><span class="p">,</span> <span class="n">cpxbin</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">width</span><span class="p">))</span>
    <span class="n">runcmd</span><span class="p">(</span><span class="n">snaphucmd</span><span class="p">,</span> <span class="n">printout</span><span class="p">)</span> <span class="c1">#True)</span>
    <span class="k">if</span> <span class="n">printout</span><span class="p">:</span>
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">starttime</span>
        <span class="n">hour</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">elapsed_time</span><span class="o">/</span><span class="mi">3600</span><span class="p">)</span>
        <span class="n">minite</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">((</span><span class="n">elapsed_time</span><span class="o">/</span><span class="mi">60</span><span class="p">),</span><span class="mi">60</span><span class="p">))</span>
        <span class="n">sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span><span class="mi">60</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Elapsed time: </span><span class="si">{0:02}</span><span class="s2">h </span><span class="si">{1:02}</span><span class="s2">m </span><span class="si">{2:02}</span><span class="s2">s&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hour</span><span class="p">,</span><span class="n">minite</span><span class="p">,</span><span class="n">sec</span><span class="p">))</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="create_preview"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.create_preview">[docs]</a><span class="k">def</span> <span class="nf">create_preview</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">ftype</span> <span class="o">=</span> <span class="s1">&#39;unwrapped&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates preview of interferogram (wrapped or unwrapped) - works only with licsar_proc</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        infile (string): path to input tif to generate preview</span>
<span class="sd">        ftype (string): type of the input file. can be: &#39;wrapped&#39;, &#39;unwrapped&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;wrapped&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ftype</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;wrong ftype&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;wrapped&#39;</span><span class="p">:</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">tosource</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSARpath&#39;</span><span class="p">],</span><span class="s1">&#39;lib&#39;</span><span class="p">,</span><span class="s1">&#39;LiCSAR_bash_lib.sh&#39;</span><span class="p">)</span>
    <span class="n">command</span> <span class="o">=</span> <span class="s1">&#39;create_preview_&#39;</span><span class="o">+</span><span class="n">ftype</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;source </span><span class="si">{0}</span><span class="s1">; </span><span class="si">{1}</span><span class="s1"> </span><span class="si">{2}</span><span class="s1"> </span><span class="si">{3}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tosource</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">infile</span><span class="p">,</span> <span class="n">extra</span><span class="p">))</span></div>


<div class="viewcode-block" id="make_snaphu_conf"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_snaphu_conf">[docs]</a><span class="k">def</span> <span class="nf">make_snaphu_conf</span><span class="p">(</span><span class="n">sdir</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates snaphu configuration file</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        sdir (string): directory where to generate snaphu.conf</span>
<span class="sd">        defomax (float): DEFOMAX parameter to snaphu</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        string: path to generated snaphu.conf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">snaphuconf</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;STATCOSTMODE  DEFO</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;INFILEFORMAT  COMPLEX_DATA</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;CORRFILEFORMAT  FLOAT_DATA</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;OUTFILEFORMAT FLOAT_DATA</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ESTFILEFORMAT FLOAT_DATA</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;DEFOMAX_CYCLE &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">defomax</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;RMTMPTILE TRUE</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">snaphuconffile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sdir</span><span class="p">,</span><span class="s1">&#39;snaphu.conf&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">snaphuconffile</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">snaphuconf</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">snaphuconffile</span></div>


<div class="viewcode-block" id="make_gacos_ifg"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_gacos_ifg">[docs]</a><span class="k">def</span> <span class="nf">make_gacos_ifg</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">,</span> <span class="n">outfile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates GACOS correction for the interferogram. works only at JASMIN</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        frame (string): frame ID</span>
<span class="sd">        pair (string): pair ID (e.g. &#39;20201001_20201201&#39;)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        string: path to generated GACOS correction, or False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;preparing GACOS correction&#39;</span><span class="p">)</span>
    <span class="n">pubdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">]</span>
    <span class="n">geoframedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pubdir</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">])),</span><span class="n">frame</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
        <span class="n">epochgacos</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;epochs&#39;</span><span class="p">,</span><span class="n">epoch</span><span class="p">,</span><span class="n">epoch</span><span class="o">+</span><span class="s1">&#39;.sltd.geo.tif&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">epochgacos</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="n">epoch1</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">epoch2</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">gacos1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;epochs&#39;</span><span class="p">,</span><span class="n">epoch1</span><span class="p">,</span><span class="n">epoch1</span><span class="o">+</span><span class="s1">&#39;.sltd.geo.tif&#39;</span><span class="p">)</span>
    <span class="n">gacos2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">geoframedir</span><span class="p">,</span><span class="s1">&#39;epochs&#39;</span><span class="p">,</span><span class="n">epoch2</span><span class="p">,</span><span class="n">epoch2</span><span class="o">+</span><span class="s1">&#39;.sltd.geo.tif&#39;</span><span class="p">)</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;gmt grdmath </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1"> SUB = </span><span class="si">{2}</span><span class="s1">=gd:GTiff&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gacos2</span><span class="p">,</span> <span class="n">gacos1</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
    <span class="c1">#print(cmd)</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">outfile</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">outfile</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error in GACOS processing of pair &#39;</span><span class="o">+</span><span class="n">pair</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="remove_height_corr"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.remove_height_corr">[docs]</a><span class="k">def</span> <span class="nf">remove_height_corr</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">corr_thres</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">dounw</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">nonlinear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Removes height-correlated signal</span>
<span class="sd">    </span>
<span class="sd">     first, correlate ```ifg_ml[&#39;pha&#39;]``` and ```ifg_ml[&#39;hgt&#39;]``` in blocks</span>
<span class="sd">      - better to keep dounw=True that unwraps each block by snaphu. but it can be slow</span>
<span class="sd">     get coefficient for correction of correlating areas</span>
<span class="sd">     interpolate the coefficient throughout whole raster</span>
<span class="sd">     multiply by hgt = &#39;to_remove&#39;</span>
<span class="sd">     </span>
<span class="sd">     Args:</span>
<span class="sd">        ifg_ml (xarray.Dataset): input dataset</span>
<span class="sd">        corr_thres (float): threshold of correlation within window to keep</span>
<span class="sd">        tmpdir (string): path to temp directory</span>
<span class="sd">        dounw (boolean): whether to unwrap the small windows, or try correlate with wrapped phase</span>
<span class="sd">        nonlinear (boolean): pass nonlinear parameter to correct_hgt</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataarray: dataarray of height correlation corrections</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ifg_mlc</span> <span class="o">=</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ifg_mlc</span> <span class="o">=</span> <span class="n">filter_ifg_ml</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">)</span>
    <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span>
    <span class="n">minheight</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">hgt</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="mf">0.25</span><span class="p">)</span><span class="o">+</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">thisisit</span><span class="p">,</span> <span class="n">thistype</span> <span class="o">=</span> <span class="n">correct_hgt</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">,</span> <span class="n">blocklen</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">,</span> <span class="n">dounw</span> <span class="o">=</span> <span class="n">dounw</span><span class="p">,</span> <span class="n">nonlinear</span><span class="o">=</span><span class="n">nonlinear</span><span class="p">,</span> <span class="n">minheight</span><span class="o">=</span><span class="n">minheight</span><span class="p">)</span>
    <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">process_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Elapsed time for hgt correction: </span><span class="si">{:f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">))</span>
    <span class="c1">#thisisit can be either False, xr.DataArray, or np.float - ok, adding &#39;thistype&#39; that can be bool, float, xr</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">thistype</span> <span class="o">==</span> <span class="s1">&#39;bool&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">thistype</span> <span class="o">==</span> <span class="s1">&#39;float&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;we use average value of </span><span class="si">{}</span><span class="s1"> rad/km&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">thisisit</span><span class="o">*</span><span class="mi">1000</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;using hgt correlation grid to reduce hgt component&#39;</span><span class="p">)</span>
        <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">thisisit</span><span class="o">*</span><span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;toremove&#39;</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">block_hgtcorr</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">hgt</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">dounw</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">block_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># first unwrap the block if conditions are ok</span>
    <span class="n">toret</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">hgt</span><span class="o">=</span><span class="n">hgt</span><span class="o">.</span><span class="n">values</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ok, hgt was already np&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hgt</span><span class="p">[</span><span class="n">hgt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">toret</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">hgt</span><span class="p">[</span><span class="n">hgt</span><span class="o">!=</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">hgt</span><span class="p">[</span><span class="n">hgt</span><span class="o">!=</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">toret</span><span class="p">:</span>
        <span class="c1"># too small coherence... although it may work anyway..</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coh</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.1</span><span class="p">:</span>
            <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1">#if not toret:</span>
    <span class="c1">#    if np.mean(coh)&lt;0.05:</span>
    <span class="c1">#        toret = np.nan</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">toret</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dounw</span><span class="p">:</span>
        <span class="c1">#ok, let&#39;s do it without the unwrapping first....</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">hgt</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">cpx</span><span class="p">))</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
                        <span class="n">huber</span> <span class="o">=</span> <span class="n">HuberRegressor</span><span class="p">()</span>
                        <span class="n">rc</span> <span class="o">=</span> <span class="n">huber</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">slope</span> <span class="o">=</span> <span class="n">huber</span><span class="o">.</span><span class="n">coef_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1">#slope = np.polyfit(np.ravel(hgt), np.ravel(np.angle(cpx)), deg=1)[0]</span>
                        <span class="n">toret</span> <span class="o">=</span> <span class="n">slope</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error during pha x hgt corr&#39;</span><span class="p">)</span>
                <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">procdir</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">block_id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">block_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
            <span class="n">unwr</span> <span class="o">=</span> <span class="n">unwrap_np</span><span class="p">(</span><span class="n">cpx</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">coh</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">tmpdir</span><span class="o">=</span><span class="n">tmpdir</span><span class="p">)</span>
            <span class="c1"># ok, then correlate - and if higher then 0.4, do linear regression to get rad/m</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">hgt</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">unwr</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.4</span><span class="p">:</span>
                        <span class="n">huber</span> <span class="o">=</span> <span class="n">HuberRegressor</span><span class="p">()</span>
                        <span class="n">rc</span> <span class="o">=</span> <span class="n">huber</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">slope</span> <span class="o">=</span> <span class="n">huber</span><span class="o">.</span><span class="n">coef_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1">#slope = np.polyfit(x, y, deg=1)[0]</span>
                        <span class="n">toret</span> <span class="o">=</span> <span class="n">slope</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error during unw x hgt corr&#39;</span><span class="p">)</span>
                <span class="n">toret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">toret</span><span class="p">]])</span>


<div class="viewcode-block" id="unwrap_xr"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.unwrap_xr">[docs]</a><span class="k">def</span> <span class="nf">unwrap_xr</span><span class="p">(</span><span class="n">ifg</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">tmpdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;Quite direct unwrapping of the xarray Dataset of ifg</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        ifg (xarray.Dataset): ifg dataset</span>
<span class="sd">        mask (boolean): whether to use mask</span>
<span class="sd">        defomax (float): DEFOMAX to snaphu</span>
<span class="sd">        tmpdir (string): temp dir</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: ifg dataset now with unwrapped result</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coh</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">coh</span><span class="o">.</span><span class="n">values</span>
    <span class="n">cpx</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">cpx</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ifg</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="n">unw</span> <span class="o">=</span> <span class="n">unwrap_np</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">tmpdir</span><span class="o">=</span><span class="n">tmpdir</span><span class="p">,</span> <span class="n">deltemp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">ifg</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ifg</span><span class="p">[</span><span class="s1">&#39;unw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">unw</span>
    <span class="k">return</span> <span class="n">ifg</span></div>


<div class="viewcode-block" id="unwrap_np"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.unwrap_np">[docs]</a><span class="k">def</span> <span class="nf">unwrap_np</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">coh</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">tmpdir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">deltemp</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;unwraps given numpy array</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        cpx (numpy.ndarray): array of complex interferogram</span>
<span class="sd">        coh (numpy.ndarray): array of coherence</span>
<span class="sd">        defomax (float): DEFOMAX to snaphu</span>
<span class="sd">        tmpdir (string): temp dir</span>
<span class="sd">        mask (boolean): whether to try use binary mask (if exists)</span>
<span class="sd">        deltemp (boolean): clean temp dir after processing</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: unwrapped array</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">binmask</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;mask.bin&#39;</span><span class="p">)</span>
            <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">binmask</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">binmask</span><span class="o">=</span><span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">binmask</span><span class="o">=</span><span class="kc">None</span>
    <span class="n">bincoh</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;coh.bin&#39;</span><span class="p">)</span>
    <span class="c1">#binR = os.path.join(tmpdir,&#39;R.bin&#39;)</span>
    <span class="c1">#binI = os.path.join(tmpdir,&#39;I.bin&#39;)</span>
    <span class="n">binCPX</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;cpxifg.bin&#39;</span><span class="p">)</span>
    <span class="n">unwbin</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">,</span><span class="s1">&#39;unw.bin&#39;</span><span class="p">)</span>
    <span class="c1"># create R, I -&gt; CPX as expected by snaphu</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span> <span class="c1">#.tofile(binR)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span> <span class="c1">#.tofile(binI)</span>
    <span class="c1">#RI2cpx(binR, binI, binCPX)</span>
    <span class="n">RI2cpx</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">binCPX</span><span class="p">)</span>
    <span class="c1">#and coh</span>
    <span class="n">coh</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">bincoh</span><span class="p">)</span>
    <span class="c1"># unwrap it</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">coh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#with nostdout():</span>
    <span class="n">main_unwrap</span><span class="p">(</span><span class="n">binCPX</span><span class="p">,</span> <span class="n">bincoh</span><span class="p">,</span> <span class="n">maskbin</span> <span class="o">=</span> <span class="n">binmask</span><span class="p">,</span> <span class="n">outunwbin</span> <span class="o">=</span> <span class="n">unwbin</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">,</span> <span class="n">defomax</span> <span class="o">=</span> <span class="n">defomax</span><span class="p">,</span> <span class="n">printout</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="c1"># and load it back</span>
    <span class="n">unw1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">unwbin</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">unw1</span> <span class="o">=</span> <span class="n">unw1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">coh</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">deltemp</span><span class="p">:</span>
        <span class="c1">#shutil - delete tmpdir!!!!!</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tmpdir</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unw1</span></div>


<span class="k">def</span> <span class="nf">correct_hgt</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">,</span> <span class="n">blocklen</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">dounw</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">num_workers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nonlinear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">minheight</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">mingausscoh</span><span class="o">=</span><span class="mf">0.4</span><span class="p">):</span>
    <span class="c1">#ifg_ml[&#39;hgtcorr&#39;] = ifg_ml[&#39;pha&#39;]</span>
    <span class="n">winsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">blocklen</span><span class="p">,</span> <span class="n">blocklen</span><span class="p">)</span>
    <span class="n">cohb</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">gauss_coh</span><span class="o">&gt;</span><span class="n">mingausscoh</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">hgt</span><span class="o">&gt;</span><span class="n">minheight</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.001</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="n">winsize</span><span class="p">)</span>
    <span class="c1">#phab = da.from_array(ifg_ml[&#39;pha&#39;].astype(np.float32).fillna(0), chunks=winsize)</span>
    <span class="n">cpxb</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">gauss_coh</span><span class="o">&gt;</span><span class="n">mingausscoh</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">hgt</span><span class="o">&gt;</span><span class="n">minheight</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="n">winsize</span><span class="p">)</span>
    <span class="n">hgtb</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;hgt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">gauss_coh</span><span class="o">&gt;</span><span class="n">mingausscoh</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ifg_mlc</span><span class="o">.</span><span class="n">hgt</span><span class="o">&gt;</span><span class="n">minheight</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">chunks</span><span class="o">=</span><span class="n">winsize</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">map_blocks</span><span class="p">(</span><span class="n">block_hgtcorr</span><span class="p">,</span> <span class="n">cpxb</span><span class="p">,</span> <span class="n">cohb</span><span class="p">,</span> <span class="n">hgtb</span><span class="p">,</span> <span class="n">procdir</span> <span class="o">=</span> <span class="n">tmpdir</span><span class="p">,</span> <span class="n">dounw</span> <span class="o">=</span> <span class="n">dounw</span><span class="p">,</span> <span class="n">meta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(()),</span> <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1">#with nostdout():</span>
        <span class="n">hgtcorr</span> <span class="o">=</span>  <span class="n">f</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">num_workers</span><span class="o">=</span><span class="n">num_workers</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error in computing hgt correlation grid&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span>
    <span class="c1"># make it to xr:</span>
    <span class="n">aaa</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
    <span class="n">aaa</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifg_mlc</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">coarsen</span><span class="p">({</span><span class="s1">&#39;lat&#39;</span><span class="p">:</span> <span class="n">blocklen</span><span class="p">,</span> <span class="s1">&#39;lon&#39;</span><span class="p">:</span> <span class="n">blocklen</span><span class="p">},</span> <span class="n">boundary</span><span class="o">=</span><span class="s1">&#39;pad&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">aaa</span><span class="p">[</span><span class="s1">&#39;hgtcorr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">aaa</span><span class="p">[</span><span class="s1">&#39;coh&#39;</span><span class="p">]</span>
    <span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">hgtcorr</span>
    <span class="c1">#count means - number of non-nan data..!</span>
    <span class="k">if</span> <span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="ow">and</span> <span class="n">nonlinear</span><span class="p">:</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#interpolate nans using gaussian 2d kernel.. lower stddev, and iterate till all nans are replaced!</span>
        <span class="k">while</span> <span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="c1">#interpolate it to the higher resolution</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">aaa</span><span class="o">.</span><span class="n">hgtcorr</span><span class="o">.</span><span class="n">interp_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="c1"># but here edges are again nans!</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">Gaussian2DKernel</span><span class="p">(</span><span class="n">x_stddev</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">out</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">interpolate_replace_nans</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="n">outype</span> <span class="o">=</span> <span class="s1">&#39;xr&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#so this will take only median, to perform only linear heights correction</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">hgtcorr</span><span class="p">)</span>
        <span class="n">outype</span> <span class="o">=</span> <span class="s1">&#39;float&#39;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;all NaNs in hgt corr&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;almost nothing to reduce for hgt&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;the estimate was: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span>
    <span class="c1">#if we got here, means, now it is up to splining it to the full (ml) resolution... but --- at this moment, i will just use average value</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">outype</span>


<div class="viewcode-block" id="export_xr2tif"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.export_xr2tif">[docs]</a><span class="k">def</span> <span class="nf">export_xr2tif</span><span class="p">(</span><span class="n">xrda</span><span class="p">,</span> <span class="n">tif</span><span class="p">,</span> <span class="n">lonlat</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">debug</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dogdal</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Exports xarray dataarray to a geotiff</span>
<span class="sd">    </span>
<span class="sd">     Args:</span>
<span class="sd">        xrda (xarray.Dataarray): dataarray to export</span>
<span class="sd">        tif (string): path to output tif file</span>
<span class="sd">        lonlat (boolean): are the dimensions named as lon, lat?</span>
<span class="sd">        debug (boolean): just load it as float32</span>
<span class="sd">        dogdal (boolean): after exporting, perform gdalwarp (fix for potential issues in output geotiff)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">rioxarray</span>
    <span class="c1">#coordsys = xrda.crs.split(&#39;=&#39;)[1]</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">xrda</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">coordsys</span> <span class="o">=</span> <span class="s2">&quot;epsg:4326&quot;</span>
    <span class="k">if</span> <span class="n">lonlat</span><span class="p">:</span>
        <span class="n">xrda</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">set_spatial_dims</span><span class="p">(</span><span class="n">x_dim</span><span class="o">=</span><span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="n">y_dim</span><span class="o">=</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xrda</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">set_spatial_dims</span><span class="p">(</span><span class="n">x_dim</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y_dim</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">xrda</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">write_crs</span><span class="p">(</span><span class="n">coordsys</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dogdal</span><span class="p">:</span>
        <span class="n">xrda</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">to_raster</span><span class="p">(</span><span class="n">tif</span><span class="o">+</span><span class="s1">&#39;tmp.tif&#39;</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="s1">&#39;deflate&#39;</span><span class="p">)</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="s1">&#39;gdalwarp -t_srs EPSG:4326 </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tif</span><span class="o">+</span><span class="s1">&#39;tmp.tif&#39;</span><span class="p">,</span> <span class="n">tif</span><span class="p">)</span>
        <span class="n">runcmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">printcmd</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tif</span><span class="o">+</span><span class="s1">&#39;tmp.tif&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xrda</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">to_raster</span><span class="p">(</span><span class="n">tif</span><span class="p">,</span> <span class="n">compress</span><span class="o">=</span><span class="s1">&#39;deflate&#39;</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">create_eqa_file</span><span class="p">(</span><span class="n">eqafile</span><span class="p">,</span><span class="n">wid</span><span class="p">,</span><span class="n">nlines</span><span class="p">,</span><span class="n">cor_lat</span><span class="p">,</span><span class="n">cor_lon</span><span class="p">,</span><span class="n">post_lat</span><span class="p">,</span><span class="n">post_lon</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">eqafile</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;data_format:        REAL*4</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;DEM_hgt_offset:          0.00000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;DEM_scale:               1.00000</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;width: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">wid</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;nlines: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">nlines</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;corner_lat: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cor_lat</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;  decimal degrees</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;corner_lon: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">cor_lon</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;  decimal degrees</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;post_lat: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">post_lat</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; decimal degrees</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;post_lon: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">post_lon</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; decimal degrees</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ellipsoid_name: WGS 84</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ellipsoid_ra:        6378137.000   m</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ellipsoid_reciprocal_flattening:  298.2572236</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;datum_name: WGS 1984</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<div class="viewcode-block" id="get_fft_std"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.get_fft_std">[docs]</a><span class="k">def</span> <span class="nf">get_fft_std</span><span class="p">(</span><span class="n">inarr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    a is numpy array</span>
<span class="sd">    improvised way, not reading much about it... pure intuition (knowing this is only first step to do it right)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">a</span><span class="o">=</span><span class="n">inarr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">fshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">magnitude_spectrum</span> <span class="o">=</span> <span class="mi">20</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fshift</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">magnitude_spectrum</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>


<div class="viewcode-block" id="load_tif2xr"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.load_tif2xr">[docs]</a><span class="k">def</span> <span class="nf">load_tif2xr</span><span class="p">(</span><span class="n">tif</span><span class="p">,</span> <span class="n">cliparea_geo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolonlat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;loads geotiff to xarray.DataArray</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        tif (string): path to geotiff</span>
<span class="sd">        cliparea_geo (string): use GMT/LiCSBAS string to identify area to clip, in geo-coordinates, as ``&#39;lon1/lon2/lat1/lat2&#39;``</span>
<span class="sd">        tolonlat (boolean): if True, return as lon lat coordinates</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xr.DataArray: loaded contents</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xrpha</span> <span class="o">=</span> <span class="n">rioxarray</span><span class="o">.</span><span class="n">open_rasterio</span><span class="p">(</span><span class="n">tif</span><span class="p">)</span>
    <span class="n">xrpha</span> <span class="o">=</span> <span class="n">xrpha</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
    <span class="n">xrpha</span> <span class="o">=</span> <span class="n">xrpha</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">cliparea_geo</span><span class="p">:</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="n">cliparea_geo</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">,</span> <span class="n">maxclipy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipx</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">minclipy</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minclipy</span> <span class="o">&gt;</span> <span class="n">maxclipy</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (latitude). fixing&#39;</span><span class="p">)</span>
            <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipy</span>
            <span class="n">minclipy</span><span class="o">=</span><span class="n">maxclipy</span>
            <span class="n">maxclipy</span><span class="o">=</span><span class="n">tmpcl</span>
        <span class="k">if</span> <span class="n">minclipx</span> <span class="o">&gt;</span> <span class="n">maxclipx</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;you switched min max in crop coordinates (longitude). fixing&#39;</span><span class="p">)</span>
            <span class="n">tmpcl</span> <span class="o">=</span> <span class="n">minclipx</span>
            <span class="n">minclipx</span><span class="o">=</span><span class="n">maxclipx</span>
            <span class="n">maxclipx</span><span class="o">=</span><span class="n">tmpcl</span>
        <span class="n">xrpha</span> <span class="o">=</span> <span class="n">xrpha</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">minclipx</span><span class="p">,</span> <span class="n">maxclipx</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">maxclipy</span><span class="p">,</span> <span class="n">minclipy</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">tolonlat</span><span class="p">:</span>
        <span class="n">xrpha</span> <span class="o">=</span> <span class="n">xrpha</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;lat&#39;</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">xrpha</span></div>


<div class="viewcode-block" id="detrend_ifg_xr"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.detrend_ifg_xr">[docs]</a><span class="k">def</span> <span class="nf">detrend_ifg_xr</span><span class="p">(</span><span class="n">xrda</span><span class="p">,</span> <span class="n">isphase</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_correction</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">maxfringes</span> <span class="o">=</span> <span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Estimates ramp of (wrapped) interferogram and corrects it. Based on Doris InSARMatlab Toolbox</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        xrda (xarray.Dataarray): input data array (interferogram)</span>
<span class="sd">        isphase (boolean): input array is phase (if not, expect complex ifg)</span>
<span class="sd">        return_correction (boolean): returns also the correction</span>
<span class="sd">        maxfringes (int): max amount of fringes to consider as proper correction</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataarray: dataarray of corrected ifg</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isphase</span><span class="p">:</span>
        <span class="c1">#convert to cpx values first</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">cpx</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cpx</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">values</span>
    <span class="n">fftt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="n">cpx</span><span class="p">)</span>
    <span class="n">fftt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fftt</span><span class="p">)</span>
    <span class="c1">#remove zero line and column - often has too much of zeroes there..</span>
    <span class="n">fftt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fftt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">fftt</span> <span class="o">=</span> <span class="n">fftt</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">fftt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fftt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">fftt</span> <span class="o">=</span> <span class="n">fftt</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">numfringesx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fftt</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">numfringesy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fftt</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">[</span><span class="n">Y</span><span class="p">,</span><span class="n">X</span><span class="p">]</span><span class="o">=</span><span class="n">fftt</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">numfringesx</span> <span class="o">&gt;</span> <span class="n">X</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">numfringesx</span> <span class="o">=</span> <span class="n">numfringesx</span> <span class="o">-</span> <span class="n">X</span>
    <span class="k">if</span> <span class="n">numfringesy</span> <span class="o">&gt;</span> <span class="n">Y</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">numfringesy</span> <span class="o">=</span> <span class="n">numfringesy</span> <span class="o">-</span> <span class="n">Y</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numfringesx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxfringes</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numfringesy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxfringes</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;too many fringes identified, probably wrong. cancelling detrend&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_correction</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">da</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">da</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;detrending by </span><span class="si">{0}</span><span class="s1">/</span><span class="si">{1}</span><span class="s1"> fringes in lon/lat&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numfringesx</span><span class="p">,</span> <span class="n">numfringesy</span><span class="p">))</span>
    <span class="n">trendx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="n">numfringesx</span>
    <span class="n">trendy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">Y</span><span class="p">)</span> <span class="o">*</span> <span class="n">numfringesy</span>
    <span class="n">trendx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">trendx</span><span class="p">,</span> <span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">trendy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">trendy</span><span class="p">,</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">correction</span> <span class="o">=</span> <span class="n">trendx</span> <span class="o">+</span> <span class="n">trendy</span>
    <span class="k">if</span> <span class="n">isphase</span><span class="p">:</span>
        <span class="c1">#was phase, return phase</span>
        <span class="n">da</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">wrap2phase</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">correction</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">cpx_corr</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">mag</span><span class="p">,</span> <span class="n">correction</span><span class="p">)</span>
        <span class="c1">#a trick to apply the correction only to non-nan values.. &#39;other&#39;</span>
        <span class="c1">#da = da.where(xrda.isnull(), other=da.values * np.conjugate(cpx_corr))</span>
        <span class="n">da</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">cpx_corr</span><span class="p">)</span>
        <span class="c1">#da.where(xrcpx.isnull()) = 0</span>
    <span class="k">if</span> <span class="n">return_correction</span><span class="p">:</span>
        <span class="n">corrda</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">corrda</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">correction</span>
        <span class="k">return</span> <span class="n">da</span><span class="p">,</span> <span class="n">corrda</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">da</span></div>

    
<div class="viewcode-block" id="filter_ifg_ml"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.filter_ifg_ml">[docs]</a><span class="k">def</span> <span class="nf">filter_ifg_ml</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">calc_coh_from_delta</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">trunc</span> <span class="o">=</span> <span class="mi">4</span><span class="p">):</span> <span class="c1">#, sigma = 1, trunc = 2):  #, rotate = False):</span>
    <span class="sd">&quot;&quot;&quot;Normalises interferogram and performs Gaussian filtering (expects proper structure of the ifg dataset).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        ifg_ml (xarray.Dataset): input xr dataset (interferogram) - must contain ``pha`` data_var</span>
<span class="sd">        calc_coh_from_delta (boolean): will calculate local variance and use to improve ``gauss_coh`` measure</span>
<span class="sd">        radius (float): length of the Gaussian window in metres</span>
<span class="sd">        trunc (int): truncation of std dev for Gaussian window, by default trunc=4 and this is recommended for the shape</span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: dataset that includes filtering results (as ``gauss_pha``, ``gauss_coh``, ``gauss_cpx``)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get sigma, trunc from radius [m], converted to pixels using resolution</span>
    <span class="n">resolution</span> <span class="o">=</span> <span class="n">get_resolution</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">in_m</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">radius_px</span> <span class="o">=</span> <span class="n">radius</span><span class="o">/</span><span class="n">resolution</span>
    <span class="c1">#width_filter = 2*int( trunc*sigma + 0.5) +1  # definition within scipy ndimage filters.py - gaussian_filter1d</span>
    <span class="c1">#width_filter = 2*radius_px</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="p">(</span><span class="n">radius_px</span> <span class="o">-</span> <span class="mf">1.5</span><span class="p">)</span><span class="o">/</span><span class="n">trunc</span>
    <span class="c1">#normalise mag</span>
    <span class="n">tempar_mag1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="p">)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;cpx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">magpha2RI_array</span><span class="p">(</span><span class="n">tempar_mag1</span><span class="p">,</span> <span class="n">ifg_ml</span><span class="o">.</span><span class="n">pha</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filter using (adapted) gauss filter&#39;</span><span class="p">)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_cpx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_cpx_gauss</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">trunc</span> <span class="o">=</span> <span class="n">trunc</span><span class="p">)</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_pha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_pha&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_cpx</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="c1">#use magnitude after filtering as coherence</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_coh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">]</span>
    <span class="c1"># that is great but has problems at maxima of cos or sin</span>
    <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ifg_ml</span><span class="o">.</span><span class="n">gauss_cpx</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">calc_coh_from_delta</span><span class="p">:</span>
        <span class="c1"># if using the coh from the phase residuals (based on variance), it </span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_pha&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;pha&#39;</span><span class="p">])))</span>
        <span class="c1">#aaa = coh_from_phadiff(delta, winsize=5)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;calculating coh from phase diff&#39;</span><span class="p">)</span>
        <span class="n">phacoh</span> <span class="o">=</span> <span class="n">coh_from_phadiff</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># this should be much better:</span>
        <span class="c1">#ifg_ml[&#39;gauss_coh&#39;].values = 1-np.abs(delta)/np.pi</span>
        <span class="c1">#but it is not actually. so i am using max of gauss_coh and phacoh:</span>
        <span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">ifg_ml</span><span class="p">[</span><span class="s1">&#39;gauss_coh&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">phacoh</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ifg_ml</span></div>



<div class="viewcode-block" id="wrap2phase"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.wrap2phase">[docs]</a><span class="k">def</span> <span class="nf">wrap2phase</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wraps array to -pi,pi (or 0,2pi?)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">A</span><span class="p">))</span></div>


<div class="viewcode-block" id="make_avg_amp"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_avg_amp">[docs]</a><span class="k">def</span> <span class="nf">make_avg_amp</span><span class="p">(</span><span class="n">mlitiflist</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates average amplitude from list of MLI tiffs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avgamp</span> <span class="o">=</span> <span class="n">hgtxr</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">nopixels</span> <span class="o">=</span> <span class="n">avgamp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ampf</span> <span class="ow">in</span> <span class="n">mlitiflist</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">read_geotiff</span><span class="p">(</span><span class="n">ampf</span><span class="p">)</span> <span class="c1">#/ 255</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error reading &#39;</span><span class="o">+</span><span class="n">ampf</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">amp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">amp</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nopixels</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">amp</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">avgamp</span> <span class="o">=</span> <span class="n">avgamp</span> <span class="o">+</span> <span class="n">amp</span>
    <span class="n">avgamp</span> <span class="o">=</span> <span class="n">avgamp</span><span class="o">/</span><span class="n">nopixels</span>
    <span class="k">return</span> <span class="n">avgamp</span></div>


<div class="viewcode-block" id="make_std_amp"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_std_amp">[docs]</a><span class="k">def</span> <span class="nf">make_std_amp</span><span class="p">(</span><span class="n">mlitiflist</span><span class="p">,</span> <span class="n">avgamp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates standard deviation of amplitude from list of MLI tiffs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">avgvar</span> <span class="o">=</span> <span class="n">avgamp</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">nopixels</span> <span class="o">=</span> <span class="n">avgvar</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ampf</span> <span class="ow">in</span> <span class="n">mlitiflist</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">read_geotiff</span><span class="p">(</span><span class="n">ampf</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error reading &#39;</span><span class="o">+</span><span class="n">ampf</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">amp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">amp</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nopixels</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">amp</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">avgvar</span> <span class="o">=</span> <span class="n">avgvar</span> <span class="o">+</span> <span class="p">(</span><span class="n">amp</span> <span class="o">-</span> <span class="n">avgamp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># correct for ddof</span>
    <span class="n">sumpx</span> <span class="o">=</span> <span class="n">nopixels</span> <span class="o">-</span> <span class="n">ddof</span>
    <span class="c1">#sumpx[sumpx&lt;1] = np.nan</span>
    <span class="n">sumpx</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">sumpx</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">avgstd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">avgvar</span><span class="o">/</span><span class="n">sumpx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">avgstd</span></div>


<div class="viewcode-block" id="make_avg_coh"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_avg_coh">[docs]</a><span class="k">def</span> <span class="nf">make_avg_coh</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates average coherence from &#39;group&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">avgcoh</span> <span class="o">=</span> <span class="n">hgtxr</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">nopixels</span> <span class="o">=</span> <span class="n">avgcoh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cohf</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;cohf&#39;</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">read_geotiff</span><span class="p">(</span><span class="n">cohf</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error reading &#39;</span><span class="o">+</span><span class="n">cohf</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">coh</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coh</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nopixels</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">coh</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">avgcoh</span> <span class="o">=</span> <span class="n">avgcoh</span> <span class="o">+</span> <span class="n">coh</span>
    <span class="n">avgcoh</span> <span class="o">=</span> <span class="n">avgcoh</span><span class="o">/</span><span class="n">nopixels</span>
    <span class="k">return</span> <span class="n">avgcoh</span></div>


<div class="viewcode-block" id="make_std_coh"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.make_std_coh">[docs]</a><span class="k">def</span> <span class="nf">make_std_coh</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">avgcoh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates standard deviation of coherence from &#39;group&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">avgvar</span> <span class="o">=</span> <span class="n">avgcoh</span><span class="o">*</span><span class="mi">0</span>
    <span class="n">nopixels</span> <span class="o">=</span> <span class="n">avgvar</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cohf</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="s1">&#39;cohf&#39;</span><span class="p">]:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">coh</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">read_geotiff</span><span class="p">(</span><span class="n">cohf</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error reading &#39;</span><span class="o">+</span><span class="n">cohf</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">coh</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coh</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nopixels</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">coh</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">avgvar</span> <span class="o">=</span> <span class="n">avgvar</span> <span class="o">+</span> <span class="p">(</span><span class="n">coh</span> <span class="o">-</span> <span class="n">avgcoh</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># correct for ddof</span>
    <span class="n">sumpx</span> <span class="o">=</span> <span class="n">nopixels</span> <span class="o">-</span> <span class="n">ddof</span>
    <span class="c1">#sumpx[sumpx&lt;1] = np.nan</span>
    <span class="n">sumpx</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">sumpx</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">avgstd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">avgvar</span><span class="o">/</span><span class="n">sumpx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">avgstd</span></div>


<span class="k">def</span> <span class="nf">get_date_matrix</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
    <span class="n">date_matrix</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">])</span>
    <span class="n">date_matrix</span><span class="p">[</span><span class="s1">&#39;date1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">date_matrix</span><span class="o">.</span><span class="n">pair</span><span class="o">.</span><span class="n">str</span><span class="p">[:</span><span class="mi">8</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">date_matrix</span><span class="p">[</span><span class="s1">&#39;date2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">date_matrix</span><span class="o">.</span><span class="n">pair</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">9</span><span class="p">:],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">date_matrix</span><span class="p">[</span><span class="s1">&#39;btemp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">date_matrix</span><span class="o">.</span><span class="n">date2</span> <span class="o">-</span> <span class="n">date_matrix</span><span class="o">.</span><span class="n">date1</span>
    <span class="n">date_matrix</span> <span class="o">=</span> <span class="n">date_matrix</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;pair&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">date_matrix</span>


<div class="viewcode-block" id="build_amp_avg_std"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.build_amp_avg_std">[docs]</a><span class="k">def</span> <span class="nf">build_amp_avg_std</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">return_ampstab</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Builds amplitude stability map (or just avg/std amplitude) of a frame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">track</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>
    <span class="n">epochsdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">],</span> <span class="n">track</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="s1">&#39;epochs&#39;</span><span class="p">)</span>
    <span class="n">hgtfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">],</span> <span class="n">track</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="s1">&#39;metadata&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.hgt.tif&#39;</span><span class="p">)</span>
    <span class="n">hgtxr</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_rasterio</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">))</span>
    <span class="n">hgtxr</span> <span class="o">=</span> <span class="n">hgtxr</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
    <span class="n">mlitiflist</span> <span class="o">=</span> <span class="n">fc</span><span class="o">.</span><span class="n">get_epochs</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">return_mli_tifs</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;generating amp average&#39;</span><span class="p">)</span>
    <span class="n">ampavg</span> <span class="o">=</span> <span class="n">make_avg_amp</span><span class="p">(</span><span class="n">mlitiflist</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;generating amp std&#39;</span><span class="p">)</span>
    <span class="n">ampstd</span> <span class="o">=</span> <span class="n">make_std_amp</span><span class="p">(</span><span class="n">mlitiflist</span><span class="p">,</span> <span class="n">ampavg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_ampstab</span><span class="p">:</span>
        <span class="n">ampstab</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ampstd</span><span class="o">/</span><span class="n">ampavg</span>
        <span class="n">ampstab</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">ampstab</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.00001</span>
        <span class="k">return</span> <span class="n">ampstab</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ampavg</span><span class="p">,</span> <span class="n">ampstd</span></div>


<div class="viewcode-block" id="build_coh_avg_std"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.build_coh_avg_std">[docs]</a><span class="k">def</span> <span class="nf">build_coh_avg_std</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">ifgdir</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">days</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">monthly</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">outnopx</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">do_std</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">do_tif</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Builds coherence stability map (or just avg/std coherence) of a frame</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">track</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ifgdir</span><span class="p">:</span>
        <span class="n">ifgdir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">],</span> <span class="n">track</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="s1">&#39;interferograms&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">get_ifgdates</span><span class="p">(</span><span class="n">ifgdir</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;error, dropping frame &#39;</span><span class="o">+</span><span class="n">frame</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">pairsall</span> <span class="o">=</span> <span class="n">get_date_matrix</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
    <span class="n">pairsall</span><span class="p">[</span><span class="s1">&#39;pair&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pairsall</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="n">pairsall</span><span class="p">[</span><span class="s1">&#39;cohf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifgdir</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">pairsall</span><span class="o">.</span><span class="n">pair</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">pairsall</span><span class="o">.</span><span class="n">pair</span> <span class="o">+</span> <span class="s1">&#39;.geo.cc.tif&#39;</span>
    <span class="k">if</span> <span class="n">days</span> <span class="o">!=</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">pairsall</span><span class="p">[</span><span class="n">pairsall</span><span class="o">.</span><span class="n">btemp</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">days</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; days&#39;</span><span class="p">]</span>
    <span class="c1">#pairs[&#39;datetocheck&#39;] = pairs.date1 + pd.Timedelta(&#39;6 days&#39;)</span>
    <span class="c1">#pairs[&#39;month&#39;] = pairs[&#39;datetocheck&#39;].dt.month</span>
    <span class="n">hgtfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">],</span> <span class="n">track</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="s1">&#39;metadata&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.hgt.tif&#39;</span><span class="p">)</span>
    <span class="n">hgtxr</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_rasterio</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">hgtfile</span><span class="p">))</span>
    <span class="n">hgtxr</span> <span class="o">=</span> <span class="n">hgtxr</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">monthly</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;generating coh average&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">days</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;fast written solution, will output xr Dataset of avg cohs&#39;</span><span class="p">)</span>
            <span class="n">coherences</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
            <span class="c1">#ndays = pairsall.btemp.dt.days.unique()</span>
            <span class="c1">#ndays.sort()</span>
            <span class="n">daygroups</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">),</span> <span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="mi">24</span><span class="p">),</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">42</span><span class="p">),</span> <span class="p">(</span><span class="mi">48</span><span class="p">,</span><span class="mi">72</span><span class="p">),</span> <span class="p">(</span><span class="mi">78</span><span class="p">,</span><span class="mi">96</span><span class="p">),</span> <span class="p">(</span><span class="mi">102</span><span class="p">,</span><span class="mi">156</span><span class="p">),</span> <span class="p">(</span><span class="mi">162</span><span class="p">,</span><span class="mi">200</span><span class="p">),</span> <span class="p">(</span><span class="mi">201</span><span class="p">,</span><span class="mi">300</span><span class="p">),</span> <span class="p">(</span><span class="mi">301</span><span class="p">,</span><span class="mi">400</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">daygroup</span> <span class="ow">in</span> <span class="n">daygroups</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;preparing coh avgs for btemp between </span><span class="si">{0}</span><span class="s1"> and </span><span class="si">{1}</span><span class="s1"> days&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">daygroup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">daygroup</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">pairs</span> <span class="o">=</span> <span class="n">pairsall</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">pairsall</span><span class="o">.</span><span class="n">btemp</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">days</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">daygroup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">daygroup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))]</span>
                <span class="c1">#now, this will select in periods between 1st March and 1st September</span>
                <span class="k">for</span> <span class="n">setX</span> <span class="ow">in</span> <span class="p">[([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="s1">&#39;summer&#39;</span><span class="p">),</span> <span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;winter&#39;</span><span class="p">)]:</span>
                    <span class="n">setX_time</span> <span class="o">=</span> <span class="n">setX</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">setX_label</span> <span class="o">=</span> <span class="n">setX</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">center_date</span> <span class="o">=</span> <span class="n">pairs</span><span class="o">.</span><span class="n">date1</span><span class="o">+</span><span class="p">(</span><span class="n">pairs</span><span class="o">.</span><span class="n">date2</span><span class="o">-</span><span class="n">pairs</span><span class="o">.</span><span class="n">date1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
                    <span class="n">setA</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">center_date</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span><span class="p">,</span><span class="n">setX_time</span><span class="p">)]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">setA</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">cohavgA</span> <span class="o">=</span> <span class="n">make_avg_coh</span><span class="p">(</span><span class="n">setA</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">)</span>
                        <span class="n">cohavgA</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;number of input cohs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">setA</span><span class="p">)</span>
                        <span class="n">nameA</span> <span class="o">=</span> <span class="s1">&#39;mean coh </span><span class="si">{0}</span><span class="s1">-</span><span class="si">{1}</span><span class="s1"> days </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">daygroup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">daygroup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">setX_label</span><span class="p">)</span>
                        <span class="n">coherences</span><span class="p">[</span><span class="n">nameA</span><span class="p">]</span> <span class="o">=</span> <span class="n">cohavgA</span>
                <span class="c1"># cohavgB.plot(vmin=0,vmax=0.9)</span>
                <span class="c1"># plt.show()</span>
                <span class="c1">#for ddays in days:</span>
                <span class="c1"># </span>
            <span class="k">return</span> <span class="n">coherences</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cohavg</span> <span class="o">=</span> <span class="n">make_avg_coh</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">do_std</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;generating coh std&#39;</span><span class="p">)</span>
                <span class="n">cohstd</span> <span class="o">=</span> <span class="n">make_std_coh</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">cohavg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cohstd</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pairs</span><span class="p">[</span><span class="s1">&#39;month&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="s1">&#39;date1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">pairs</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;month&#39;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;preparing month &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; from </span><span class="si">{}</span><span class="s1"> coh maps&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))))</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">make_avg_coh</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">hgtxr</span><span class="p">)</span>
            <span class="n">outtif</span> <span class="o">=</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.avg_coh.month&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.tif&#39;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;exporting to &#39;</span><span class="o">+</span><span class="n">outtif</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">write_crs</span><span class="p">(</span><span class="s2">&quot;epsg:4326&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">rio</span><span class="o">.</span><span class="n">to_raster</span><span class="p">(</span><span class="n">outtif</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">do_tif</span><span class="p">:</span>
        <span class="n">outtif</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;LiCSAR_public&#39;</span><span class="p">],</span> <span class="n">track</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="s1">&#39;metadata&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">+</span><span class="s1">&#39;.geo.meancoh.&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">days</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;.tif&#39;</span><span class="p">)</span>
        <span class="n">nopx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        <span class="n">cohavg</span> <span class="o">=</span> <span class="p">(</span><span class="n">cohavg</span><span class="o">*</span><span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">cohavg</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;NUMBER_OF_INPUT_FILES&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nopx</span>
        <span class="n">cohavg</span> <span class="o">=</span> <span class="n">cohavg</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;lon&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;lat&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">sortby</span><span class="p">([</span><span class="s1">&#39;lon&#39;</span><span class="p">,</span><span class="s1">&#39;lat&#39;</span><span class="p">])</span>
        <span class="n">export_xr2tif</span><span class="p">(</span><span class="n">cohavg</span><span class="p">,</span> <span class="n">outtif</span><span class="p">,</span> <span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">outnopx</span><span class="p">:</span>
        <span class="n">nopx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cohavg</span><span class="p">,</span> <span class="n">cohstd</span><span class="p">,</span> <span class="n">nopx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cohavg</span><span class="p">,</span> <span class="n">cohstd</span></div>






<span class="c1">#### extra functions (not used in the workflow, but considered useful!)</span>

<div class="viewcode-block" id="deramp_unw"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.deramp_unw">[docs]</a><span class="k">def</span> <span class="nf">deramp_unw</span><span class="p">(</span><span class="n">xrda</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span><span class="s1">&#39;lon&#39;</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Deramps unwrapped interferogram</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">da</span> <span class="o">=</span> <span class="n">xrda</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">apply_ufunc</span><span class="p">(</span>
                    <span class="n">_detrend_2d_ufunc</span><span class="p">,</span>
                    <span class="n">da</span><span class="p">,</span>
                    <span class="n">input_core_dims</span><span class="o">=</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span>
                    <span class="n">output_core_dims</span><span class="o">=</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span>
                    <span class="n">output_dtypes</span><span class="o">=</span><span class="p">[</span><span class="n">da</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span>
                    <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">dask</span><span class="o">=</span><span class="s2">&quot;parallelized&quot;</span><span class="p">,</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">dt</span></div>


<span class="k">def</span> <span class="nf">_detrend_2d_ufunc</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">col0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">col1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">col2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">col0</span><span class="p">,</span> <span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">d_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">m_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">spl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">G</span><span class="p">)),</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">d_obs</span><span class="p">)</span>
    <span class="n">d_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">m_est</span><span class="p">)</span>
    <span class="n">linear_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">d_est</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arr</span> <span class="o">-</span> <span class="n">linear_fit</span>


<div class="viewcode-block" id="deramp_ifg_tif"><a class="viewcode-back" href="../../../../licsar_proc/apidoc.html#licsar_proc.python.LiCSAR_lib.lics_unwrap.deramp_ifg_tif">[docs]</a><span class="k">def</span> <span class="nf">deramp_ifg_tif</span><span class="p">(</span><span class="n">phatif</span><span class="p">,</span> <span class="n">unwrap_after</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Deramps wrapped interferogram geotiff</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># works fine if the path is to some diff_pha.tif file inside $LiCSAR_public only!</span>
    <span class="n">phatif</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">phatif</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">phatif</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;the input tif does not exist, exiting&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">xrpha</span> <span class="o">=</span> <span class="n">load_tif2xr</span><span class="p">(</span><span class="n">phatif</span><span class="p">)</span>
    <span class="n">xrpha_detrended</span> <span class="o">=</span> <span class="n">detrend_ifg_xr</span><span class="p">(</span><span class="n">xrpha</span><span class="p">,</span> <span class="n">isphase</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">xrpha_detrended</span> <span class="o">=</span> <span class="n">xrpha_detrended</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">xrpha</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">phatif_orig</span> <span class="o">=</span> <span class="n">phatif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.diff_pha.orig.tif&#39;</span><span class="p">)</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;mv </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phatif</span><span class="p">,</span> <span class="n">phatif_orig</span><span class="p">))</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;mv </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phatif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.diff.png&#39;</span><span class="p">),</span> 
       <span class="n">phatif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.diff.orig.png&#39;</span><span class="p">)))</span>
    <span class="n">export_xr2tif</span><span class="p">(</span><span class="n">xrpha_detrended</span><span class="p">,</span> <span class="n">phatif</span><span class="p">)</span>
    <span class="c1"># just do also preview</span>
    <span class="n">create_preview</span><span class="p">(</span><span class="n">phatif</span><span class="p">,</span> <span class="s1">&#39;wrapped&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">unwrap_after</span><span class="p">:</span>
        <span class="c1"># and probably reunwrapping is needed...</span>
        <span class="c1"># doing it original way</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">phatif</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">pair</span> <span class="o">=</span> <span class="n">phatif</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">unwtif</span> <span class="o">=</span> <span class="n">phatif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.diff_pha.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">)</span>
        <span class="n">unwtif_orig</span> <span class="o">=</span> <span class="n">unwtif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.unw.orig.tif&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;mv </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unwtif</span><span class="p">,</span> <span class="n">unwtif_orig</span><span class="p">))</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;mv </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unwtif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.unw.png&#39;</span><span class="p">),</span> <span class="n">unwtif</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.geo.unw.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.geo.unw.orig.png&#39;</span><span class="p">)))</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s1">&#39;unwrap_geo.sh </span><span class="si">{0}</span><span class="s1"> </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">pair</span><span class="p">))</span></div>
        <span class="c1">#or using this approach? well... it takes some 5x+ longer!!!, so perhaps not</span>
        <span class="c1">#outtif = phatif.replace(&#39;.geo.diff_pha.tif&#39;,&#39;.geo.unw.tif&#39;)</span>
        <span class="c1">#process_ifg(frame, pair, ml = 1, pre_detrend = False, outtif = outtif)</span>
    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, COMET and CEMAC teams.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>